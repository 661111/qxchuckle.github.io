<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>第一篇文章：一点小小的说明与介绍</title>
    <url>/article/ff73d561.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><font size="2">&emsp;&emsp;<strong>大鸭鸭镇文(误)</strong></font></p>
<div align=left><img src=/images/1-1.webp width="50%" height="50%"><img src=/images/1-2.webp width="50%" height="50%"></div>
<span id="more"></span>

<hr>
<h1 id="本博的说明"><a href="#本博的说明" class="headerlink" title="本博的说明"></a>本博的说明</h1><p>1.目前记录自己学习编程之路</p>
<p>2.酷安机佬分享搞机</p>
<p>3.记录日常</p>
<p>4.欢迎交换友链</p>
<p>5.更多</p>
<hr>
<h1 id="写博原因"><a href="#写博原因" class="headerlink" title="写博原因"></a>写博原因</h1><blockquote>
<p>不写博客不知道自己多牛B，写了博客就知道自己多lowB<br><del>博客不是你想写，想写就能写，这玩意儿需要大量知识，沉淀，研究，总结</del><br>博客就是自己想什么就写什么的哈，比如有个瞬间想法也可以写进去，记录下来！何必在意那么多！<br><del>把工作中需要用的技术和实现代码写到博客里，下次再用上就直接复制粘贴</del></p>
<blockquote>
<p>来自评论区<a href="https://www.bilibili.com/video/BV1334y1q72q">bilibili评论区</a> </p>
</blockquote>
</blockquote>
<p>写博明确的好处————CodeSheep<br>1.培养总结能力<br>2.面试加分项<br>3.让自己的知识在某个地方留下痕迹，不流失<br>4.加深对技术点的理解(写的过程=复现)<br>5.帮助自己创建一个属于自己的知识体系<br>6.踩坑记录<br>7.获得阅读量，提高知名度，结交志同道合的朋友<br>8.提高表达与写作能力<br>9.·····</p>
<p><strong>总之写博是提升自己方便自己的好途径</strong><br>作为一只计科大一<font size=2><del>带学牲</del></font>，未来的程序员，写博是必要的</p>
<hr>
<h1 id="CodeSheep的tip"><a href="#CodeSheep的tip" class="headerlink" title="CodeSheep的tip"></a>CodeSheep的tip</h1><blockquote>
<p>写博客可以系统地整合自己某一阶段的学习成果</p>
</blockquote>
<blockquote>
<p>博客的方向：<br>可复现，能否解决实际问题</p>
</blockquote>
<blockquote>
<p>注意：<br>尊重知识产权，用别人的代码或者语言，记得表明来源。</p>
</blockquote>
<blockquote>
<p>入门：<br>备忘录，基础理解，踩坑的记录分享、学习笔记<br>实战类：<br>环境搭建，操作记录</p>
</blockquote>
<hr>
<h1 id="为什么用hexo搭博客"><a href="#为什么用hexo搭博客" class="headerlink" title="为什么用hexo搭博客"></a>为什么用hexo搭博客</h1><p>1.静态博客够用了</p>
<p>2.hexo用的人多，遇到问题百度好解决</p>
<p>3.主题丰富</p>
<p>4.无需服务器 <del>部署到github/gitee无需软妹币</del></p>
]]></content>
      <categories>
        <category>Chuckle</category>
      </categories>
      <tags>
        <tag>Chuckle</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客的基本操作</title>
    <url>/article/aa2a7b7e.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p><strong>Hexo官方文档:</strong><a href="https://hexo.io/zh-cn/docs">Hexo</a></p>
</blockquote>
<h1 id="Hexo操作"><a href="#Hexo操作" class="headerlink" title="Hexo操作"></a>Hexo操作</h1><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><figure class="highlight js"><figcaption><span>新建文章，在blog\source\_posts</span></figcaption><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> post (文章名称)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><figcaption><span>新建页面，在blog\source</span></figcaption><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> page (页面名称)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><figcaption><span>清除缓存文件 (db.json) 和已生成的静态文件 (public)</span></figcaption><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><figcaption><span>生成静态文件</span></figcaption><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><figcaption><span>启动服务器，访问网址:http://localhost:4000</span></figcaption><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><figcaption><span>部署网站</span></figcaption><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><figcaption><span>hexo三连,四连</span></figcaption><table><tr><td class="code"><pre><span class="line">hexo cl &amp;&amp; hexo g &amp;&amp; hexo s</span><br><span class="line">hexo cl &amp;&amp; hexo g &amp;&amp; gulp &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>
<br>

<h2 id="文章操作"><a href="#文章操作" class="headerlink" title="文章操作"></a>文章操作</h2><blockquote>
<p><strong>Markdown 教程</strong><br><a href="https://www.runoob.com/markdown/md-tutorial.html">菜鸟教程</a><br><a href="http://markdown.p2hp.com/basic-syntax/">官网–Markdown基本语法</a></p>
</blockquote>
<blockquote>
<p><strong>blog\scaffolds中修改三种文章模板</strong></p>
</blockquote>
<blockquote>
<p>#(空格)一级标题<br>##二级标题<br>###三级标题</p>
</blockquote>
<blockquote>
<p><em>斜体文本</em> &emsp;*斜体文本*<br><strong>粗体文本</strong> &emsp;**粗体文本**<br><em><strong>粗斜体文本</strong></em> &emsp;***粗斜体文本***<br><del>横线删除</del> &emsp;~~横线删除~~ </p>
</blockquote>
<blockquote>
<p>***水平分割线</p>
</blockquote>
<figure class="highlight html"><figcaption><span>文字蓝链</span></figcaption><table><tr><td class="code"><pre><span class="line">文字内容[tittle](https://*******)</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><figcaption><span>文章中自定义文本，size文字大小，face字体，color颜色，&emsp空格</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span>=<span class="string">&quot;2&quot;</span> <span class="attr">face</span>=<span class="string">&quot;verdana&quot;</span> <span class="attr">color</span>=<span class="string">&quot;blue&quot;</span> &gt;</span><span class="symbol">&amp;emsp;</span>这是一个文本<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><figcaption><span>插入自定义图片,</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">left</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">1.png</span> <span class="attr">width</span>=<span class="string">&quot;25%&quot;</span> <span class="attr">height</span>=<span class="string">&quot;25%&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">left</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">1.png</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">2.png</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">![文本](图片地址 &quot;鼠标悬停弹出文本提示&quot;)</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>测试用文章</title>
    <url>/article/d87f7e0c.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>test</p>
<p>test</p>
<span id="more"></span>
<p>test</p>
<p>test<br>看看能不能自动同步<br>test</p>
]]></content>
      <categories>
        <category>Test</category>
      </categories>
      <tags>
        <tag>Test</tag>
      </tags>
  </entry>
  <entry>
    <title>博客搜索挂了解决方法</title>
    <url>/article/f8c79a1b.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>省流助手：删除所有local-search.js中下面这行代码<br>window.pjax &amp;&amp; window.pjax.refresh($resultContent)</p>
</blockquote>
<h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p>我使用的是本地搜索，local-search，装好后一直正常使用，也没去动过配置<br>前天捣鼓着博客，突然发现博客部署到github上后搜索挂了</p>
<div><img src=/images/4-2.webp width="60%" height="60%"></div>
一直卡在数据库加载中

<p>但是，部署在本地，搜索却一切正常</p>
<div><img src=/images/4-3.webp width="60%" height="60%"></div>
尝试过重装插件，清除浏览器缓存，search.xml改为json，但过一会又挂了

<p>看网上也有不少人遇到这种问题，却找不到解决办法</p>
<hr>
<h1 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h1><p>遇事不决f12，我禁我自己（误）</p>
<div><img src=/images/4-4.webp width="40%" height="40%"></div>
local-search会请求生成在本地的search.xml，也就是数据库加载中里的“数据库”

<p>部署在本地时正常请求</p>
<div><img src=/images/4-8.webp width="80%" height="80%"></div>
而部署在github时没有请求
<div><img src=/images/4-9.webp width="65%" height="65%"></div>
直接访问search.xml正常，不是search.xml的问题
<div><img src=/images/4-5.webp width="60%" height="60%"></div>
查看报错，看起来是这个js的问题
<div><img src=/images/4-6.webp width="60%" height="60%"></div>
本地找到local-search.js，这三个代码都一样
<div><img src=/images/4-7.webp width="60%" height="60%"></div>
js中只有一处pjax报错
<div><img src=/images/4-10.webp width="60%" height="60%"></div>
类型“Window & typeof globalThis”上不存在属性“pjax”。ts(2339)  


<p>看不懂这种报错，但问题多半就是这行代码导致的，查看整个js后，尝试删除此行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">window.pjax &amp;&amp; window.pjax.refresh($resultContent)</span><br></pre></td></tr></table></figure>
<p>删除后，搜索挂了的问题解决，博客正常请求search.xml</p>
<div><img src=/images/4-8.webp width="70%" height="70%"></div>

<p>但点击搜索结果后pjax失效，具体表现是aplayer停止播放音乐</p>
<p>看来是pjax的bug，不过感知不强，其余地方的pjax仍然生效</p>
<p>暂时先这样，以后找到更好的解决办法再更新</p>
<hr>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Butterfly</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言学习笔记</title>
    <url>/article/13675369.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h1><p>两个整数运算结果也只能是整数<br>a+=5等价于a=a+5<br>a*=b+5等价于a=a*(b+5)<br>a++等a+=1等a=a+1<br>a++是a加1以前的值，++a是a加1后的值<br>运算符优先级：算数&gt;关系&gt;赋值，判断是否相等的优先级比大于小于低</p>
<hr>
<h1 id="所表达的数的范围"><a href="#所表达的数的范围" class="headerlink" title="所表达的数的范围"></a>所表达的数的范围</h1><p>char&lt; short&lt;int&lt; float&lt;double</p>
<hr>
<h1 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof()"></a>sizeof()</h1><p>sizeof()是一个运算符,给出某个类型或变量在内存中所占据的字节数<br>sizeof()是静态运算符,它的结果在编译时刻就决定了，不要在 sizeof的括号里做运算,这些运算不会做的</p>
<hr>
<h1 id="unsigned"><a href="#unsigned" class="headerlink" title="unsigned"></a>unsigned</h1><p>unsigned：如果一个字面量常数想要表达自己是 unsigned,可以在后面加u或U，255U用l或L表示long(long)<br>unsigned的初衷并非扩展数能表达的范围,而是为了做纯二进制运算,主要是为了移位</p>
<hr>
<h1 id="整数的输入输出"><a href="#整数的输入输出" class="headerlink" title="整数的输入输出"></a>整数的输入输出</h1><p>只有两种形式:int或 long long<br>%d: int<br>%u: unsigned<br>%ld: longlong<br>%lu: unsigned long long</p>
<hr>
<h1 id="选搔整数类型"><a href="#选搔整数类型" class="headerlink" title="选搔整数类型"></a>选搔整数类型</h1><p>为什么整数要有那么多种?为了准确表达内存,做底层程序的需要<br>没有特殊需要,就选int<br>现在的CPU的字长普遍是32位或64位,一次内存该写就是个int,一次计算也是一个int,选择更短的类型不会更快,甚至可能更慢<br>现代的编译器一般会设计内存对齐,所以更短的类型实际在内存中有可能也占据一个int的大小(虽然sizeof告诉你更小)</p>
<hr>
<p>unsigned与否只是输出的不同,内部计算是一样的<br>printf输出inf表示超过范围的浮点数:±∞<br>print输出nan表示不存在的浮点数<br>带小数点的字面量是 double而非 float<br>float需要用或F后綴来表明身份<br>1.234f</p>
<hr>
<p>判断两个浮点数是否相等可能失败<br>fabs(fl-2)&lt; le-2//两个浮点数相减的绝对值小于一个很小的数，可认为两个浮点数相等</p>
<hr>
<h1 id="选浮点类型"><a href="#选浮点类型" class="headerlink" title="选浮点类型"></a>选浮点类型</h1><p>如果没有特殊需要,只使用 double<br>现代CPU能直接对 double做硬件运算,性能不会比float差,在64位的机器上,数据存儲的速度也不比float慢</p>
<hr>
<h1 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h1><p>当运算符的两边出现不一致的类型时,会自动转换成較大的类型<br>大的意思是能表达的数的范围更大<br>char——&gt; short——&gt;int——&gt;long——&gt;long long<br>int——&gt; float——&gt; double<br>对于 printf,任何小于int的类型会被转换成int，float会被转换成 double<br>但是scanf不会,要输入short,需要%hd</p>
<hr>
<h1 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h1><p>要把一个量强制转换成另一个类型(通常是較小的类型),需要:(类型)值<br>比如：<br>(int)10.2<br>(short)32<br>注意这时候的安全性,小的变量不总能表达大的量<br>(short)32768<br>只是从那个变量计算出了一个新的类型的值,它并不改变那个变量,无论是值还是类型都不改变<br>强制类型转换的优先级高于四则运算</p>
<hr>
<h1 id="逻辑运算符优先级"><a href="#逻辑运算符优先级" class="headerlink" title="逻辑运算符优先级:"></a>逻辑运算符优先级:</h1><p>!&gt;&amp;&amp;&gt;||</p>
<hr>
<h1 id="短路"><a href="#短路" class="headerlink" title="短路"></a>短路</h1><p>逻辑运算是自左向右进行的,如果左边的结果已经能够决定结果了,就不会做右边的计算<br>a==6&amp;&amp;b==1<br>a==6&amp;&amp;b+=1<br>对于&amp;&amp;,左边是 false时就不做右边了<br>对于‖,左边是true时就不做右边了  </p>
<hr>
<h1 id="tip1"><a href="#tip1" class="headerlink" title="tip1"></a>tip1</h1><p>不要把赋值,包括复合赋值组合进表达式!<br>一个代码内有重复相似段是程序质量不良的表现<br>函数是一块代,接收零个或多个参数做一件事情,并返回零个或一个值</p>
<hr>
<h1 id="数组的大小"><a href="#数组的大小" class="headerlink" title="数组的大小"></a>数组的大小</h1><p>sizeof给出整个数组所占据的内容的大小,单位是字节<br>sizeof(a)/sizeof(a[0])<br>sizeof(a[0])给出数组中单个元素的大小,于是相除就得到了数组的单元个数<br>这样的代码,一旦修改数组中初始的数据,不需要修改遍历的代吗</p>
<hr>
<h1 id="数组的操作"><a href="#数组的操作" class="headerlink" title="数组的操作"></a>数组的操作</h1><p>遍历数组：通常都是使用for循环,让循环变量i从0到&lt;数组的长度,这样循环体内最大的正好是数组最大的有效下标<br>数组作为函数的参数时:不能在[]中给出数组的大小，不能再利用 sizeof来计算数组的元素个数!<br>数组作为函数参数时,往往必再用另一个参数来传入数组的大小</p>
<h1 id="作为参数的指针"><a href="#作为参数的指针" class="headerlink" title="作为参数的指针"></a>作为参数的指针</h1><p>void f(int * p)<br>在被调用的时候得到了某个变量的地址<br>int i=O; f(&amp;i)<br>在函数里面可以通过这个指针访问外面的这个<br>函数参数表中的数组实际上是指针<br>sizeof(a)==sizeof(int *)<br>但是可以用数组的运算符进行运算</p>
<hr>
<h1 id="指针是const"><a href="#指针是const" class="headerlink" title="指针是const"></a>指针是const</h1><p>表示一旦得到了某个变量的地址,不能再指向其他变量<br>int *const q=&i;//q是 const<br>*q=26;//OK<br>q++; //ERROR</p>
<hr>
<h1 id="所指是-const"><a href="#所指是-const" class="headerlink" title="所指是 const"></a>所指是 const</h1><p>表示不能通过这个指针去修改那个变量(并不能使得那个变量成为 const)<br>const int *p=&amp;i<br>*p= 26; //ERROR!<br>i=26;//OK<br>P=&i;//OK</p>
<hr>
<h1 id="const"><a href="#const" class="headerlink" title="const"></a>const</h1><p>lnt i<br>const int* p1 =&amp;i<br>int const* p2=&amp;i<br>int <em>const p3=&amp;i<br>判断哪个被const了的标志是const在</em>的前面还是后面<br>*const p指针不许动<br>const *p指针不许动变量</p>
<hr>
<h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><p>总是可以把一个非 const的值转換成 const的<br>void f(const int* x)<br>int a =15:<br>f(&amp;a);//ok<br>const int b = a<br>f(&amp;b);//ok<br>b =a+1: // Error<br>当要传递的参数的类型比地址大的时候,这是常用的手段:既能用比較少的字节数传递值给参数,又能避免函数对外面的变量的修改</p>
<hr>
<h2 id="const数组"><a href="#const数组" class="headerlink" title="const数组"></a>const数组</h2><p>const int a[]={1,2,3,4,5,6};<br>数组变量已经是 const的指针了,这里的 const表明数组的每个单元都是 const Int所以必须通过初始化进行赋值</p>
<hr>
<h2 id="保护数组值"><a href="#保护数组值" class="headerlink" title="保护数组值"></a>保护数组值</h2><p>因为把数组传入函数时传递的是地址,所以那个函数内部可以修改数组的值<br>为了保护数组不被函数破坏,可以设置参数为 const<br>int sum(const int a[], int length);</p>
<hr>
<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>int *p ：指针加一p+1是指加上一个sizeof(int)，将指针移到下一个单元<br>int *p=a[];<br>*p –&gt;a[0]<br>*(p+1)–&gt;a[1]<br>*(p++)可以遍历数组</p>
<hr>
<p>给一个指针加|表示要让指针指向下一个变量<br>int a[l0]<br>int *p= a<br>*(p+1)–&gt;a[1]<br>如果指针不是指向一片连分配的空间,如数组,则这种运算没有意义<br>*(p+n)&lt;–&gt;a[n]<br><em>p</em>q两个指针相减p-q，等于q加多少个单元等于p</p>
<hr>
<p>*p++<br>取出p所指的那个数据来,完事之后顺便把移到下一个位置去<br>*的优先级然高,但是没有++高<br>常用于数组类的连续空间操作<br>在某些CPU上,这可以直接被翻译成一条汇编指令</p>
<p>指针乘除无意义</p>
<hr>
<h2 id="指针遍历数组方法"><a href="#指针遍历数组方法" class="headerlink" title="指针遍历数组方法"></a>指针遍历数组方法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*p a[10]</span><br><span class="line">p=a</span><br><span class="line">for(i=0;i&lt;sizeof(a)/sizeof(a[0]); i++ )&#123;</span><br><span class="line">printf(&quot;%d\n&quot;, acri[i]);</span><br><span class="line">&#125;  </span><br><span class="line">a[9]=-1//在数组末尾放入一个特殊的东西</span><br><span class="line">while(*p!=-1)&#123;</span><br><span class="line">printf(&quot;%d\n&quot;,*p++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="指针比較"><a href="#指针比較" class="headerlink" title="指针比較"></a>指针比較</h2><p>&lt;,&lt;=,==,&gt;,&gt;=,!=都可以对指针做<br>比较它们在内存中的地址<br>数组中的单元的地址肯定是线性从小到大递增的</p>
<hr>
<h2 id="0地址"><a href="#0地址" class="headerlink" title="0地址"></a>0地址</h2><p>当然你的内存中有0地址,但是0地址通常是个不能随便碰的地址<br>所以你的指针不应该具有0值  </p>
<p>因此可以用0地址来表示特殊的事情:<br>1返回的指针是无效的<br>2指针没有被真正初始化(先初始化为0)  </p>
<p>NULL（必须是大写）是一个预定定义的符号,表示0地址<br>有的编译器不愿意你用0来表示0地址</p>
<hr>
<h2 id="指针的类型"><a href="#指针的类型" class="headerlink" title="指针的类型"></a>指针的类型</h2><p>无论指向什么类型,所有的指针的大小都是一样的,因为都是地址<br>但是指向不同类型的指针是不能直接互相赋值的<br>这是为了避免用错指针</p>
<h2 id="指针的类型转换"><a href="#指针的类型转换" class="headerlink" title="指针的类型转换"></a>指针的类型转换</h2><p>void<em>表示不知道指向什么东西的指针<br>计算时与char</em>相同(但不相通)</p>
<p>指针也可以转换类型<br>int<em>p =&amp;i<br>void</em>p&lt;–&gt;(void *)p<br>这并没有改变p所指的变量的类型,而是让后人用不同的眼光通过p看它所指的变量<br>我不再当你是int,我认为你就是个void!</p>
<hr>
<h2 id="用指针来做什么"><a href="#用指针来做什么" class="headerlink" title="用指针来做什么"></a>用指针来做什么</h2><p>需要传入較大的数据时用作参数<br>传入数组后对数组做操作<br>函数返回不止一个结果是<br>需要用函数来修改不止一个变量<br>动态申请的内存</p>
<hr>
<h1 id="内存操作"><a href="#内存操作" class="headerlink" title="内存操作"></a>内存操作</h1><h2 id="malloc-跟系统要一块内存"><a href="#malloc-跟系统要一块内存" class="headerlink" title="malloc(跟系统要一块内存)"></a>malloc(跟系统要一块内存)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdlib. h&gt;</span><br><span class="line">void*malloc(size_t size)</span><br><span class="line">//向malloc申请的空间的大小是以字节为单位返回的结果是void,需要类型转换为自己需要的类型</span><br><span class="line">(int *)malloc(n*sizeof(int))</span><br></pre></td></tr></table></figure>
<p>如果申请失敗则返回0,或者叫做NULL</p>
<hr>
<h2 id="free"><a href="#free" class="headerlink" title="free()"></a>free()</h2><p>把申请得来的空间还给“系统”<br>申请过的空间,最终都应该要还<br>只能还申请来的空间的首地址</p>
<h2 id="free常见问题"><a href="#free常见问题" class="headerlink" title="free常见问题"></a>free常见问题</h2><p>申请了没free—&gt;长时间运行内存逐漸下降<br>新手:忘了<br>老手:找不到合的free的时机<br>free过了再free<br>地址变过了,直接去free</p>
<hr>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>char a[]={‘h’,’a’,’l’,’l’,’o’,’!’}//字符数组<br>char a[]={‘h’,’a’,’l’,’l’,’o’,’!’,’\0’}//字符串</p>
<hr>
<p>以0(整数0)结尾的一串字符<br>0或’\0’是一样的,但是和0不同<br>0标志字符串的结束,但它不是字符串的一部分<br>计算字符串长度的时候不包含这个0<br>字符串以数组的形式存在,以数组或指针的形式访问<br>更多的是以指针的形式<br>string.h里有很多处理字符串的函数</p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char*str=&quot;Hello&quot;</span><br><span class="line">char word[]=&quot;Hello&quot;</span><br><span class="line">char linel[10]=&quot;Hello&quot;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h2><p>Char* s=”Hello, world”<br>●s是一个指针,初始化为指向一个字符串常量<br>●由于这个常量所在的地方,所以实际上s是 const<br>char*s,但是由于历史的原因,编译器接受不带const的写法<br>●但是试图对s所指的字符串做写入会导致严重的后果</p>
<hr>
<p>char S[]=”Hello, world”//这个字符串就在我这里<br>Char* s=”Hello, world”//指向某个地方的字符串<br>数组:这个字符串在这里(作为本地变量,空间自动被回收)<br>指针:这个字符串不知道在哪里(处理参数,动态分配空间)<br>如果要构造一个字符串一&gt;数组<br>如果要处理一个字符串一&gt;指针</p>
<hr>
<h2 id="字符串输入输出"><a href="#字符串输入输出" class="headerlink" title="字符串输入输出"></a>字符串输入输出</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char string[8];</span><br><span class="line">scanf(&quot;%s&quot;, string);</span><br><span class="line">printf(&quot;%s&quot;, string);</span><br><span class="line">//scanf读入一个単词(到空格、tab或回车为止)</span><br><span class="line">//scanf是不安全的,因为不知道要该入的内容的长度</span><br><span class="line">scanf(&quot;%7s&quot;, string)</span><br><span class="line">//在%和s之间的数字表示最多允许该入的字符的数量,这个数字应该比数组的大小小</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="空字符串"><a href="#空字符串" class="headerlink" title="空字符串"></a>空字符串</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char buffer[100]=&quot;&quot;;</span><br><span class="line">//这是一个空的字符串, buffer[O]==&quot;\0&quot;;</span><br><span class="line">char buffer[]=&quot;&quot;;</span><br><span class="line">//这个数组的长度只有1</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="复制一个字符串"><a href="#复制一个字符串" class="headerlink" title="复制一个字符串"></a>复制一个字符串</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char*dst=(char*)malloc(strlen(src)+1)</span><br><span class="line">strcpy(dst, src)</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="枚挙"><a href="#枚挙" class="headerlink" title="枚挙"></a>枚挙</h1><p>枚挙是一种用戶定义的数据类型,它用关键字enum以如下语法来声明<br>enum枚挙类型名字{名字0,……,名字n};  </p>
<p>枚挙类型名字通常并不真的使用,要用的是在大括号里的名字,因为它们就是就是常量符号,它们的类型是int,值则依次从0到n。如：<br>enum colors {red, yellow, green};<br>就创建了三个常量,red的值是0, yellow是1,而 green是2。<br>当需要一些可以排列起来的常量值时,定义枚举的意义就是给了这些常量值名字。</p>
<blockquote>
<p>声明枚挙量的时候可以指定值<br>enum COLOR {RED=1, YELLOW, GREEN =5};</p>
</blockquote>
<hr>
<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><h2 id="声明结构的形式"><a href="#声明结构的形式" class="headerlink" title="声明结构的形式"></a>声明结构的形式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct point&#123;</span><br><span class="line">int X;</span><br><span class="line">Int y;</span><br><span class="line">&#125;;</span><br><span class="line">struct point p1, p2</span><br><span class="line">//pl和p2都是 point里面有x和y的值</span><br><span class="line"></span><br><span class="line">struct &#123;</span><br><span class="line">Int x;</span><br><span class="line">int y;</span><br><span class="line">&#125;pl, p2;</span><br><span class="line">//pl和p2都是一种无名结构,里面有x和y</span><br><span class="line"></span><br><span class="line">struct point &#123;</span><br><span class="line">Int x;</span><br><span class="line">int y;</span><br><span class="line">&#125;pl, p2;</span><br><span class="line">//pI和p2都是point, 里面有x和y的值t</span><br></pre></td></tr></table></figure>
<blockquote>
<p>和本地变量一样,在函数内部声明的结构类型只能在函数内部使用<br>所以通常在函数外部声明结构类型,这样就可以被多个函数所使用了</p>
</blockquote>
<hr>
<h2 id="结构指针"><a href="#结构指针" class="headerlink" title="结构指针"></a>结构指针</h2><p>和数组不同,结构变量的名字并不是结构变量的地址,必须使用&amp;运算符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct date*pdate= &amp;today;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="结构作为函数参数"><a href="#结构作为函数参数" class="headerlink" title="结构作为函数参数"></a>结构作为函数参数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int numberofdays(struct date d)</span><br></pre></td></tr></table></figure>
<p>整个结构可以作为参数的值传入函数<br>这时候是在函数内新建一个结构变量,并复制调用者的结构的值<br>也可以返回一个结构<br>这与数组完全不同</p>
<hr>
<h2 id="指向结构的指针"><a href="#指向结构的指针" class="headerlink" title="指向结构的指针"></a>指向结构的指针</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct date &#123;</span><br><span class="line">int month;</span><br><span class="line">int day;</span><br><span class="line">int yeari;</span><br><span class="line">&#125;myday;</span><br><span class="line">struct date *p =&amp;myday;</span><br><span class="line">(*p).month 12;</span><br><span class="line">p-&gt;zmonth 12;</span><br><span class="line">//用-&gt;表示指针所指的结构变量中的成员</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="全局变量初始化"><a href="#全局变量初始化" class="headerlink" title="全局变量初始化"></a>全局变量初始化</h1><p>没有做初始化的全局变量会得到0值<br>指针会得到NULL值<br>只能用编译时刻已知的值来初始化全局变量<br>它们的初始化发生在main函数之前<br>全局变量不应该和另一个全局变量有联系<br>同名变量，本地变量优先级高于全局变量，即本地变量隐藏了全局变量</p>
<hr>
<h1 id="静态本地变量（全局生存期，本地作用域）"><a href="#静态本地变量（全局生存期，本地作用域）" class="headerlink" title="静态本地变量（全局生存期，本地作用域）"></a>静态本地变量（全局生存期，本地作用域）</h1><p>在本地变量定义时加上 static修饰符就成为静态本地变量<br>当函数离开的时候,静态本地变量会銖存在并保持其值<br>静态本地变量的初始化只会在第一次进入这个函数时做（只做一次初始化）,以后进入函数时会保持上次离开时的值<br>静态本地变量实际上是特殊的全局变量，它们位于相同的内存区域<br>静态本地变量具有全局的生存期,函数内的局部作用域<br>static在这里的意思是局部作用域(本地可访问)</p>
<blockquote>
<p>不要使用全局变量来在函数间传递参数和结果<br>尽量避免使用全局变量<br>丰田汽车的案子<br>使用全局变量和静态本地变量的函数是线程不安全的  </p>
</blockquote>
<hr>
<h1 id="返回指针的函数"><a href="#返回指针的函数" class="headerlink" title="返回指针的函数"></a>返回指针的函数</h1><p>返回本地变量的地址是危险的<br>返回全局变量或静态本地变量的地址是安全的<br>返回在函数内 malloc的内存是安全的,但是容易造成问题<br>最好的做法是返回传入的指针</p>
<hr>
<h1 id="编译预处理指令"><a href="#编译预处理指令" class="headerlink" title="编译预处理指令"></a>编译预处理指令</h1><p>#开头的是编译预处理指令<br>它们不是C语言的成分,但是C语言程序离不开它们</p>
<hr>
<h2 id="define-纯文本替换"><a href="#define-纯文本替换" class="headerlink" title="#define(纯文本替换)"></a>#define(纯文本替换)</h2><p>#define用来定义一个宏<br>#define&lt;名字&gt;&lt;值&gt;<br>注意没有结尾的分号,因为不是C的语句<br>名字必颁是一个单词,值可以是各种东西<br>在C语言的编译器开始编译之前,编译预处理程序<br>(cpp)会把程序中的名字换成值<br>完全的文本替换<br>acc-save-temps</p>
<hr>
<h2 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h2><p>如果一个宏的值中有其他的宏的名字,也是会被替换的<br>如果一个宏的值超过一行,最后一行之前的行末需要加  \<br>宏的值后面出现的注释不会被当作宏的值的一部分</p>
<hr>
<h3 id="预定义的宏"><a href="#预定义的宏" class="headerlink" title="预定义的宏"></a>预定义的宏</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_LINE_</span><br><span class="line">_FILE_</span><br><span class="line">_DATE_</span><br><span class="line">_TIME_</span><br><span class="line">_STDC_</span><br></pre></td></tr></table></figure>
<h3 id="带参数的宏"><a href="#带参数的宏" class="headerlink" title="带参数的宏"></a>带参数的宏</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define cube(x) ((x)*(x)*(x))</span><br></pre></td></tr></table></figure>
<p>在大型程序的代吗中使用非常普遍<br>可以非常复杂,如“产生”函数:在#和##这两个运算符的帮助下<br>存在中西方文化差异<br>部分宏会被inline函数替代</p>
<hr>
<h1 id="变量的声明"><a href="#变量的声明" class="headerlink" title="变量的声明"></a>变量的声明</h1><p>int i;是变量的定义<br>extern int i;是变量的声明</p>
<hr>
<h1 id="声明和定义"><a href="#声明和定义" class="headerlink" title="声明和定义"></a>声明和定义</h1><p>声明是不产生代码的东西<br>函数原型<br>变量声明<br>结构声明<br>宏声明<br>枚挙声明<br>类型声明<br>inline函数<br>定义是产生代码的东西<br>头文件放声明是规则</p>
<hr>
<h1 id="重复声明"><a href="#重复声明" class="headerlink" title="重复声明"></a>重复声明</h1><p>同一个编译单元里,同名的结构不能被重复声明<br>如果你的头文件里有结构的声明,很难这个头文件不会在一个编译单元里被#include多次，所以需要”标准头文件结构”</p>
<hr>
<h1 id="标准头文件结构-宏的if"><a href="#标准头文件结构-宏的if" class="headerlink" title="标准头文件结构(宏的if)"></a>标准头文件结构(宏的if)</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifndef _LIST_HEAD_</span><br><span class="line">#define _LIST_HEAD_</span><br><span class="line">#include &quot;node.h&quot;</span><br><span class="line">typedef struct _list&#123;</span><br><span class="line">    Node* head</span><br><span class="line">    Node* tail</span><br><span class="line">&#125;List</span><br><span class="line">#endif</span><br><span class="line">//运用条件编译和宏,保证这个头文件在一个编译单元中只会被#include一次</span><br><span class="line">#pragma once//也能起到相同的作用,但是不是所有的编译器都支持</span><br></pre></td></tr></table></figure>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><blockquote>
<p>0建一个node结构<br>1首选有个node结构(作为节点)，结构里有int(或者其他类型)变量去存数据，还有个同样结构的*next(next要等于下一个节点)（套娃）<br>2读入数据，并新建一个node结构p，要让一个node结构head始终等于链表第一个节点<br>3要有一个node结构last，每次要让last从head开始，直到last-&gt;next是空的，然后让next等于新的p结构（这样就链起来了）<br>4每次读入新的数据，就新建一个p，然后让last从head开始遍历链表，直到last-&gt;next是空的，然后然后让next等于新的p结构<br><strong>要在函数内改变指针的指向，就要传指针的指针进去</strong></p>
</blockquote>
<hr>
<h2 id="遍历链表"><a href="#遍历链表" class="headerlink" title="遍历链表"></a>遍历链表</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(p=list.head; p; p=p-&gt;next)&#123;&#125;</span><br><span class="line">//单用一个指针p可以遍历链表</span><br></pre></td></tr></table></figure>
<p>但要让删除链表中某一结点，需要另一个指针q，q一开始为null，后来始终指向p前一个节点<br>当p找到了要删除的节点，就让q-&gt;next等于p-&gt;next，然后free(p)<br>for(q=null，p=list.head; p; q=p，p=p-&gt;next){}<br>当然还要判断链表的第一个元素是不是我们要删除的<br>如果是，就不能让q-&gt;next等于p-&gt;next，因为q一开始是NULL<br>我们应该让head-&gt;next等于p-&gt;next，然后free(p)  </p>
<blockquote>
<p>“.”一般情况下读作”的”。<br>“-&gt;”一般读作”指向的结构体的”。  </p>
</blockquote>
<hr>
<h2 id="清除整个链表"><a href="#清除整个链表" class="headerlink" title="清除整个链表"></a>清除整个链表</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(p=head;p;p=q)&#123;</span><br><span class="line">     q=p-&gt;next;</span><br><span class="line">     free(p)</span><br><span class="line">&#125;</span><br><span class="line">//先让指针p等于head，让q始终指向p的下一个节点，然后free(p),再让p=q，p去等于下一个节点</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="main"><a href="#main" class="headerlink" title="main()"></a>main()</h1><p>main(成为C语言的入口函数其实和C语言本身无关,你的代码是被一小段叫做启动代的程序所调用的,它需要叫做main的地方)<br>操作系统把你的可执行程序装载到内存里,启动运行,然后调用你的main函数<br>在不同操作系统，入口函数可能不是main()</p>
<hr>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
</search>
