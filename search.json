[{"title":"归档、分类、标签页文章卡片加上所属分类和标签","url":"/article/a19bb7fb.html","content":"\n# 前言\n&emsp;&emsp;如图，上面修改前，下面修改后。\n<img src=/images/23-2.webp width=\"90%\" height=\"90%\">\n\n# 实现\n&emsp;&emsp;修改`\\themes\\butterfly\\layout\\includes\\mixins\\article-sort.pug`\n```\n.article-sort-item-info\n    .article-sort-item-time\n        time.post-meta-date-created(datetime=date_xml(article.date) title=_p('post.created') + ' ' + full_date(article.date))= date(article.date, config.date_format)\n        a.article-sort-item-title(href=url_for(article.path) title=title)= title\n+    .article-meta-wrap\n+        if (theme.post_meta.page.categories && article.categories.data.length > 0)\n+            span.article-sort-item-categories\n+                i.iconfont.icon-fenlei//- 记得改成自己的图标\n+                each item, index in article.categories.data\n+                    a(href=url_for(item.path)).article-meta__categories #[=item.name]\n+                    if (index < article.categories.data.length - 1)\n+                       i.fas.fa-angle-right\n+        if (theme.post_meta.page.tags && article.tags.data.length > 0)\n+            span.article-sort-item-tags\n+                i.iconfont.icon-biaoqian//- 记得改成自己的图标\n+                each item, index in article.tags.data\n+                    a(href=url_for(item.path)).article-meta__tags #[=item.name]\n+                    if (index < article.tags.data.length - 1)\n+                        span.article-meta__link #[='•']\n+        .article-sort-item-time\n+            time.post-meta-date-created(datetime=date_xml(article.date) title=_p('post.created') + ' ' + full_date(article.date))= date(article.date, config.date_format)\n\n```\n\n&emsp;&emsp;增加css：根据自己的实际样式情况进行微调，没有通用css。\n","tags":["Butterfly","Hexo"],"categories":["Hexo"]},{"title":"控制指定单页的背景样式","url":"/article/eb3a4679.html","content":"\n# 前言\n&emsp;&emsp;看[@heo](https://blog.zhheo.com/)的博客单页，无论是哔哔，友链，还是关于页，page的背景都是透明的，一开始我以为是在单页的index.md里单独引入css，后来才知道，是直接`#page{background:transparent;}`,这只会让所有非文章、归档、分类、标签的单页背景透明。\n\n&emsp;&emsp;这好啊，果断抄走，然后不出意外，有些单页变得很难看，因为没关侧边栏（侧边栏没透明，page透明了），或因为背景透明后字看不清（友链页），反正，我需要能单独控制单页page的背景样式，说干就干，让不同单页加上不同class，css控制这些class即可。\n<img src=/images/22-1.webp width=\"40%\" height=\"40%\">\n\n***\n\n# 实现\n## 方案一\n&emsp;**让指定单页背景样式相同(如透明)**\n&emsp;&emsp;修改`\\themes\\butterfly\\layout\\page.pug`\n```pug 需要控制哪些单页的背景就加上is_current('<单页路径>')\nblock content\n+  - let transparent = (is_current('/bb/') || is_current('/charts/')) ? true : false\n-  #page\n+  #page(class= (transparent === true) ? 'transparentpage' : '')\n\n```\n\n&emsp;&emsp;然后写css：（别漏了!important）\n```pug 这里是让指定单页的背景都透明\n.transparentpage{\n    background:transparent!important;\n}\n\n```\n\n## 方案二\n&emsp;**控制不同单页有不同背景样式**\n&emsp;&emsp;修改`\\themes\\butterfly\\layout\\page.pug`\n```pug 需要控制更多单页就仿照格式写\nblock content\n+  - let bb = is_current('/bb/') ? true : false\n+  - let charts = is_current('/charts/') ? true : false\n-  #page\n+  #page(class= (bb === true) ? 'bb-transparent' : '')(class= (charts === true) ? 'charts-transparent' : '')\n\n```\n\n&emsp;&emsp;然后写css：（别漏了!important）\n```pug\n.bb-transparent{\n    background:transparent!important;\n}\n.charts-transparent{\n    background:blue!important;\n}\n\n```\n\n&emsp;&emsp;此方法存在一个问题：\n&emsp;&emsp;hexo g和hexo s时，会提示:You should not have pug tags with multiple attributes.（您不应该使用具有多个属性的pug标记）\n&emsp;&emsp;这是因为我尝试多次class=()，但实际上，因为路径是唯一的，这不会导致出问题，对hexo渲染没有影响。\n***","tags":["Butterfly","Hexo"],"categories":["Hexo"]},{"title":"Butterfly给首页首个文章卡片加个class","url":"/article/dbde845d.html","content":"\n# 前言\n&emsp;&emsp;看[@heo](https://blog.zhheo.com/)的博客首页，他的第一个文章卡片是其余卡片宽度的两倍，F12可知是首页的首个文章卡片多了一个class，虽然我的文章卡片暂时没这需求，但刚好有人问怎么才能控制首页第一个文章卡片的样式，也刚好我有思路，就实现一下吧\n&emsp;&emsp;关键就是怎么给首个文章卡片加一个class，我想到了和之前[给文章卡片加上最新文章标志](https://www.chuckle.top/article/2ed7d622.html)差不多的操作\n<img src=/images/21-2.webp width=\"100%\" height=\"100%\">\n***\n\n# 实现\n&emsp;&emsp;先看原来post-ui的结构:``\\blog\\themes\\butterfly\\layout\\includes\\mixins\\post-ui.pug``\n```pug\nmixin postUI(posts)\n  each article , index in page.posts.data\n    .recent-post-item//要在这里加个calss\n    //后面就是文章卡片的具体的内容\n\n```\n\n&emsp;&emsp;可以改成这样，就能将首页第一个文章卡片和其余卡片分开渲染成html，自然，加个class就轻而易举了\n```pug\nmixin postUI(posts)\n  each article , index in page.posts.data\n    if (firstpost !== 1 && is_current('/'))\n      - var firstpost = 1\n      .recent-post-item.firstpost-item\n      //首页首个文章卡片的具体的内容（cv原来的就行）\n    else\n      .recent-post-item\n      //其余文章卡片的具体的内容（cv原来的就行）\n\n```\n\n&emsp;&emsp;这样，首页第一个文章卡片就会多一个``firstpost-item``class，控制这个class就能控制样式了\n<img src=/images/21-1.webp width=\"40%\" height=\"40%\">\n\n&emsp;&emsp;而且这样改完pug，首页第一个文章卡片有更多的操作空间，可以完全和其余卡片长得不一样，修改具体内容里的源码即可\n***\n\n# 优化\n&emsp;&emsp;[@heo](https://blog.zhheo.com/)的代码结构优化版本（适合无需对首页第一个卡片进行定制化）\n```pug\nmixin postUI(posts)\n  each article , index in page.posts.data\n    - let lastPost = firstpost !== 1 && is_current('/') ? true : false\n    - var firstpost = 1\n    .recent-post-item(class= (lastPost === true) ? 'firstpost-item' : '')\n    \n```\n\n***","tags":["Butterfly","Hexo"],"categories":["Hexo"]},{"title":"Butterfly文章卡片加上最新文章标志","url":"/article/2ed7d622.html","content":"\n# 前言\n&emsp;&emsp;昨天[@Leonus](https://blog.leonus.cn/)大佬用js给首页最新的文章卡片加上了``最新``标志:[几行代码实现最新文章标志 | Leonus](https://blog.leonus.cn/2022/newpost.html)\n&emsp;&emsp;不过每次切换到首页都要执行这个js，不然最新标志就不显示，开启了pjax之后,怎么让这js每次切换到首页都执行是个问题，而且每次都执行也会多吃一些性能\n\n&emsp;&emsp;因为butterfly是按创建时间顺序排序的，最上面的卡片就是最新文章，直接修改文章卡片源码，给第一个卡片加上``最新``标志就行了（当然还要排除手动置顶的文章）\n&emsp;&emsp;这样pug渲染成html时，``最新``标志就写死在那了\n<img src=/images/20-1.webp width=\"30%\" height=\"30%\">\n***\n\n# 实现\n>我这实现看起来挺笨，有大佬有更好的实现方式不\n\n1. 修改``\\blog\\themes\\butterfly\\layout\\includes\\mixins\\post-ui.pug``&emsp;加上三行：\n```pug\n.recent-post-info\n+    if (numberone !== 1 && is_current('/') && (!article.top || (article.new && article.top)))\n+        span.newPost 最新\n+        - var numberone = 1\n```\n\n2. 在你的自定义css文件中，添加如下代码：\n```css\n/* 最新文章图标 */\n.newPost {\n    position: absolute;\n    top: 0;\n    color: rgba(255, 255, 255, 0.92);\n    padding: 0 15px;\n    background-color: #49b0f5b9;\n    border-radius: 0 0 10px 10px;\n    right: 40px;\n}\n@media screen and (max-width:600px){\n  .newPost {\n    right: 0px;\n    padding: 0 12px;\n    border-radius: 0 10px 0px 10px;\n}\n}\n```\n\n***\n\n# 使用\n&emsp;&emsp;当首页没有置顶时，会给第一个卡片加上最新标志\n&emsp;&emsp;当首页有置顶时，会给非置顶的第一个卡片加上最新标志\n\n&emsp;&emsp;显然，这里有bug，如果置顶里的文章就是最新的咋办？\n&emsp;&emsp;只需要在文章头部加上``new: true``就行了\n\n&emsp;&emsp;稍微有点麻烦，所以，建议最新的文章就没必要置顶了，反正不置顶也在第一个\n```\n---\ntitle: aaaaaaaaaa\ntop: 1\n+ new: true\n---\n```\n\n***\n\n","tags":["Butterfly","Hexo"],"categories":["Hexo"]},{"title":"小米妙享--MIUI的生态互联","url":"/article/eb38f645.html","content":"\n# 引言\n&emsp;&emsp;不少人去年就听说了这个功能，作为小米产品生态构建的重要一环（全局设备互联互通），这个功能我却迟迟没去更新使用，因为它与miui+的割裂导致使用起来比较繁琐，也因为它把平板排除于外，当然最主要是我实在没有这么多设备需要去``流转``。\n&emsp;&emsp;但在最近的更新中，``小米妙享``不仅将miui+给整合进了`妙享中心`，还带上了小米平板5系列，为平板与电脑的互联互通增加了几个重要的功能。\n\n# 如何安装\n&emsp;&emsp;我喜欢小米的一点，就是它将系统功能都作为一个个软件的形式打包，不同批次的软件之间兼容性也不错，除非跨安卓版本才能实现的功能（例如米版的全局手写，这个基于安卓12，自然安卓11用不了），都可以通过安装或更新软件来使用新功能，正好，小米妙享就是这样一个安装即用的系统功能。  \n\n## 平板/手机端\n&emsp;&emsp;我的平板还在13.0.6这个稳定版养老，下载安装最新的`miui+`、`投屏`、`小米互联通信`,手机端就搞定了(没有资格就刷个`Miui解锁小米妙享模块`)。\n\n## 电脑端\n&emsp;&emsp;目前电脑端软件有限制，只有小米电脑上才能使用，但这难不倒酷友们，跟着此帖即可在电脑端安装好妙享中心：[最新miui+（小米妙享）PC版安装及配置教程](https://www.coolapk.com/feed/38357299?shareKey=MzdiMWMzNjNmMTgwNjJmYTcyYmI~&shareUid=4137393&shareFrom=com.coolapk.market_12.0.2)。\n\n# 使用体验\n\n## 互联\n&emsp;&emsp;电脑打开蓝牙，平板打开蓝牙、wifi、小米互传，让设备处于同一网络下，电脑端点击连接，等待`1-2秒`，很快即可连接上。且蓝牙wifi我一般保持常开，平板使用时也是手机或电脑给平板开热点，基本能做到需要就点击连接。\n<img src=/images/19-1.webp width=\"60%\" height=\"60%\"><img src=/images/19-3.webp width=\"60%\" height=\"60%\">\n\n## 平板作为电脑副屏\n&emsp;&emsp;这个功能是这次妙享更新后给米版上的新功能，在连接成功后可以看到两种副屏方式，作为镜像屏，或者扩展屏。选择任意一种副屏方式，同样等待2秒，就可完成副屏的启动。\n&emsp;&emsp;作为一个`无线可触摸`的副屏，使用起来非常舒适。\n<img src=/images/19-2.webp width=\"60%\" height=\"60%\">&emsp;&emsp;侧边栏有一些快捷键：“返回桌面”“多任务”“保存”“返回/撤销上一步操作”“保存截图”“屏幕键盘”“退出”。\n\n### 作为镜像屏\n&emsp;&emsp;利用秒表测试有0.04s延迟（屏幕一半播视频，一半秒表计时，拍照算时差，确保符合正常使用的延迟），实际体验下延迟确实可忽略不计，分辨率1920*1080（等同电脑屏幕分辨率），但帧率在40到60之间波动，习惯了120帧确实有点不舒服，不过也远胜我之前用的spacedesk。\n<img src=/images/19-4.webp width=\"60%\" height=\"60%\">&emsp;&emsp;小米妙享实际上是一个软件，那当然可以上滑挂在后台，或者挂个小窗在前台。  \n\n<img src=/images/19-5.webp width=\"60%\" height=\"60%\">&emsp;&emsp;在电脑端还可以设置侧边栏的位置、使用米板作为电脑的音频输出等。\n\n<img src=/images/19-6.webp width=\"60%\" height=\"60%\">\n\n### 作为扩展屏\n&emsp;&emsp;作为扩展屏时与镜像屏时差不多，同样有低延迟、高分辨率（作为扩展屏时分辨率1920*1200），同样可以挂后台挂小窗，设置侧边栏的位置、使用米板作为电脑的音频输出等。\n&emsp;&emsp;但此时帧率在30到50之间波动，可以感觉到鼠标拖动的略微不顺畅的卡顿，且窗口在平板与电脑直接拖动时，大小变化还有待优化，经常拖到平板还得再手动调小窗口大小。\n<img src=/images/19-7.webp width=\"60%\" height=\"60%\">\n&emsp;&emsp;无论是作为镜像还是扩展屏，吃电脑资源都不多。\n<img src=/images/19-10.webp width=\"70%\" height=\"70%\">\n\n## 平板投屏到电脑\n&emsp;&emsp;应用流转仅限于小米的设备，自然投屏也需要小米笔记本才行，不过酷友[@迷璐](https://www.coolapk.com/u/1189245)的模块可以让其它品牌的电脑也出现在妙享界面，只需要将平板画面拖到电脑的气泡上，1-2秒后，电脑上就有平板的投屏窗口了，投屏后平板可关闭屏幕。\n<img src=/images/19-11.webp width=\"60%\" height=\"60%\">&emsp;&emsp;投屏窗口可最大化可最小化，利用秒表测试有0.07s延迟（主界面播视频，小窗秒表计时，拍照算时差，确保符合正常使用的延迟），分辨率至少有1080p以上，帧数稳稳50-60帧。\n\n<img src=/images/19-12.webp width=\"60%\" height=\"60%\">&emsp;&emsp;值得注意的点是，这不是简单的投屏，投屏后，不仅平板的画面会在电脑上出现个窗口，平板上的所有音频也会用电脑的喇叭输出，而且可以直接使用电脑的键盘、鼠标去控制、操作平板。\n\n## 互通\n&emsp;&emsp;平板端截图，电脑会弹出有图和保存按键的小悬浮窗。\n<img src=/images/19-8.webp width=\"40%\" height=\"40%\">&emsp;&emsp;平板端或电脑端复制文字内容，另一个设备会同步这个内容到剪切板，并弹窗提示，且电脑端的弹窗会显示复制的文字内容。当任意一设备复制的是网址时，悬浮窗还会有直接打开网站的按键。\n\n<img src=/images/19-9.webp width=\"60%\" height=\"60%\">\n\n### 电脑与平板互传文件\n&emsp;&emsp;平板长按文件点分享，选择电脑即可；电脑端使用用小米互传向平板传文件，两种操作都非常方便且快速。\n<img src=/images/19-13.webp width=\"70%\" height=\"70%\">\n\n# 使用感受\n&emsp;&emsp;在简单上手平板与电脑之间的妙享后，可以确定，我以后将经常用到它的功能，实际上我还体验了平板-手机-电脑的三方互联互通，不过任意两个设备互联后，另一个设备就会断开连接（虽然重连很快，但还是很影响体验），所以三方互联的体验并不好，但平板-手机、手机-电脑之间的妙享体验也不错。\n&emsp;&emsp;可以看得出来MIUI还是有认真去做互联互通生态的，未来可期。\n\n# 不足之处\n1. 多设备同时互联体验差。\n2. 作为扩展屏与电脑之间拖动软件窗口，窗口大小自适应效果不好。\n3. 虽然博主安装起来较轻松，但不少酷友倒在了电脑硬件或其它配置上。\n4. 依赖核显（考虑考虑没核显或核显弱的笔记本？）。\n5. 平板投屏到电脑不能像手机与电脑的互联那样，直接拖文件传输。\n6. 手机应用流转到平板居然开倒车！直接全屏，而不是像之前那样在平板上弹出小窗。","tags":["小米妙享","MIUI"],"categories":["其它"]},{"title":"JavaWeb笔记--寄途的初始","url":"/article/7c1f73d5.html","content":"\n咕咕咕（\n","tags":["JAVA","JavaWeb"],"categories":["学习笔记"]},{"title":"JavaSE查缺补漏笔记","url":"/article/3c6a38d9.html","content":"\n>跟着翁恺或者学校的进度学完的JavaSE，如泛型、I/O、线程、映射、反射等等大部分没有提到或只是简略介绍，想要从JavaSE衔接上JavaEE，这些知识不可跳过。\n","tags":["JAVA","JavaSE"],"categories":["学习笔记"]},{"title":"新生生存指南","url":"/article/f6a0ce6c.html","content":"\n<script>\n    document.onselectstart = function(){\n        return false;\n    }\n</script>\n\n>一份生存指南，经验之谈，仅代表博主的个人观点。\n\n# 入学QA\n{% folding cyan close,入学QA（默认折叠，点击展开）  %}\n>持续更新中，关于校区介绍看：[广海阳江校区介绍](https://www.chuckle.top/article/8154a640.html)\n\n**问题1：**通知书啥时候到，里面有什么？\n&emsp;&emsp;计划8月1号开始邮寄通知书，邮政快递，拿通知书需要带身份证。里面有录取通知书，一张建设银行卡（拿到后要去当地建行激活），缴费须知，以及其它一些通知文件。邮寄地址是自己在高考信息系统里留的地址。\n\n**问题2：**入学需要准备什么？\n&emsp;&emsp;这部分在录取通知书里会说，这里也先简单说下：录取通知书、``高中的档案``、身份证复印件、1寸红底照片、登记兵役信息（有些高中学校已经帮你们登记好了）、生活用品（包括但不限于衣服、被子、床垫）等。但不用带洗衣机、桶装水、饮水机等物品！！！这些物品可``提前邮寄``（邮寄地址见问题3）到学校，或者到校后再和舍友一起合资在网上买。空调每个宿舍学校都已经装好，不用买。\n\n**问题3：**学校邮寄地址？什么时候可以邮寄？\n&emsp;&emsp;广东省阳江市江城区罗琴路1号广东海洋大学阳江校区菜鸟驿站。大二8月25号开学，就可以邮寄了，不过最好还是在开学前几天再寄。除了韵达和京东其它都可以进菜鸟驿站。\n\n**问题4：**怎么知道住哪个宿舍以及床位安排？\n&emsp;&emsp;我们那时是报道当天在宿舍楼下看宿舍安排，每个宿舍第一个到的同学要在宿管那拿空调遥控器和宿舍钥匙，今年不知道会不会先告诉你们。床位是先到先得。\n\n**问题5：**床有多大？买多大床垫？\n<div><img src=/images/16-2.webp width=\"30%\" height=\"30%\"></div>\n\n**问题6：**什么时候知道分班？\n&emsp;&emsp;去年是8月25号左右。\n\n**问题7：**军训时间？\n&emsp;&emsp;去年是9月15号开学，17号开始军训，30号结束，为期14天。\n\n**问题7：**可以装床帘么？\n&emsp;&emsp;床帘、桌帘都可以整，实际上宿舍你想咋搞都行（除了搞破坏）。\n\n{% endfolding %}\n\n***\n# 学校地图防止迷路\n{% folding cyan close,学校地图（默认折叠，点击展开）  %}\n<div><img src=/images/16-3.webp width=\"100%\" height=\"100%\"></div>\n\n{% endfolding %}\n\n***\n\n# 开学前一天\n\n## 提前一天到阳江\n&emsp;&emsp;不少新生是选择前一天到阳江市，好在第二天一大早就到学校，落脚点一般是离学校最近的市区：``江城区``，这也是阳江市的老城区了，酒店还是不少的。但不要像博主那样，从海陵岛回来都晚上10点了，才开始找酒店，那在市中心附近比较难找有空房的。（阳江高铁站同样在江城区）  \n&emsp;&emsp;当你七八点一大早就醒来准备去学校，那大可能遇到堵车，特别是在``金山路——鱿鱼大桥``那段，摩托大军与车流，所以提前规划好路线，避开早高峰，或者绕路以通过``漠阳江``。  \n<div><img src=/images/16-1.webp width=\"90%\" height=\"90%\"></div>\n\n## 有什么玩的\n&emsp;&emsp;博主是去了海陵岛玩，但可能并不是旅游旺季，而且已是晚上，景区内不少地方没开放，或者没人值守。散步逛街、驾车兜风、买了些鱿鱼丝、紫菜等产品就回去了。顺便吐槽下，去海陵岛两条路线，其中一条走高速，短短一条高速路，过路费倒是挺高。\n\n***\n\n# 开学首日\n\n## 当天到阳江\n&emsp;&emsp;除了提前一天到阳江，还有同学是选择开学当天到。\n&emsp;&emsp;学校有安排在高铁站直达学校的大巴，每隔一段时间一班次（具体时间看通知），自驾的话那不用说，避开早晚高峰，直接到校就行，即停即走。\n\n## 进校到入住流程\n>去年流程，今年看最后通知，不过应该差不多\n\n&emsp;&emsp;1. 到校门口有志愿者接过你的行李运到校车上，你则进到入校通道，配合完成一些工作后就可进到学校内，然后上校车。\n&emsp;&emsp;2. 校车会直接开到宿舍楼下，在宿舍楼下找到对应学院/专业的老师，进行入学登记，领校园卡等东西。\n&emsp;&emsp;3. 接着拿着自己的行李就可以上宿舍了，第一个到宿舍的要在宿管那拿空调遥控器和宿舍钥匙。\n&emsp;&emsp;4. 首日整个白天都是自由的，可以整理宿舍，到处逛逛，晚上有没有任务要看老师的安排（一般也没有）。\n\n***\n\n# 第二天\n&emsp;&emsp;1. 选好宿舍长；\n&emsp;&emsp;2. 轮流召开各个学院的开学典礼；\n&emsp;&emsp;3. 在体育馆购买两套军训服；\n&emsp;&emsp;4. 更多活动等安排。\n\n***\n\n# 第三天军训\n>为期14天的大学军训\n\n## 军训时间表\n&emsp;&emsp;6:30-7:20 早餐\n&emsp;&emsp;7:20-11:00 上午操课\n&emsp;&emsp;11:00-12:00 午餐\n&emsp;&emsp;12:00-14:30  午休\n&emsp;&emsp;15:00-17:00 下午操课\n&emsp;&emsp;17:00-19:00 晚餐\n&emsp;&emsp;19:00-23:00 除校区安排集中教育外，由各连及各学院商定开展军旅文艺活动、入学教育、学院活动等。\n&emsp;&emsp;23:00晚休\n\n## 军训生存指南\n&emsp;&emsp;0. 准备好``防汗``的防晒霜\n&emsp;&emsp;1. 千万别``迟到``和``逃训``\n&emsp;&emsp;2. 军训以一个连/排为集体，一人捣乱，``全员``受罪\n&emsp;&emsp;3. 动作不到位就是重复的训练\n&emsp;&emsp;4. 训练中有身体不适可以打报告休息一会，也可以申请后去“病号连”，“病号连”也要穿军训服，然后在操场看台待着不能回宿舍，该连虽然不用训练，但是要``写作文``（听说字数还挺多。。。）\n&emsp;&emsp;5. 军训的鞋子``比较小``，而且``硬底``，一般的鞋垫塞进去后很挤脚，可以垫纸巾啥的，不过博主14天都没垫东西\n&emsp;&emsp;6. 第一天就和舍友在JD上买好洗衣机，不然你不会想手洗军训服\n&emsp;&emsp;7. 军训服包括外套、裤子、衬衫、外腰带、帽子，只能说能穿，14天对于这种用料的军训服还是太勉强了，建议带盒``针线``，防止暴毙\n&emsp;&emsp;8. 准备好一个腰带，或者在裤子上多开一个纽扣孔，发的``外腰带是系腰（外套）上的！！！！！！``\n&emsp;&emsp;9. 多带点透气的袜子！！！\n&emsp;&emsp;10. 一个容量大的水瓶，不过我更建议直接在超市买1L的矿泉水\n&emsp;&emsp;11. 准备好防中暑的药品:风油精、藿香正气水等\n&emsp;&emsp;12. 买军训服``早点去``，抢码数，不然只剩小码了，虽然后面几天可以换，不过麻烦\n&emsp;&emsp;13. 在宿舍准备好泡面、面包等应急食品~~&ensp;派蒙&ensp;~~！！！\n&emsp;&emsp;14. 军训会分批去干饭，当然有些教官也会偷偷着带你们离饭堂近点训练，然后抢饭，不过分批得看教官队长分，会轮着来，中午晚去晚上就早去\n&emsp;&emsp;15. 教官前几天挺严，熟悉之后就会带着你们摸鱼了，只要配合好教官训练，训练好了就能去阴凉处坐着休息\n&emsp;&emsp;16. 军训不配合教官是会要求明年重训的（不过一般不会的啦），当然，表现好也会发优秀学员证书，能加操行分\n&emsp;&emsp;17. 晚训很摸鱼，经常去教室开会或者在操场上坐着拿手机看直播，当然也要穿军训服\n\n\n## 军训摸鱼指南\n&emsp;&emsp;1. 额，还想着摸鱼呢，14天坚持坚持就过去了，其实也挺快乐的~~~\n\n***","tags":["其它"],"categories":["其它"]},{"title":"“扬帆起航”LOGO设计活动--初柒网络科技","url":"/article/560689dd.html","content":"\n>&emsp;&emsp;为了庆祝武汉初柒网络科技有限公司开业，推出本期“扬帆起航”LOGO设计活动，帮助各位博主免费设计LOGO，提高知名度。logo即标志，它是活动的标志和象征，它体现着活动中的精神与文化。\n\n# 初柒科技简介\n{% span center logo large, 初柒科技 %}\n{% span center small, 技术·创新·前端·网络·建站·开发·设计 %}\n&emsp;\n&emsp;&emsp;武汉初柒网络科技有限公司成立于2022年7月11日，是一家集互联网开发、网络运营 、网站建设、平面设计、小程序及APP开发服务公司互联网服务于一体的网络科技公司。其主要专注于技术创新、寄情于网络IT、投身于互联网事业。\n\n&emsp;&emsp;拥有全新的服务理念，服务社会。武汉初柒网络科技有限公司是一家快速成长、锐意进取的年轻网络科技公司。公司以人为本，以客户为中心，以需求为导向，以服务为宗旨；以创新、专业、求实、诚信、和谐为经营理念。创新科技，最专业的技术。现以成为整个行业技术较专业的网络公司。迅速发展成为网络科技领域的后起之秀。\n\n{% link 戳我了解更多--初柒科技, https://mp.weixin.qq.com/s/0s6HnxTSPxuPh6ywJtxifg,%}\n&emsp;\n<div><img src=/images/15-1.webp width=\"80%\" height=\"80%\"></div>\n\n***\n\n# “扬帆起航”LOGO设计活动\n<div><img src=/images/15-2.webp width=\"90%\" height=\"90%\"></div>\n\n{% link “扬帆起航”LOGO设计活动--初柒科技, https://sady0.com/759/,%}\n&emsp;\n>&emsp;&emsp;为了庆祝武汉初柒网络科技有限公司开业，推出本期“扬帆起航”LOGO设计活动，帮助各位博主免费设计LOGO，提高知名度。logo即标志，它是活动的标志和象征，它体现着活动中的精神与文化。\n\n&emsp;**活动主题：**“扬帆起航”LOGO设计活动  \n\n&emsp;**活动时间：**2022年7月16日-2022年7月19日  \n\n&emsp;**参与人员：**所有博主  \n\n&emsp;**活动目的：**为广大博主设计专属LOGO，提高知名度、活跃度，其次提高公司知名度  \n\n&emsp;**参与要求：**  \n&emsp;&emsp;1. 博主个人博客文章大于10篇  \n&emsp;&emsp;2. 发布一篇不少于200字的公司宣传文章 ”公司主营业务：平面设计、开发等“（也可以宣传此次活动，但文章内必须带上公司名称，时间不能少于30天）,文章可以参照微信公众号文章来写（必须写出公司的营业范围“设计” “开发”）  \n\n&emsp;**参与方式：**  \n&emsp;&emsp;1. 收集表：https://www.wjx.cn/vm/tcX59cL.aspx  \n&emsp;&emsp;2. QQ群：425673538  \n\n&emsp;**活动奖励：**  \n&emsp;&emsp;1. 博主专属LOGO（一个）  \n&emsp;&emsp;2. 公司将随机抽取参与博主送出公司周边小礼品  \n&emsp;&emsp;3. 给博主免费通过10G图床空间  \n\n&emsp;**设计案例:**\n<div><img src=/images/15-4.webp width=\"100%\" height=\"100%\"></div>\n\n***\n\n","tags":["其它"],"categories":["其它"]},{"title":"广海阳江校区介绍","url":"/article/8154a640.html","content":"\n<script>\n    document.onselectstart = function(){\n        return false;\n    }\n</script>\n\n>前排提示：本文仅代表博主的个人观点。选专业和学校是人生大事，务必结合自身兴趣等分析，并考虑未来发展\n\n# 简介\n{% tabs test4 %}\n<!-- tab 阳江校区简介 -->\n{% link 广东海洋大学阳江校区官网, https://www.gdou.edu.cn/yjxq/, https://www.gdou.edu.cn/yjxq/images/logo.png %}{% link 广东海洋大学阳江校区简介,https://www.gdou.edu.cn/yjxq/xqgk/xqjj.htm , https://www.gdou.edu.cn/yjxq/images/logo.png %}\n\n&emsp;&emsp;广东海洋大学阳江校区作为`广东海洋大学的组成部分`，将秉承“坚韧不拔 自强不息”的`海大精神`，坚持“内涵发展、特色发展、创新发展”战略，`在“本、硕、博”完整学位授权体系办学的基础上`，作为学校`改革示范区`积极推进综合改革，建设区域特色鲜明的`高水平校区`。\n{% timeline 校区历程：,blue %}\n<!-- timeline 2019年初 -->\n&emsp;&emsp;`广东省委省政府`作出在阳江加快建设`应用型本科院校`的重大决策。同年7月，粤东西北地区新建迁建高校对口帮扶工作推进会召开，`华南理工大学`与`阳江市`签订对口帮扶建设阳江应用型本科院校框架协议，派出强有力的帮扶团队进驻阳江，大学建设工作全面展开。\n<!-- endtimeline -->\n<!-- timeline 2021年1月4日 -->\n&emsp;&emsp;广东省教育厅明确，由`省教育厅`、`阳江市`、`海大`、`华工`四方`共同建设`广东海洋大学`阳江校区`。3月30日，在省长马兴瑞等领导见证下，四方在湛江签署了`四方协议`。`广东海洋大学阳江校区正式成立`。\n<!-- endtimeline -->\n{% endtimeline %} \n\n**四通八达，山水校园**\n&emsp;&emsp;广东海洋大学阳江校区坐落于“幸福宜居之城”之称的现代化滨海城市——阳江市，海岛沙滩，如诗如画，高山峻岭，秀丽壮美，大山拥大江，大江融大海。阳江是粤港澳大湾区和北部湾城市群的交汇中心，纳入“9+6”大珠三角经济区，东邻粤港澳大湾区，西融北部湾城市群，承东连西、左右逢源的区位优势明显。在交通网络上，“两纵三横”的高速公路网逐步完善，正在扩建民用机场，构建了东连珠三角、西接大西南、海陆空相通的立体交通综合网络。\n&emsp;&emsp;广东海洋大学阳江校区位于阳江`主城区近郊`，西靠阳江八景之一的罗琴山，南临风景优美的石河水库，沈海高速、云阳高速、江湛铁路、广湛客专等交通路网纵横交错于校区旁，区域优势明显，交通条件优越，处于阳江融入粤港澳大湾区一小时交通圈、生活圈、经济圈的重要交通枢纽位置。阳江校区总规划用地面积`3500亩`，首期建设项目用地`512亩`，2021年6月建成。校区建设规划注重立意，以规划、景观、建筑三位为一体，依托校园自然以及人文环境，打造山水校园、书香校园。\n\n**四方共建，华工加持**\n&emsp;&emsp;广东海洋大学阳江校区由`广东省教育厅`、`阳江市政府`、`广东海洋大学`、`华南理工大学`四方联手共建，院校建设`顶层设计由华南理工大学帮扶指导`，学科建设由`华南理工大学论证规划`，`人才培养模式`由`华工资深教授把舵定向`，阳江校区教师队伍由`广东海洋大学教学名师`、帮扶高校`华南理工大学特聘教授`和`校区优秀教师`构成，`各学院首任负责人`由`华南理工大学`优秀`教授`担任----这是一所饱含着华工基因特色而成长起来的`高水平`、`高标准`院校。\n\n**同步硕博，高位启航**\n&emsp;&emsp;阳江新校区2021年已同步启动`本科`、`硕士`和`博士`三个学位层次的招生，以契合区域经济社会发展需求的学科专业为主，首年开设7个本科专业，有3个专业（机械设计制造及其自动化、计算机科学与技术、食品科学与工程）入选国家级`一流本科专业建设点`，占比超40%，办学`起点高`，`层次高`。\n\n**融通产业，锻造工匠**\n&emsp;&emsp;阳江校区依托阳江市千亿五金刀剪产业目标、世界级风电产业基地、调味品食品工业、基础零部件产业等重点产业群，创新打造产业学院，深化产学研深度融合人才培养模式，共建白天鹅酒店管理学院、五金刀剪学院、海上风电学院等产业学院和数字旅游研究中心，着力培育学生的“工匠精神”，为广东省构建“一核一带一区”区域发展格局提供人才支持和智力保障，为加快推进区域协调发展和沿海经济带区域经济社会高质量发展提供新动能。\n\n**多向协力，尖端创新**\n&emsp;&emsp;阳江校区协同建在校内的先进能源科学与技术广东省实验室阳江分中心（阳江海上风电实验室）、材料科学与技术广东省实验室阳江分中心（阳江合金材料实验室）以及`华南理工大学阳江研究院`，构建一流的教学科研与实践条件，在科技开发、科技成果产业化、科技咨询及培训等方面开拓创新，形成`大学、省实验室和研究院同步规划、共建共享的格局`。\n<!-- endtab -->\n<!-- tab 广海简介 -->\n{% link 广东海洋大学官网, https://www.gdou.edu.cn/, https://www.gdou.edu.cn/img/logo1.png %}{% link 广东海洋大学简介, https://www.gdou.edu.cn/xxgk/xxjj.html, https://www.gdou.edu.cn/img/logo1.png %}\n\n&emsp;&emsp;广东海洋大学是`广东省人民政府`和`自然资源部`共建的`省属重点建设大学`，是一所多学科协调发展的`综合性海洋大学`，是教育部本科教学水平评估优秀院校，是广东省高水平大学重点学科建设高校。  \n&emsp;&emsp;学校以海洋和水产为特色、多学科协调发展的`综合性大学`，是教育部本科教学水平评估`优秀院校`，是具有“学士、硕士、博士”`完整学位授权体系`的大学，是广东省高水平大学`重点学科建设高校`。现有“水产”“食品科学与工程”“海洋科学”等`3个一级学科博士点`，`11个一级学科硕士点`，`12个硕士专业学位类别`；81个本科专业，全日制本科在校生3.5万人。\n{% folding cyan,学校历程时间轴：%}\n{% timeline 学校历程（摘自学校官网）：,blue %}\n<!-- timeline 1935年 -->\n&emsp;&emsp;学校前身是广东省立高级水产职业学校，是广东现代海洋水产教育的发端，原暨南大学水产系、原华南工学院（现华南理工大学）湛江分院先后并入。\n<!-- endtimeline -->\n<!-- timeline 1979年 -->\n&emsp;&emsp;学校升格发展为农业部直属的湛江水产学院。经教育部批准，具有62年办学历史的湛江水产学院和39年办学历史的原华南农学院（现华南农业大学）湛江分院为基础发展起来的湛江农业专科学校。\n<!-- endtimeline -->\n<!-- timeline 1997年 -->\n&emsp;&emsp;学校进行实质性合并组建为湛江海洋大学。\n<!-- endtimeline -->\n<!-- timeline 2001年12月 -->\n&emsp;&emsp;国家气象局主管的全国重点中专湛江气象学校并入湛江海洋大学。\n<!-- endtimeline -->\n<!-- timeline 2005年6月 -->\n&emsp;&emsp;湛江海洋大学更名为`广东海洋大学`。\n<!-- endtimeline -->\n<!-- timeline 2021年1月 -->\n&emsp;&emsp;省委、省政府明确由我校作为举办校，与阳江市政府、省教育厅、华南理工大学共建`广东海洋大学阳江校区`。\n<!-- endtimeline -->\n{% endtimeline %} \n{% endfolding %}\n\n&emsp;&emsp;湛江市的`湖光校区`（校本部，麻章区海大路1号）、`霞山校区`（霞山区解放东路40号）、`海滨校区`（霞山区海滨大道中5号）三个校区占地面积4892亩，其中湖光校区坐落于国家AAAA级旅游景区湖光岩世界地质公园东侧。\n&emsp;&emsp;`湛江校区`设有水产学院、海洋与气象学院、食品科技学院、滨海农业学院、机械与动力工程学院、海洋工程学院、马克思主义学院、经济学院、管理学院、数学与计算机学院（软件学院）、电子与信息工程学院、化学与环境学院、海运学院、文学与新闻传播学院、法政学院、外国语学院、中歌艺术学院、体育与休闲学院、继续教育学院等`19个`学院。\n&emsp;&emsp;阳江市的`阳江校区`（江城区罗琴路1号）西靠阳江八景之一的罗琴山，南临风景优美的罗琴湖，总规划用地面积3500亩，第一期建设项目用地512亩，已于2021年6月建成。校区设有机械与能源工程学院、材料科学与工程学院、计算机科学与工程学院、食品科学与工程学院、商学院等`5个`学院，首次招收学生710人。`第二期`规划建设`7个`学院、30个专业。\n<!-- endtab -->\n{% endtabs %}\n\n***\n\n# 校区QA\n{% folding cyan close,校区QA（默认折叠，点击展开）  %}\n>QA不带图，图片统一放在后文，更多问题可以在评论区留言\n\n**问题1：**阳江校区与广东海洋大学是什么关系？\n&emsp;&emsp;阳江校区是广东海洋大学四个校区之一，是学校的一部分，只不过位置在阳江，同享广海的“本、硕、博”完整学位授权体系，目前也同步进行学科工程认证。毕业证一样的。\n\n**问题2：**阳江校区基础设施和建设完善么\n&emsp;&emsp;校区经过首批师生的开荒，目前基础设施完善，运动方面有体育馆、室外篮球场、跑道还有健身房。物理、电路、机械、食品等实验室很完善。教学楼也非常完善（这些看图就知道了），不过厚为楼那块里面不少房间还比较空。学校也会定期听取学生代表建议来完善校区建设。\n\n**问题3：**宿舍咋样？\n&emsp;&emsp;广海最好的宿舍，现在入住全是崭新出厂的新宿舍，全部为上床下桌四人间，两个风扇一台空调，卫浴分离有两种花洒，不限电不断网，晚上11点30分要关宿舍灯，不过可以开阳台灯和自己的台灯，一个宿舍一个华为wifi终端（可插网线），专业物业管理，物业会查违规电器，{% del 会提前通知不搞突击 %}。\n\n**问题4：**饭堂怎么样？\n&emsp;&emsp;目前饭堂的饭菜还是较为摆烂（早餐除外），窗口较少（服务目前的700人够了），饭菜也只能管饱，算不上美味，下学期开新饭堂。但是饭堂环境不错，有多台空调，wifi覆盖。不过如果你恰好财力雄厚，可以找饭堂经理订餐（经理：想吃啥就来面谈预定，饭堂都能买来做，按成本价，收服务费），在二楼包间吃。\n\n**问题5：**外卖业如何？\n&emsp;&emsp;在首批学生的开荒下，学校外卖业形成了多平台（学生平台、商家平台）模式，依托小程序在线点餐，配送模式有校门口自取、送到宿舍楼下，送到宿舍门口。外卖员由学生兼职。外卖涵盖早餐、午餐、晚餐和夜宵。外卖种类多，有kfc、麦当劳、披萨、炸鸡、烧烤、奶茶饮品、各类饭菜和粉面。若不封校可自行到校门口隔条马路的对面的饭店吃。特别的还有学校食工院学生开的解馋宵夜店，有手抓饼、薯条、章鱼小丸子等各种夜宵。\n\n**问题6：**学校周围荒凉么？\n&emsp;&emsp;周围还待开发，校门口隔条马路对面有饭店、超市、美宜佳，玩的地方周围是没有了。\n\n**问题7：**去市区方便么？\n&emsp;&emsp;出校门口左转就有广海公交站台，阳江的公交比较摆烂，但是在许多师生和学校的反馈、阳江市政府的资金支持下，目前可以做到30到60分钟一趟，正常去到市区要40分钟，打滴滴等需要20到30分钟。\n\n**问题8：**校医院如何？\n&emsp;&emsp;校医院只能处理一些小毛病，若出现发烧等问题，辅导员和物业将送你到最近的中医院，从学校到中医院开车要20分钟，若是紧急情况，学校也有救护车常驻。\n\n**问题9：**图书馆情况？\n&emsp;&emsp;校区图书馆室阅读区、自习区、电子浏览室、研习间等都已建好，还有两层比较空（有两个英语听力教室），但已经建好的很完善够用了，整个图书馆wifi空调全覆盖，藏书也较多且在逐步引进各种书籍与报刊，图书馆有终端机器，用于找书与还书，馆内管理有序。\n\n**问题10：**校区的计科和主校区的区别？\n&emsp;&emsp;两边课程是一样的，上学期学C语言、线代，下学期学JAVA、大物、离散、电路、模电，师资力量我觉得差不多（[阳江校区计科师资](https://www.gdou.edu.cn/compsci/szdw1.htm)）。老师由新招老师、主校区老师。华工老师组成，主校区的老师两边奔波，不过也有主校区老师是只教新校区了，比如上学期教C语言的吴卫祖教授，是原来主校区数学与计算机学院副院长。老师上课也挺有激情（特别是离散老师），还有不少新老师在面试。不过主校区计科最大的优势我觉得是历史久，有很多成熟的项目团队，计算机嘛，靠自学和做项目，项目经验很重要，阳江校区的团队，恐怕得再等一两年了。不过能力强的也可以自己找开源项目做。\n\n**问题11：**社团情况？\n&emsp;&emsp;社团有不少，也经常有活动的公告牌在饭堂、教学楼、宿舍区摆着，会有社团招新日，不过毕竟从零开始，还得摸索着来，博主没加入社团，所以具体的方面不了解。\n\n**问题12：**校区内各类比赛多么?\n&emsp;&emsp;多！而且因为比赛多还人少，基本报了就能参加，计科有校内算法比赛，蓝桥杯、ACM，大比赛和主校区同学一起作为广海队伍参加，当然也能参加别的院组织的比赛，比如博主就参加了两次由机械院组织的循迹小车比赛，小车、场地等所需物资都由学院提供。\n\n**问题13：**教学楼环境怎么样？\n&emsp;&emsp;两个班（70人）一个教室上课，一间教室三台空调，不过wifi还没覆盖，桌椅全新挺漂亮（具体看图），每层都有热饮水机（不用钱的）、卫生间和垃圾桶。部分课（高数、线代等）在一楼大教室上，四个班一起即所有计科的学生一起，大教室是阶梯教室的样子，中间有两块大屏幕，防止后排学生看不到ppt，一个大教室三台大空调，还有若干风扇。\n\n**问题14：**平时如何进行教学？\n&emsp;&emsp;由校区老师、主校区老师上课，主校区老师两边奔波，比如高数、大物老师，不过计科的高数老师好像申请了只教阳江校区。\n\n**问题15：**平时可以去主校区么？\n&emsp;&emsp;由于疫情的关系，封校，不过想出去只需要企业微信和辅导员申请，而且原则上不允许过夜，所以平时去不了，但是部分有事情的学生，在学校安排下会过去主校区，由学校大巴接送。\n\n**问题16：**二三期什么时候建好?\n&emsp;&emsp;二期目前还没开始建设，暑假动不动工不清楚，目前一期还有6栋空宿舍楼，按我们700人住了三栋楼（有些宿舍没住满）来算，最迟明年就会开启二期建设了。也不用担心未来施工太吵，后面的建设离现在的宿舍和教学区都有一定距离。\n\n**问题17：**学校小么？\n&emsp;&emsp;现在只有512亩，沿着最外围校道走一圈是2.5km，相比于一般大学上千亩还是挺小的，但好处就是宿舍走到（走快点）教室只需要10多分钟，去哪都方便\n\n**问题18：**学校可以带载具么？\n&emsp;&emsp;可以骑自行车（要统一上牌），可以玩滑板、滑轮。\n\n**问题19：**多少排位能上阳江校区的计科？\n&emsp;&emsp;去年计科最低排位8.9w，不过今年大背景是公办学校缩招许多，加上去年是阳江校区第一年招生与广东省第一年新高考，8.9w我觉得今年还会再高，不过都可以冲冲冲，但注意今年不再是一个专业组里只有一个计科专业，阳江校区今年的计算机专业组有三个专业：计科、物联网工程、信管，如果报了这个专业组，但是排位在8.9w左右的，得考虑会不会调剂到其他两个专业，不过其他两个专业在主校区排位是9w以内的，也不会差。\n\n**问题20：**校园网如何？\n&emsp;&emsp;我们第一年是免费使用，不知道今年新生还有没有免费用一年政策，目前只有移动的网络，以后会有电信。未来收费300块一年30Mbps速度（3.75MB/s），更多套餐要等通知。\n\n**问题21：**学校手机信号，移动网络质量如何？\n&emsp;&emsp;校门口对面就有大基站，三大运营商的信号都是满格的（安卓红米k40，苹果不清楚）。\n\n**问题22：**学费和住宿费情况？\n&emsp;&emsp;学费和主校区的一样，今年计算机相关专业学费两边都是6850，住宿费都是900-1700（来自志愿书上），其他专业的费用应该也是和主校区的差不多，到正式填志愿，志愿系统会把费用放在专业后面的。\n\n**问题23：**怎么去高铁站？\n&emsp;&emsp;在放寒假暑假时，学校会组织大巴直接去高铁站，上午下午各一趟，新生报道在高铁站会有老师和大巴接送。\n\n**问题24：**商业区如何？\n&emsp;&emsp;一个超市，东西算多品，种类也多，要什么也可以和主管说进货，一个小面包房，有面包、水果拼盘、小吃啥的，菜鸟驿站还挺大，除了韵达京东进不来要在校门口拿，其它快递都能进来，每天都派送。校区的商业区还是比较拉的，想逛街、吃喝玩乐不太行。\n\n**问题25：**转专业难么？\n&emsp;&emsp;不建议把转专业看得太有希望，竞争还是很大的。在阳江校区也是这样，转入计算机院今年整个校区才4个名额。\n\n**问题26：**水电费情况？\n&emsp;&emsp;学校使用完美校园管理智能水电，自来水每年补贴吨数非常多，我用了一年还有70多吨，等于自来水不用钱。电费一度7毛多，也有补贴，但不够用的。洗澡热水10分钟大概不到一块钱，热水24小时都有。\n\n**问题27：**在阳江读书以后实习好找么？\n&emsp;&emsp;不清楚，毕竟校区还没大三大四学生，按主校区的情况来看，实习可以由学校安排,也可以由自己找单位,主校区那边有去广州、深圳实习的。\n\n**更多问题在评论区讨论吧，典型问题将扩充在此处。**\n\n{% endfolding %}\n\n***\n\n# 去年录取分数线、今年招生情况\n**2021阳江校区分数线：**\n<div><img src=https://npm.elemecdn.com/chuckle-js-css/post/14/2021-2.webp width=\"95%\" height=\"95%\"></div>\n\n**2022阳江校区开设专业与招生情况：**\n具体情况以志愿系统为准！！！\n<div><img src=https://npm.elemecdn.com/chuckle-js-css/post/14/2022-1.webp width=\"100%\" height=\"100%\"><img src=https://npm.elemecdn.com/chuckle-js-css/post/14/2022-2.webp width=\"100%\" height=\"100%\"></div>\n\n{% link 广东海洋大学2022年普通本科招生专业组分组情况表（广东省）,https://zsjy.gdou.edu.cn/newstudent/view/aid/494/tag/xwgg , https://www.gdou.edu.cn/img/logo1.png %}\n\n***\n\n# 广海阳江校区2022年招生宣传片\n{% folding cyan close,宣传片（默认折叠，点击展开）  %}\n<div style=\"position: relative; padding: 30% 45%;\">\n<iframe style=\"position: absolute; width: 100%; height: 100%; left: 0; top: 0;\" src=\"//player.bilibili.com/player.html?aid=812828401&bvid=BV1R34y1W7pE&cid=757003892&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"></iframe>\n</div>\n{% endfolding %}\n\n***\n\n# 校区未来规划图\n{% gallery %}\n![](https://npm.elemecdn.com/chuckle-js-css/post/14/wl1.webp)\n![](https://npm.elemecdn.com/chuckle-js-css/post/14/wl2.webp)\n{% endgallery %}\n\n***\n\n# 校区有关图文\n{% folding cyan close,图文（默认折叠，点击展开）  %}\n{% link 学校官网的展示图片,https://www.gdou.edu.cn/yjxq/xqgk/xyfg.htm , https://www.gdou.edu.cn/yjxq/images/logo.png %}\n{% link 广海阳江校区招生简章,https://mp.weixin.qq.com/s/uha1P5jLTUIb-oukeC83Pw , https://www.gdou.edu.cn/yjxq/images/logo.png %}\n{% link 2022年广海阳江校区招生宣传片,https://www.gdou.edu.cn/yjxq/xqgk/xxcsp.htm , https://www.gdou.edu.cn/yjxq/images/logo.png %}\n{% link 计算机科学与工程学院宣传片,https://www.gdou.edu.cn/compsci/xygk/xyjj.htm,https://www.gdou.edu.cn/compsci/images/logo.png %}\n{% link 计算机科学与工程学院官网,https://www.gdou.edu.cn/compsci/, https://www.gdou.edu.cn/compsci/images/logo.png%}\n{% link 阳江校区图书馆官网,https://yjlib.gdou.edu.cn/ , https://yjlib.gdou.edu.cn/engine2/upload/engine/2021-08-28/202108281638525796.png %}\n{% endfolding %}\n\n***\n\n# 校区图片（更新中）\n>建议配合宣传视频食用\n>图片部分来自互联网收集，侵删；图片经过压缩。\n\n{% gallery %}\n![](https://npm.elemecdn.com/chuckle-js-css/post/14/14-1.webp)\n![](https://npm.elemecdn.com/chuckle-js-css/post/14/14-2.webp)\n![](https://npm.elemecdn.com/chuckle-js-css/post/14/14-3.webp)\n![](https://npm.elemecdn.com/chuckle-js-css/post/14/14-4.webp)\n![](https://npm.elemecdn.com/chuckle-js-css/post/14/14-5.webp)\n![](https://npm.elemecdn.com/chuckle-js-css/post/14/14-6.webp)\n![](https://npm.elemecdn.com/chuckle-js-css/post/14/14-7.webp)\n![](https://npm.elemecdn.com/chuckle-js-css/post/14/14-8.webp)\n![](https://npm.elemecdn.com/chuckle-js-css/post/14/14-9.webp)\n![](https://npm.elemecdn.com/chuckle-js-css/post/14/14-10.webp)\n![](https://npm.elemecdn.com/chuckle-js-css/post/14/14-11.webp)\n![](https://npm.elemecdn.com/chuckle-js-css/post/14/14-12.webp)\n![](https://npm.elemecdn.com/chuckle-js-css/post/14/14-13.webp)\n![](https://npm.elemecdn.com/chuckle-js-css/post/14/14-14.webp)\n![](https://npm.elemecdn.com/chuckle-js-css/post/14/14-15.webp)\n![](https://npm.elemecdn.com/chuckle-js-css/post/14/14-16.webp)\n![](https://npm.elemecdn.com/chuckle-js-css/post/14/14-17.webp)\n![](https://npm.elemecdn.com/chuckle-js-css/post/14/14-18.webp)\n![](https://npm.elemecdn.com/chuckle-js-css/post/14/14-19.webp)\n![](https://npm.elemecdn.com/chuckle-js-css/post/14/14-20.webp)\n![](https://npm.elemecdn.com/chuckle-js-css/post/14/14-21.webp)\n![](https://npm.elemecdn.com/chuckle-js-css/post/14/14-22.webp)\n![](https://npm.elemecdn.com/chuckle-js-css/post/14/14-23.webp)\n![](https://npm.elemecdn.com/chuckle-js-css/post/14/14-24.webp)\n![](https://npm.elemecdn.com/chuckle-js-css/post/14/14-25.webp)\n![](https://npm.elemecdn.com/chuckle-js-css/post/14/14-26.webp)\n![](https://npm.elemecdn.com/chuckle-js-css/post/14/14-27.webp)\n![](https://npm.elemecdn.com/chuckle-js-css/post/14/14-28.webp)\n![](https://npm.elemecdn.com/chuckle-js-css/post/14/14-29.webp)\n![](https://npm.elemecdn.com/chuckle-js-css/post/14/14-30.webp)\n![](https://npm.elemecdn.com/chuckle-js-css/post/14/14-31.webp)\n![](https://npm.elemecdn.com/chuckle-js-css/post/14/14-32.webp)\n![](https://npm.elemecdn.com/chuckle-js-css/post/14/14-33.webp)\n![](https://npm.elemecdn.com/chuckle-js-css/post/14/14-34.webp)\n![](https://npm.elemecdn.com/chuckle-js-css/post/14/14-35.webp)\n![](https://npm.elemecdn.com/chuckle-js-css/post/14/14-36.webp)\n![](https://npm.elemecdn.com/chuckle-js-css/post/14/14-37.webp)\n![](https://npm.elemecdn.com/chuckle-js-css/post/14/14-38.webp)\n![](https://npm.elemecdn.com/chuckle-js-css/post/14/14-39.webp)\n![](https://npm.elemecdn.com/chuckle-js-css/post/14/14-40.webp)\n![](https://npm.elemecdn.com/chuckle-js-css/post/14/14-41.webp)\n![](https://npm.elemecdn.com/chuckle-js-css/post/14/14-42.webp)\n![](https://npm.elemecdn.com/chuckle-js-css/post/14/14-43.webp)\n![](https://npm.elemecdn.com/chuckle-js-css/post/14/14-44.webp)\n![](https://npm.elemecdn.com/chuckle-js-css/post/14/14-45.webp)\n{% endgallery %}\n\n***\n","tags":["其它"],"categories":["其它"]},{"title":"超星学习通数据泄露事件记录","url":"/article/af84a159.html","content":"\n# 事件时间轴\n{% timeline 时间轴 ,blue %}\n<!-- timeline 2022-06-20 -->\n1. 学习通被爆有`1.7亿`师生账号信息`数据泄露`  \n包括手机号码、邮箱、姓名、学校、班级、明文密码等信息  \n随后，热搜词条`#学习通数据库疑发生信息泄露#`被撤,词条内容被屏蔽\n<div><img src=/images/13-1.webp width=\"40%\" height=\"40%\"></div>\n\n<!-- endtimeline -->\n<!-- timeline 2022-06-21 上午-->\n`#学习通#`词条登顶微博热搜第一\n很多人发现自己学习通的使用量多达上万、几十万次（图为博主的次数，2万次）\n<div><img src=/images/13-2.webp width=\"40%\" height=\"40%\"></div>\n\n<!-- endtimeline -->\n<!-- timeline 2022-06-21 15:45-->\n学习通就泄露事件做出声明：`目前还未发现数据泄露，确认不存在明文密码泄露。`\n<div><img src=/images/13-3.webp width=\"40%\" height=\"40%\"></div>\n\n<!-- endtimeline -->\n<!-- timeline 2022-06-21 16:17-->\n学习通就异常使用量做出声明：`正常现象。`\n<div><img src=/images/13-4.webp width=\"40%\" height=\"40%\"></div>\n\n<!-- endtimeline -->\n{% endtimeline %}\n\n***\n\n# 事件相关\n1. 2020年超星学习通就被[国家信息安全漏洞共享平台(cnvd)](https://www.cnvd.org.cn/)警告存在`信息泄露漏洞`\n{% link 超星学习通App存在信息泄露漏洞, https://www.cnvd.org.cn/flaw/show/CNVD-2020-61119, %}\n<div><img src=/images/13-5.webp width=\"40%\" height=\"40%\"></div>\n\n2. 著名蓝色机器人发通知与投票：\n<div><img src=/images/13-6.webp width=\"40%\" height=\"40%\"></div>\n\n3. 博主已中招\n<div><img src=/images/13-7.webp width=\"40%\" height=\"40%\"></div>\n\n4. 学习通的一些`免责条款`：总之，无责\n<div><img src=/images/13-8.webp width=\"40%\" height=\"40%\"></div>\n\n\n***\n","tags":["其它"],"categories":["其它"]},{"title":"记一次超声波避障小车比赛","url":"/article/81935dcb.html","content":"\n>去年第一次红外循迹比赛的时候我还没整博客，第二次便记录一下吧\n\n# 比赛简介\n学校机械院举办的智能小车比赛，一学期一次，上次是红外循迹，这次是超声波避障  \n小车是学院统一采购的，第一次去比赛时拿到的是散件，51单片机、电阻、其它芯片等，都得自己焊  \n\n***\n\n# 关于队伍\n一位机械院的同学在酷安私信我参不参加智能小车比赛，我那时还不认识他，但想着反正闲着也是闲着，参加点活动也好，便一拍即合，后面他又拉来了商学院的一位男同学和两位女同学  \n第一次比赛，我们也是唯一有商学院同学的队伍（其它队伍队均两机械两计科），不过我们队也是女同学最多的，Buff加满   \n\n队名我提议是秋名山车队，又是一拍即合  \n\n***\n\n# 关于比赛\n小车在上次比赛时就已搞好，所以这次重点在写个超声波避障程序烧进去  \n作为队里唯一的计科同学，这个程序当然得我搞了  \n但我倒也摸鱼，程序不难，测试过一次没毛病，剩下就是数值的微调（这就是我比赛前一天晚上才去调的原因么（误））\n\n***\n\n# 比赛过程\n过程简单，就是一遍一遍测试，然后改改数值，调调机制，然后队伍抽签轮流上，看谁跑的时间短  \n上午7个队（本来12个队，弃权了5个，新报名的队伍焊坏小车的不少），取前三进入下午复赛  \n\n***\n\n# 结果\n第一次的比赛我们第二，这次还是第二，属于万年老二了  \n上次有初赛复赛都有奖册，我拿了一本，这次只有复赛一本册子，给了队里一位女同学，争取以后人手一本  \n\n***\n\n# 一些图片\n<div><img src=/images/12-1.webp width=\"100%\" height=\"100%\"></div>\n\n<div><img src=/images/12-2.webp width=\"100%\" height=\"100%\"></div>\n\n<div><img src=/images/12-3.webp width=\"100%\" height=\"100%\"></div>\n\n<div><img src=/images/12-4.webp width=\"100%\" height=\"100%\"></div>\n\n***","tags":["Chuckle"],"categories":["Chuckle"]},{"title":"FakeLocation模拟校园跑教程","url":"/article/c5d354fd.html","content":"\n我们学校用的是运动世界校园，所以就用这个软件为例，其他软件差不多  \n博主测试设备：红米k40安卓11、红米6pro安卓9  \n>吐槽：这软件，什么都往里塞，天天更新加广告（一指禅干掉）  \n\n# 准备工作\n1、首先是有面具**Root**，而非小米官方等残废root  \n2、下载万恶之源：运动世界校园  \n3、下载安装[FakeLocation1.3.0.2版本](https://wwm.lanzoul.com/iMHUo057ibyb)  \n4、下载安装[隐藏应用列表xp模块](https://wwm.lanzoul.com/iQ6lq057irkd)我使用的版本1.6较老，但能稳定用我也没去升级  \n5、安装lsp/xp框架  \n6、下载安装[Godvip](https://wwm.lanzoul.com/i8RYM057ibzc)  \n\n***\n\n# 隐藏防检测\n\n## 运动世界校园权限设置\n确保权限设置与图一致，关闭miui的模糊定位  \n<div><img src=/images/11-1.webp width=\"90%\" height=\"90%\"></div>\n\n## 隐藏root\n面具本身随机包名安装  \n面具hide对运动世界校园全勾选（如果是24版本的面具，自行去酷安找shamiko模块隐藏root教程，我还没升到24，因为我用hide就能很好地隐藏root）  \n\n## 隐藏应用列表设置\n推荐先看酷安详细图文：[隐藏应用列表使用教程 Pro](https://www.coolapk.com/feed/34458057?shareKey=YjBlYzcxNDgwMzYwNjI4OGIzZmM~)  \n\n简单速通：  \n1、lsp/edxp启用**隐藏应用列表**  \n2、也许需要重启手机  \n3、点击模板管理，启用所有隐藏方式  \n4、选择要隐藏的应用，将FakeLocation、面具、lsp等搞机应用勾选  \n5、对运动校园应用模板  \n<div><img src=/images/11-2.webp width=\"100%\" height=\"100%\"></div>\n\n## 破解FakeLocation\nlsp启用Godvip，模块对FakeLocation起作用  \n\n## FakeLocation设置\n给FakeLocation软件Root权限  \nFakeLocation设置页只打开**模拟GPS信号**  \n<div><img src=/images/11-3.webp width=\"50%\" height=\"50%\"></div>\n\n## 如何模拟跑\n首先到一个较空旷，能接收到gps信号的地方（宿舍阳台、宿舍走廊），拿个椅子坐下，手机关闭wifi（可以开启蓝牙和数据）  \nFakeLocation选择**要模拟的位置**到跑道，当然具体在哪无所谓  \n打开运动软件，**待运动软件接收到gps信号**提示可以开始跑，返回FakeLocation软件，点击**启动模拟**（第一次打开需要等待一会，建议在模拟跑前先开关一次预热），并**打开摇杆**  \n\n摇杆设置：  \n摇杆里的**模拟gps信号**和**步频模拟**都得关掉，不能打开！不能打开！不能打开！   \n<div><img src=/images/11-4.webp width=\"100%\" height=\"100%\"></div>\n\n接着返回运动软件，你会发现显示的位置瞬移到了之前选择的模拟位置处，然后开始运动，要去哪就**用摇杆摇**到哪，步频可以使用其它软件模拟，但**建议抖手**  \n跑完后先结束运动，关闭运动软件，再停止位置模拟  \n\n***\n\n# 可能出现的问题\n1、当摇杆回到中间时（速度为0），运动软件会提示gps信号弱，这是正常现象  \n2、启动模拟后，运动软件上显示的位置没变：杀掉运动软件和FakeLocation，重新操作一次  \n3、启动模拟后，运动软件上显示的位置变了，但一开始运动位置就变回原来位置：杀掉运动软件和FakeLocation，重新操作一次  \n4、被检测到环境异常4：FakeLocation没隐藏好、运动软件检测到gps信号长期未变。请自查有无和教程操作不同的地方  \n\n# 温馨提示\n\n>如有问题可在评论区回复或在酷安找我\n>本教程虽然目前还可行，博主自用了两个学期也没被检测到一次，但安卓设备众多，系统繁杂，不确保教程的通用性\n>Root手机导致手机变砖、假跑被检测到影响体育成绩等后果，博主不承担任何责任\n\n***\n","tags":["教程"],"categories":["教程"]},{"title":"JAVA/面向对象学习笔记(3)","url":"/article/8636f786.html","content":"\n>所看教程（视频）：《浙江大学-翁恺-Java-面向对象程序设计》\n>作为我自己的复习笔记，也可以当做该视频的同步笔记\n>上接[JAVA/面向对象学习笔记(2)](https://www.chuckle.top/article/9f2dc6c7.html)\n\n# Swing\n**Swing**是一个为Java设计的GUI工具包，是java的基础类（import javax.swing.*;）  \n在Swing中，所有我们在界面中看到的东西都是**部件**（组件）  \n\n其中容器是一种特殊的部件\n部件可以被放进容器中，当然容器也能放进容器中  \n\nSwing提供了一个底层容器类JFrame，即整个窗口    \n```java JFrame中常用的方法\n//创建一个无标题的窗口\nJFrame()\n//创建标题为s的窗口\nJFrame(String s)\n//设置窗口的初始位置是(a,b),即距屏幕左面a个像素，距屏幕上方b个像素，窗口的宽是width,高是height。\npublic void setBounds(int a,int b,int width,int height)\n//设置窗口的大小。\npublic void setSize(int width,int height)\n//设置窗口的位置，默认位置是(0,0)。\npublic void setLocation(int x,int y)\n//设置窗口是否可见，窗口默认是不可见的。\npublic void setVisible(boolean b)\n//设置窗口是否可调整大小，默认可调整大小。public voiddispose()撤销当前窗口，并释放当前窗口所使用的资源。\npublic void setResizable(boolean b)\n//撤销当前窗口，并释放当前窗口所使用的全部资源\npublic void dispose()\n//设置窗口的扩展状态\npublic void setExtendedState(int state)\n//其中参数state取JFrame类中的下列类常量:\nMAXIMIZED_HORIZ (水平方向最大化)，\nMAXIMIZED_VERT (垂直方向最大化)，\nMAXIMIZED_BOTH (水平、垂直方向都最大化)。\n//该方法用来设置单击窗体右上角的关闭图标后，程序会做出怎样的处理，\npublic void setDefaultCloseOperation(int operation)\n//其中的参数operation取JFrame类中的下列int型static常量，程序根据参数operation取值做出不同的处理:\nDO_NOTHING_ON_CLOSE(什么也不做)，\nHIDE_ON_CLOSE (隐藏当前窗口)，\nDISPOSE_ON_CLOSE (隐藏当前窗口，并释放窗体占有的其他资源)，\nEXIT_ON_CLOSE (结束窗口所在的应用程序)\n```\n\n## add\n通过add把一个部件加到一个容器中  \n部件被加到容器后，就受这个容器所管理  \n容器管理部件的方式叫**布局管理器**  \nJFrame默认采用的布局管理器叫**BorderLayout**,默认把部件放到CENTER  \n```java\ntheView = new View(theField);//theView是一个容器\nJFrame frame = new JFrame();//创建一个底层容器\nframe.add(theView);//把theView容器加到底层容器中。默认为中间\nJButton btnstep =new JButton(\"单步\");//btnstep是一个按钮部件\nframe.add(btnstep, BorderLayout.SOUTH);//把btnstep部件加到底层容器中，且放到南边（窗口最下面）\n```\n\n## BorderLayout\nBorderLayout把整个容器划分为五个部分  \n<div><img src=/images/7-13.webp width=\"60%\" height=\"60%\"></div>\n\n后面放进去的部件会替换掉相同位置的部件（这就是为什么之前界面中只剩下一个按钮了）  \n当有部分没有部件时，其他部分会膨胀，将那个位置所占据  \n\nBorderLayout会根据部件里面的东西来帮我们计算，这个部件需要占据多大的空间 \n\n## 消息机制\n现在我们有了一个按下去没反应的按钮  \n如何让按钮按下去有反应？程序如何知道按钮被按下去了？  \n用户在图形界面做了一些操作，通过一些路径让程序知道，这个路径叫做**消息机制**  \n\nJava的Swing类实现了一个有意思的消息机制  \n```java\nJButton btnstep =new JButton(\"单步\");\nframe.add(btnstep, BorderLayout.SOUTH);\nbtnstep.addActionListener(new ActionListener(){\n    @Override\n\tpublic void actionPerformed(ActionEvent e) {\n\t\tSystem.out.println(\"成功按下!\");\n\t}\n});\n```\n运行一下，当我们点击一次按钮，控制台都会输出一次“成功按下!”\n\n现在程序已经知道按钮被按下，且在上面的古怪代码中能成功做一些我们期望程序做的事（输出点东西）  \n我们可以把输出点东西换成其它事情，在狐狸和兔子中，step()函数控制单步  \n我们只需要做下面一些动作，就能让按钮控制单步  \n```java\nprivate JFrame frame;//把frame从FoxAndRabbit()中拿出来，让它变为FoxAndRabbit类中的成员变量\n···\n//JFrame frame = new JFrame();\nframe = new JFrame();\n···\nbtnstep.addActionListener(new ActionListener(){\n    //实现了ActionListener这个接口的匿名类\n    @Override\n\tpublic void actionPerformed(ActionEvent e) {\n\t\tstep();\n        frame.repaint();\n\t}\n});\n···\n//fab.start(500);把main里的这句去掉，不让程序主动地开始\n``` \n现在每按一次按钮，程序就会运行一步  \n\n按钮自己有代码，知道自己被按下去了，但按钮作为一个早已经定好的类不可能有代码去调用step()\n但实际效果就是，每按一次按钮，step()就会被调用一次，这是怎么做到的？  \n<div><img src=/images/7-14.webp width=\"90%\" height=\"90%\"></div>\n\nJButton类提供了一个接口，只要实现了这个接口的类的对象，都可以通过**addActionListener()**方法**注册**给JButton，当按钮发现自己被按下去了，就会检查有没有东西注册在按钮那，接着找到重写的**actionPerformed()**，这样JButton就知道step()了  \n注册进去的东西，是运行时候一个动态的对象  \n\n这就是**反转控制**（Swing的消息机制）：\n·由按钮公布一个守听者接口和一对注册/注销函数  \n·你的代码实现那个接口，将守听者对象注册在按钮上  \n·一旦按钮被按下，就会反过来调用你的守听者对象的某个函数   \n\n## 内部类、匿名类\n刚刚实现接口的代码看起来十分奇怪\n```java\nbtnstep.addActionListener(new ActionListener(){\n    //实现了ActionListener这个接口的匿名类\n    @Override\n\tpublic void actionPerformed(ActionEvent e) {\n\t\tstep();\n        frame.repaint();\n\t}\n});\n```\n可以换种写法\n```java\n//在类中新增这个类\nprivate class stepListener implements ActionListener {\n\t@Override\n\tpublic void actionPerformed(ActionEvent e) {\n\t\tstep();\n\t\tframe.repaint();\t\t\t\n\t}\n}\n···\n//原来的代码替换为这句\nbtnstep.addActionListener(new stepListener());\n```\n在一个类的内部，再定义一个类，这个类就叫**内部类**  \n内部类可以**直接访问**其所处类的**所有**成员  \njava的内部类也是类的成员  \n外部是函数时，只能访问那个函数里**final**的变量   \n\n用匿名类实现接口\n```java\nnew ActionListener(){\n    //实现了ActionListener这个接口的匿名类\n    @Override\n\tpublic void actionPerformed(ActionEvent e) {\n\t\tstep();\n        frame.repaint();\n\t}\n}\n```\n在**new对象**的时候给出的**类的定义**形成了匿名类  \n匿名类可以**继承某类**，也可以**实现某接口**  \nSwingl的消息机制广泛使用匿名类  \n外部是函数时，只能访问那个函数里**final**的变量  \n\n为什么需要匿名类？\nSwing的消息机制决定了，每个部件发出的消息，都需要新的类去实现接口，然后去接收消息，当部件很多时，给每个类起名字非常麻烦   \n\n***\n\n# 一个课程表\n做一个课程表程序，它有8行7列，有表头表示7天，每个格子用户能自己编辑内容  \n效果是这样：  \n<div><img src=/images/7-15.webp width=\"60%\" height=\"60%\"></div>\n\n有前面Swing的基础，我们知道想要有一个窗口，需要用到JFrame类，来创建一个底层窗口  \n```java KCB.java\npackage kcb;\n\nimport javax.swing.*;\n\npublic class KCB {\n\n    public static void main(String[] args) {\n        JFrame frame = new JFrame();//声明一个窗口\n        frame.pack();//自动调整窗口大小\n        frame.setVisible(true);//显示窗口\n    }\n}\n```\n现在运行，只有一个空空的窗口，一个空空的容器，我们需要往里面放部件  \n想要一个表格，那就放一个表格进去  \n```java KCB.java\npackage kcb;\n\nimport javax.swing.*;\n\npublic class KCB {\n\n    public static void main(String[] args) {\n        JFrame frame = new JFrame();//声明一个窗口\n\t\tJTable table = new JTable());//声明一个表格\n        frame.add(table);//把表格放进去\n        frame.pack();//自动调整窗口大小\n        frame.setVisible(true);//显示窗口\n    }\n}\n```\n运行一下，还是啥都没有，因为我们还没初始化表格，还没给表格它要的数据  \n\n用JTable类可以以表格的形式显示和编辑数据。  \nJTable类的对象并不存储数据，它只是数据的表现。  \nJTable实现了数据与表现的分离  \n\n新建一个KCBData类，作为表格的数据  \n让这个类实现一个叫TableModel的接口  \n```java KCBData.java\npackage kcb;\n\nimport javax.swing.event.TableModelListener;\nimport javax.swing.table.TableModel;\n\npublic class KCBData implements TableModel {\n\n    @Override\n    public int getRowCount() {\n        return 0;\n    }\n\n    @Override\n    public int getColumnCount() {\n        return 0;\n    }\n\n    @Override\n    public String getColumnName(int columnIndex) {\n        return null;\n    }\n\n    @Override\n    public Class<?> getColumnClass(int columnIndex) {\n        return null;\n    }\n\n    @Override\n    public boolean isCellEditable(int rowIndex, int columnIndex) {\n        return false;\n    }\n\n    @Override\n    public Object getValueAt(int rowIndex, int columnIndex) {\n        return null;\n    }\n\n    @Override\n    public void setValueAt(Object aValue, int rowIndex, int columnIndex) {\n\n    }\n\n    @Override\n    public void addTableModelListener(TableModelListener l) {\n\n    }\n\n    @Override\n    public void removeTableModelListener(TableModelListener l) {\n\n    }\n}\n```\nTableModel接口是由JTable提供给我们的  \nTableModel告诉我们，只要实现了它，就能作为数据交给JTable  \n\n完善一下KCBData  \n```java KCBData.java\npackage kcb;\n\nimport javax.swing.event.TableModelListener;\nimport javax.swing.table.TableModel;\n\npublic class KCBData implements TableModel {\n\n    private String[] title = {\"周一\", \"周二\", \"周三\", \"周四\", \"周五\", \"周六\", \"周日\"};//表格标题\n    private String[][] data = new String[8][7];//真正放7天8节课的数据结构\n    //这个data数组里面都是String类型的管理者，所以需要初始化每个管理者去管理一个String类型的空数据\n    public KCBData() {\n        //构造方法,初始化数据,每一行的数据都是空的,即没有数据,这样才能显示表格,否则会报错\n        for (int i = 0; i < data.length; i++) {\n            for (int j = 0; j < data[i].length; j++) {\n                data[i][j] = \"\";//让每一个单元格都是空的\n            }\n        }\n    }\n    @Override\n    public int getRowCount() {\n        return 8;//表格有8行\n    }\n\n    @Override\n    public int getColumnCount() {\n        return 7;//表格有7列\n    }\n\n    @Override\n    public String getColumnName(int columnIndex) {\n        return title[columnIndex];//返回一个表头\n    }\n\n    @Override\n    public Class<?> getColumnClass(int columnIndex) {\n        return String.class;//告诉表格每列的数据类型,每一个都是String类型\n    }\n\n    @Override\n    public boolean isCellEditable(int rowIndex, int columnIndex) {\n        return true;//每个单元格都可以编辑\n    }\n\n    @Override\n    public Object getValueAt(int rowIndex, int columnIndex) {\n        return data[rowIndex][columnIndex];//将每一个单元格的数据返回，让表格拿到\n    }\n\n    @Override\n    public void setValueAt(Object aValue, int rowIndex, int columnIndex) {\n        data[rowIndex][columnIndex] = (String) aValue;//将每一个单元格的数据设置为aValue,即用户输入的数据\n    }\n\n    @Override\n    public void addTableModelListener(TableModelListener l) {\n        //添加监听器\n    }\n\n    @Override\n    public void removeTableModelListener(TableModelListener l) {\n        //移除监听器\n    }\n}\n\n```\n现在表格能拿到数据了，它知道该怎么画一个表格  \n但运行一下，还是没有表头  \n\n这是因为JTable组件显示数据时，如果直接将其放置在Frame的contentPane中则表头一行会显示不出来，如果将其放置在JScrollPane中显示数据的话，表头会自动显示出来。  \n暂时无需关心为什么  \n\n再完善下KCB类，一个课程表就完成了  \n```java KCB.java\npackage kcb;\n\nimport javax.swing.*;\n\npublic class KCB {\n\n    public static void main(String[] args) {\n        JFrame frame = new JFrame();//声明一个窗口\n        JTable table = new JTable(new KCBData());//声明一个表格\n        JScrollPane pane = new JScrollPane(table);//声明一个滚动面板\n        frame.add(pane);//将滚动面板添加到窗口\n        frame.pack();//自动调整窗口大小\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);//设置窗口关闭方式\n        frame.setVisible(true);//显示窗口\n    }\n\n}\n```\n\n## MVC设计模式\n刚刚的课程表结构是这样的  \n<div><img src=/images/7-16.webp width=\"85%\" height=\"85%\"></div>\n\n当JTable决定显示多少列时会调用getColumnCount，当它要显示表头时会调用getColumnName  \n程序运行过程中JTable反过来调用我们自己的KCBData里的方法  \n\n数据由我们自己实现了TableModel的对象来维护，JTable只管表现不管数据  \n\n**MVC**:数据、表现和控制三者分离，各负其责  \n·M=Model（模型)  \n·V=View(表现)  \n·C=Control(控制)  \n\n模型：保存和维护数据，提供接口让外部修改数据，通知表现需要刷新  \n表现：从模型获得数据，根据数据画出表现  \n控制：从用户得到输入，根据输入调整数据  \n\n<div><img src=/images/7-17.webp width=\"85%\" height=\"85%\"></div>\n\n不是由接收到用户输入的代码去修改界面上的显示，而是去修改内部的数据，内部的数据去触发界面的更新  \n\n这样做的好处：每一部分都很单纯，尤其是View表现，只管拿到想要的数据去表现，至于数据是怎么更新，怎么生成的，它统统不管  \n\n在代码实现中，View和Control通常在同个表达界面的类中实现，因为表现和用户控制都是在界面中完成的，这和MVC并不矛盾，只是在具体实现MVC模式时的技巧  \n\n***\n\n# Exception异常\n异常是程序中的一些错误，但并不是所有的错误都是异常，并且错误有时候是可以避免的。  \n比如说，你的代码少了一个分号，那么运行出来结果是提示是错误 java.lang.Error；如果你用System.out.println(11/0)，那么你是因为你用0做了除数，会抛出 java.lang.ArithmeticException 的异常。  \n\n写出下面的程序，idea的编辑器不会指出数组越界的错误，但运行程序控制台会抛出异常  \n```java ArrayIndex.java\npublic class ArrayIndex {\n    public static void main(String[] args) {\n        int[] a = new int[10];\n        a[10] = 10;\n        System.out.println(\"hello\");\n    }\n}\n```\n\n```java 异常\nException in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: Index 10 out of bounds for length 10\n\tat ArrayIndex.main(ArrayIndex.java:4)\n```\n在main里面有Exception异常，问题出在在ArrayIndex的第四行，问题叫做ArrayIndexOutOfBoundsException，即数组越界  \n\n## 两种类型的异常与错误\n\n检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。  \n运行时异常： 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。  \n错误： 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。  \n\n异常和错误的区别：异常能被程序本身可以处理，错误是无法处理。  \n\n## 捕获异常\n当代码某一处可能出现问题、可能出现异常，就可以将这块代码放在一个用于捕捉异常的代码块中  \n```java\ntry\n{\n   // 可能出现异常的程序代码\n}catch(ExceptionName e1)//可以多个catch\n{\n   //处理异常的代码\n}catch(ExceptionName e2)\n{\n   //处理异常的代码\n}finally{\n  //无论是否发生异常，finally 代码块中的代码总会被执行。\n  // 程序代码\n}\n```\n使用 try 和 catch 关键字可以捕获异常。try/catch 代码块放在异常可能发生的地方。try/catch代码块中的代码称为保护代码  \n\nCatch 语句包含要捕获异常类型的声明。当保护代码块中发生一个异常时，try 后面的 catch 块就会被检查。  \n如果发生的异常包含在 catch 块中，异常会被传递到该 catch 块，这和传递一个参数到方法是一样.  \n\n将刚刚数组越界的代码用捕捉异常处理  \n```java ArrayIndex.java\npublic class ArrayIndex {\n    public static void main(String[] args) {\n        int[] a = new int[10];\n        try{\n        a[10] = 10;\n        System.out.println(\"hello\");\n        }catch(ArrayIndexOutOfBoundsException e){\n            System.out.println(\"error\");\n        }\n    }\n}\n```\n运行一下\n```java\nerror\n```\n\n异常是程序运行过程中可能出现的问题，现在这个代码是一定会出错的，我们改造一下  \n```java\nimport java.util.Scanner;\n\npublic class ArrayIndex {\n    public static void main(String[] args) {\n        int[] a = new int[10];\n        int idx = 0;\n        Scanner in = new Scanner(System.in);\n        idx = in.nextInt();\n        try{\n            a[idx] = 10;\n            System.out.println(\"hello\");\n        }catch(ArrayIndexOutOfBoundsException e){\n            System.out.println(\"error\");\n        }\n    }\n}\n```\n\n```java 输出\n输入：2\nhello\n输入：12\nerror\n```\n\n## 异常处理机制\n把可能发出异常的代码放到try里，在try后面用catch去匹配可能出现的异常类型。  \n当try里的代码没有异常，catch里的代码不会被运行，当try里的代码出现异常，try里后续的代码都不会被执行，会直接调到catch里，在catch里处理完异常，会继续往下运行整个程序，而不会回到try。   \n当匹配到一个catch之后，异常就已经被处理完了，不会再去匹配另一个异常。  \n\n运行下面的代码  \n```java\npublic class ArrayIndex {\n\n    public static void f(){\n        int[] a = new int[10];\n        a[10] = 10;\n        System.out.println(\"hello\");\n    }\n    public static void main(String[] args) {\n        try{\n            f();\n        }catch(ArrayIndexOutOfBoundsException e){\n            System.out.println(\"error\");\n        }\n        System.out.println(\"main\");\n    }\n}\n```\n```java 输出\nerror\nmain\n```\n当给数组赋值出现异常后，f方法后面的代码都不会被执行，然后回到调用f方法的地方，try会捕捉到f方法的异常，然后传递给catch  \n\n当有异常被抛出时，可以遵循下面的图来判断该在哪个地方处理这个异常  \n<div><img src=/images/7-18.webp width=\"92%\" height=\"92%\"></div>\n\n```java 示例\npublic class ArrayIndex {\n\n    public static void f(){\n        int[] a = new int[10];\n        a[10] = 10;//抛出ArrayIndexOutOfBoundsException异常\n        System.out.println(\"hello\");//异常后面的代码不会被执行\n    }\n\n    public static void g(){\n        f();//f方法抛出异常，异常没有try捕捉，所处是函数，返回调用者\n    }\n\n    public static void h(){\n        int i = 10;\n        if(i < 100){\n            g();//所处不是函数，跳出一层\n        }//异常没有try捕捉，所处是函数，返回调用者\n    }\n\n    public static void k(){\n        try{\n            h();//有try捕捉异常\n        }catch(NullPointerException e){//没有对应catch匹配，退出到外层\n            System.out.println(\"k error\");\n        }//所处是函数\n        //返回调用者\n    }\n\n    public static void main(String[] args) {\n        try{\n            k();//有try捕捉异常\n        }catch(ArrayIndexOutOfBoundsException e){//有对应catch匹配\n            System.out.println(\"error\");//处理异常\n        }\n        System.out.println(\"main\");\n    }\n}\n```\n```java 输出\nerror\nmain\n```\n\n## Java 内置异常类\n\n| 异常  | 描述    |\n| -----    | ------ |\n| ArithmeticException  |当出现异常的运算条件时，抛出此异常。例如，一个整数\"除以零\"时，抛出此类的一个实例|\n|ArrayIndexOutOfBoundsException|用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引|\n|ArrayStoreException|试图将错误类型的对象存储到一个对象数组时抛出的异常|\n|ClassCastException|当试图将对象强制转换为不是实例的子类时，抛出该异常|\n|IllegalArgumentException|抛出的异常表明向方法传递了一个不合法或不正确的参数|\n|IllegalMonitorStateException|抛出的异常表明某一线程已经试图等待对象的监视器，或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程|\n|IllegalStateException|在非法或不适当的时间调用方法时产生的信号。换句话说，即 Java 环境或 Java 应用程序没有处于请求操作所要求的适当状态下|\n|IllegalThreadStateException|线程没有处于请求操作所要求的适当状态时抛出的异常|\n|IndexOutOfBoundsException|指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出|\n|NegativeArraySizeException|如果应用程序试图创建大小为负的数组，则抛出该异常|\n|NullPointerException|当应用程序试图在需要对象的地方使用 null 时，抛出该异常|\n|NumberFormatException\t|当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常|\n|SecurityException|由安全管理器抛出的异常，指示存在安全侵犯|\n|StringIndexOutOfBoundsException|此异常由 String 方法抛出，指示索引或者为负，或者超出字符串的大小|\n|UnsupportedOperationException|当不支持请求的操作时，抛出该异常|\n|下面是Java 定义在 java.lang 包中的检查性异常类：||\n|ClassNotFoundException|应用程序试图加载类时，找不到相应的类，抛出该异常|\n|CloneNotSupportedException|当调用 Object 类中的 clone 方法克隆对象，但该对象的类无法实现 Cloneable 接口时，抛出该异常|\n|IllegalAccessException|拒绝访问一个类的时候，抛出该异常|\n|InstantiationException|当试图使用 Class 类中的 newInstance 方法创建一个类的实例，而指定的类对象因为是一个接口或是一个抽象类而无法实例化时，抛出该异常|\n|InterruptedException|一个线程被另一个线程中断，抛出该异常|\n|NoSuchFieldException|请求的变量不存在|\n|NoSuchMethodException|\t请求的方法不存在|\n\n## 异常方法\n当catch匹配到了异常，实际上是拿到了一个异常类型的对象，我们可以让对象做事情  \n```java\npublic class a {\n    public static void main(String[] args) {\n        int[] a = new int[10];\n        try{\n            a[10] = 20;\n            System.out.println(\"hello\");\n        }catch(ArrayIndexOutOfBoundsException e){\n            System.out.println(\"error\");\n            System.out.println(e.getMessage());\n            System.out.println();\n            System.out.println(e);\n            System.out.println();\n            e.printStackTrace();\n        }\n    }\n}\n```\n```java 输出\nerror\nIndex 10 out of bounds for length 10\n\njava.lang.ArrayIndexOutOfBoundsException: Index 10 out of bounds for length 10\n\njava.lang.ArrayIndexOutOfBoundsException: Index 10 out of bounds for length 10\n\tat a.main(a.java:5)\n\n```\n\n| 异常方法  | 描述    |\n| -----    | ------ |\n|String getMessage()|返回关于发生的异常的详细信息。这个消息在Throwable 类的构造函数中初始化了|\n|Throwable getCause()|返回一个 Throwable 对象代表异常原因|\n|String toString()|返回此 Throwable 的简短描述|\n|void printStackTrace()|将此 Throwable 及其回溯打印到标准错误流|\n|StackTraceElement [] getStackTrace()|返回一个包含堆栈层次的数组。下标为0的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底|\n|Throwable fillInStackTrace()|用当前的调用栈层次填充Throwable 对象栈层次，添加到栈层次任何先前信息中|\n\n## throw再度抛出\n当一个异常已经被处理了，将不会再次被捕捉  \n```java\npublic class ArrayIndex {\n    public static void k(){\n        try{\n            int[] a = new int[10];\n            a[10] = 10;\n            System.out.println(\"hello\");\n        }catch(ArrayIndexOutOfBoundsException e){//k中已经处理了异常\n            System.out.println(\"k error\");\n        }\n    }\n\n    public static void main(String[] args) {\n        try{\n            k();\n        }catch(ArrayIndexOutOfBoundsException e){//不会再次处理\n            System.out.println(\"error\");\n        }\n        System.out.println(\"main\");\n    }\n}\n```\n```java 输出\nk error\nmain\n```\n但可以通过throw主动地再次抛出这个异常  \n```java\npublic class ArrayIndex {\n    public static void k(){\n        try{\n            int[] a = new int[10];\n            a[10] = 10;\n            System.out.println(\"hello\");\n        }catch(ArrayIndexOutOfBoundsException e){\n            System.out.println(\"k error\");\n            throw e;//捕捉到后在此抛出该异常\n        }\n    }\n    public static void main(String[] args) {\n        try{\n            k();\n        }catch(ArrayIndexOutOfBoundsException e){\n            System.out.println(\"error\");\n        }\n        System.out.println(\"main\");\n    }\n}\n```\n```java 输出\nk error\nerror\nmain\n```\n\n## 为什么要异常机制\n我们希望程序能够根据运行过程中可能出现的各种情况进行处理  \n早期，函数都有特定的返回值，通过函数内很多的if-else来判断返回什么，以返回值来做相应处理  \n\n函数内出现很多与功能无关的if-else，会导致函数可读性很差，而且不利于增加新的功能  \n异常机制将业务逻辑与异常处理在代码上分开  \n```java\ntry{\n    //业务逻辑都放在一起\n    open the file;\n    determine its size;\n    allocate that much memory;\n    read the file into memory;\n    close the file;\n    //如果上面的业务逻辑出了问题，就用下面的catch去处理对应的问题\n}catch(fileOpenFailed){\n    doSomething;\n}catch(sizeDeterminationFailed){\n    doSomething;\n}catch(memoryAllocationFailed ){\n    doSomething;\n}catch(readFailed ){\n    doSomething;\n}catch(fileCloseFailed ){\n    doSomething;\n}\n```\n异常机制最大的好处就是清晰地分开了正常的业务逻辑代码和遇到情况时的处理代码  \n\n## 异常的抛出和声明\n在Java中可以自定义异常。  \n1、所有异常都必须是 Throwable 的子类。  \n2、如果希望写一个检查性异常类，则需要继承 Exception 类。  \n3、如果你想写一个运行时异常类，那么需要继承 RuntimeException 类。  \nRuntimeException继承自Exception  \n\n```java 声明一个异常类型\nclass MyException extends Exception{\n}\n```\n```java 声明一个可能会抛出异常的方法\npublic void f() throws MyException{\n    throw new MyException();//抛出一个MyException异常\n}\n```\n所有调用这个方法的地方都必须套上try-catch，来处理可能发生的异常  \n```java\npublic static void main(String[] args) {\n    try{\n        f();\n    }catch(MyException e){//必须catch该方法会抛出的异常类型\n        System.out.println(\"error\");\n    }\n}\n```\n\n可以声明并不会真的抛出的异常,但调用该方法的地方必须处理全部可能抛出的异常  \n```java\npublic void f() throws MyException,YouException{\n    throw new MyException();//抛出一个MyException异常\n}\npublic static void main(String[] args) {\n    try{\n        f();\n    }catch(MyException e){//必须catch该方法会抛出的异常类型\n        System.out.println(\"MyError\");\n    }catch(YouException e){//必须catch该方法会抛出的异常类型\n        System.out.println(\"YouError\");\n    }\n}\n```\n\n任何继承了Throwable类的对象都可以被throw  \nException类继承了Throwable，我们通常让自定义的异常类从Exception类得到继承  \n\n```java Exception类的两种构造\n//我们在自定义异常类时也通常会有这两种构造\nthrow new Exception();  \nthrow new Exception(\"HELP\");//可以用这个字符串来表达一些东西  \n```\n\n## catch的匹配机制\n抛出子类的异常会被捕捉父类异常的catch给捉到  \n```java\n//声明两个异常类，YouException继承自MyException\nclass MyException extends Exception{}\nclass YouException extends MyException{}\n\npublic class Test{\n\n    public static void f() throws MyException, YouException {\n        throw new YouException();//抛出一个YouException异常\n    }\n\n    public static void main(String[] args) {\n        try{\n            throw new YouException();\n        }catch(MyException e){//MyException匹配到了它的子类YouException\n            System.out.println(\"YouException\");\n        }\n    }\n}\n```\n如果同时捕捉父类子类两个异常，子类catch要写在父类前面，否则会报错  \n```java\ntry{\n    throw new YouException();\n}catch(YouException e){\n    System.out.println(\"YouException\");\n}catch(MyException e){\n    System.out.println(\"YouException\");\n}\n```\n\n捕捉任何异常\n```java\ncatch(Exception e){\n}\n```\n\n### 运行时刻异常\n像ArrayIndexOutOfBoundsException这样java本身提供的异常是不需要声明的，如果需要去声明这些异常，那么每个方法都将带上一长串的声明    \n但是如果没有适当的机制来捕捉，就会最终导致程序终止  \n\n## 异常遇到继承\n当覆盖一个方法的时候，子类不能声明抛出比父类的版本更多的异常  \n```java\nclass MyException extends Exception{}\nclass YouException extends MyException{}\nclass NewException extends Exception{}\n\npublic class Test {\n    public static void f() throws MyException {}\n    public static void main(String[] args) {}\n}\nclass NewClass extends Test{\n    //NewClass'中的f()'与'a'中的'f()'冲突；重写的方法未抛出NewException'\n    public void f() throws NewException {}\n    //正确的\n    public void f() throws YouException {}\n    public void f() throws MyException {} \n    public void f() {} \n}\n```\n\n在子类的构造方法中，必须声明父类可能抛出的全部异常，可以抛出更多异常,可以是父类抛出异常的父类异常  \n```java\nclass MyException extends Exception{}\nclass YouException extends MyException{}\nclass NewException extends Exception{}\n\npublic class Test {\n    public a() throws YouException{}\n    public static void main(String[] args) {}\n}\n\nclass NewClass extends Test {\n    //允许\n    public NewClass() throws YouException{}\n    public NewClass() throws MyException{}\n    public NewClass() throws MyException,NewException{}\n    //不允许\n    public NewClass(){}\n    public NewClass() throws NewException{}\n}\n```\n\n***\n\n# Stream流\n任何程序都有输入输出，会向用户那读点东西，也会向用户那输出点东西  \n所以，任何一个编程语言都给程序员提供了输入输出的方式，让这个程序可以和外界打交道  \n\n对于java语言，以及之后的新语言，处理输入输出的手段叫做**流**  \n\n流是一个抽象、动态的概念，是一连串连续动态的数据集合。  \n流给数据源和程序之间提供了数据信息传输的通道，编程语言提供了多种流用于数据传输  \n\n## Hallo World\n```java\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        System.out.println(\"Hello World!\");\n    }\n}\n```\n这个程序就用到了输出流，把Hallo World输出给用户看  \n**System**是一个类，**out**是这个类的一个静态成员，**println**是这个成员能做的事情  \n实际上，**out**这个成员就是用于做输出的流  \n\n## 流的基础\n在java的基础类库中，所有的输出都基于**OutputStream**类，所有的输入都基于**InputStream**类，这两个类构成了输入和输出的基础  \n\n但这两个类是抽象的，具体使用时应该用它们的子类  \n在这里可以看到java系统类库中所有的包[Java®平台、标准版和Java开发工具包第18版API规范](https://docs.oracle.com/en/java/javase/18/docs/api/index.html)  \n在其中的java.base中有[java.io](https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/io/package-summary.html)，这里面有java输入输出所有相关的东西  \n在里面可以找到**InputStream**和**OutputStream**类，当然这里面还有很多的类，以及其它的东西  \n\n点击InputStream，可以看到这个类的描述，以及它所有的方法  \n<div><img src=/images/7-19.webp width=\"100%\" height=\"100%\"></div>\n\n**InputStream**把外界的输入当做**字节**的流来看待，**OutputStream**也同理，当我们使用这两个类，只能做字节层面上的读和写  \n\n尝试一下：  \n```java\nimport java.io.IOException;\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Hello World!\");\n        byte[] buffer = new byte[1024];//一个1k字节的butter\n        int len = 0;//让系统读取输入流，并将读取到的内容存储到buffer中，返回读取到的字节数\n        try {//所有io的操作都存在风险，所以要捕获异常\n            len = System.in.read(buffer);\n            String s = new String(buffer, 0, len);//将buffer中从0开始到len的这么多个字节构造一个字符串\n            System.out.println(\"读到了：\"+len+\"字节\");//输出读取到的字节数\n            System.out.println(s);//输出字符串\n            System.out.println(\"s的长度：\"+s.length());//输出字符串有多少个字符\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n```java 输出\nHello World!\n输入:123abc\n读到了：7字节\n123abc\n\ns的长度：7\n\n```\n123abc是6个字节，但后面还有个回车，所以读到7个字节，且输出s时，把回车也输出了  \n\n换个输入：\n```java 输出\nHello World!\n输入：123汉字abc\n读到了：13字节\n123汉字abc\n\ns的长度：9\n\n```\n在UTF-8编码中,一个中文字符等于三个字节，所以一共读到13个字节  \n\n## 文件流\n**System.in**和**System.in**是标准输入和标准输出的流  \n如果想要直接写文件，就需要使用到**文件流**：**FileInputStream**、**FileOutputStream**  \n\n实际工程中已经较少直接对文件进行读写（除了在造轮子）  \n更常用的是以在内存数据或通信数据上建立的流，如数据库的二进制数据读写或网络端口通信  \n具体的文件读写往往有更专业的类，比如配置文件和日志文件  \n\n尝试一下**FileOutputStream**：  \n```java\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class test {\n    public static void main(String[] args)  {\n        System.out.println(\"Hello World!\");\n        byte[] buf = new byte[10];//10个字节的数组\n        for (int i=0; i<buf.length; i++){\n            buf[i] = (byte)i;//让buf中的每个元素都是i，而且是byte类型\n        }\n        try {\n            FileOutputStream out = new FileOutputStream(\"a.dat\");//如果文件不存在，则创建，存在则覆盖\n            out.write(buf);//将buf中的数据写入文件\n            out.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n用**Hexdump**打开这个16进制文件  \n```\n  Offset: 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F \t\n00000000: 00 01 02 03 04 05 06 07 08 09                      ..........\n\n```\n1到9都已经被写入  \n\n## 流过滤器\n无论是System.in和out还是文件流，都只能处理单个字节，一个个字节地读，一个个字节地写  \n如果要把一个10进制地整数写入到一个文件中，就要同时读写4个字节，显然前面介绍的流无法做到  \n\n**流过滤器**可以在已存在的流的基础上，去增加一层层的过滤器，每一层的过滤器都可以做点事情，其中一些过滤器就可以做int、double这些基础类型数据的读和写  \n\n尝试一下：  \n```java\nimport java.io.BufferedOutputStream;\nimport java.io.DataOutputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class test {\n    public static void main(String[] args)  {\n        System.out.println(\"Hello World!\");\n        byte[] buf = new byte[10];//10个字节的数组\n        for (int i=0; i<buf.length; i++){\n            buf[i] = (byte)i;//让buf中的每个元素都是i，而且是byte类型\n        }\n        try {\n            DataOutputStream out = new DataOutputStream(\n                    new BufferedOutputStream(//缓冲输出流\n                            new FileOutputStream(\"a.dat\")));\n            //打开这个文件之后，在上面接了一个缓冲流，缓冲流外面还有一个流，最终得到的是一个DataOutputStream的对象\n            //我们可以往DataOutputStream这个流里面写入数据，数据会被缓冲到缓冲流里面，缓冲流里面的数据会被写入到文件里面\n            int i = 0xcafebabe;\n            out.writeInt(i);//写入一个int类型的数据,DataOutputStream流的writeInt方法可以写入一个int类型的数据\n            out.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n```\n```java\n  Offset: 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F \t\n00000000: CA FE BA BE                                        J~:>\n```\n0xcafebabe这个16进制数已经被写入  \n```java 输出\nHello World!\n-889275714\n```\n0xcafebabe这个16进制的数对应的10进制数是-889275714  \n\n每一层过滤器都可以起到一定的作用，在上面的程序中，BufferedOutputStream起到了缓冲垫作用，DataOutputStream起到了读写基本数据类型的作用  \n\n## 文本的输入和输出\n加上了DataOutputStream也只能以二进制处理基本数据类型，如何处理文本？  \n\n二进制数据采用InputStream/OutputStream  \n文本数据采用Reader/Writer  \n\n但Reader/Writer本身是处理Unicode编码的字符的，如果文件是Unicode编码，可以直接用Reader/Writer处理文件，但一般情况下，文件本身并不是Unicode编码，它可能是GBK，可能是UTF-8  \n在这种情况下，我们需要借助Stream，用字节形式打开文件，再在Stream流的基础上，用过滤器的方式去建立Reader/Writer ，来做文本的输入和输出，**StreamReader**可以将字节流转换为字符流，然后交给Reader/Writer，当然中间可以加上Buffered实现缓冲  \n\n尝试一下：  \n```java\nimport java.io.*;\n\npublic class test {\n    public static void main(String[] args)  {\n        System.out.println(\"Hello World!\");\n        byte[] buf = new byte[10];//10个字节的数组\n        for (int i=0; i<buf.length; i++){\n            buf[i] = (byte)i;//让buf中的每个元素都是i，而且是byte类型\n        }\n        try {\n            PrintWriter out = new PrintWriter(//创建一个输出流,PrintWriter可以通过连接BufferedWriter实现的缓冲功能\n                    new BufferedWriter(//创建一个缓冲流\n                            new OutputStreamWriter(//将字节流转换为字符流\n                                new FileOutputStream(\"a.txt\"))));//创建一个文件输出流\n            //我们做了一个文件流，但它只能处理字节\n            // 在此基础上再做一个桥梁：OutputStreamWriter\n            // 它构建起了Stream和Writer的桥梁，它的输入是OutputStream，输出是Writer\n            int i = 123456;\n            out.println(i);//在PrintWriter的基础上，我们可以用println方法来输出数据\n            out.close();\n            //和上面输出一样，如果要读取一个文件，我们需要做一个桥梁：InputStreamReader\n            //它构建起了Stream和Reader的桥梁，它的输入是InputStream，输出是Reader\n            BufferedReader in = new BufferedReader(// BufferedReader类从字符输入流中读取文本并缓冲字符\n                    new InputStreamReader(//将字节流转换为字符流\n                        new FileInputStream(\"src/test.java\")));//创建一个文件输入流，打开这个程序的源码文件\n            //readLine()方法从字符输入流中读取一行，并返回该行。\n            String line;\n            while ((line = in.readLine()) != null){//当读取到的行不为空时，执行循环，就可以读取整个文件\n                System.out.println(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n运行：在a.tet文件中有123456字符,控制台也将这整个源码输出了出来  \n\n除了BufferedReader，还有LineNumberReader，里面的getLineNumber()可以读取指定的行  \n\n**FileReader**是InputStreamReader类的子类，所有方法都从父类中继承而来，它可以直接读取一个二进制文件，建立起一个流，然后形成一个Reader    \nFileReader(File file)在给定从中读取数据的Fe的情况下创建一个新FileReader  \nFileReader(String fileName)在给定从中读取数据的文件名的情况下创建一个新FileReader  \nFileReader不能指定编码转换方式  \n\n## 汉字编码问题\nFileOutputStream(\"a.txt\")可以以二进制形式打开一个文件  \nOutputStreamWriter(FileOutputStream(\"a.txt\"))将字节流转换为字符流,如果不指定编码，那么它优先使用程序源码文件的编码去转换这个字节流为字符流，这就很容易导致汉字乱码  \n\n我们可以指定编码进行转换OutputStreamWriter(FileOutputStream(\"a.txt\"),\"utf8\")  \n用utf8去将这个字节流转换成字符流 \n\n当然还有其它方法，这里不展开讲\n\n## 格式化输入输出\n格式化输出：使用printf(\"格式\", );用法和C语言的基本一样，这里不展开讲，博主同样有篇C语言学习笔记  \n\n格式化输入：如果想从一个文本中读取出一些数字，可以在流上构建一个Scanner，然后用next系列的方法去读取数字、单词等等  \n\n## Stream/Reader/Scanner的选择\n<div><img src=/images/7-20.webp width=\"92%\" height=\"92%\"></div>\n\n## 流的应用\n现在已经很少有程序需要用流的方式去打开一个文件，裸地去进行文件读和写的操作，更多地是从某个地方得到了一个流  \n\n### 服务器通信\n下面这个程序将从本地服务器得到一个流，并向这个流写入东西  \n```java\nimport java.io.*;\nimport java.net.InetAddress;\nimport java.net.Socket;\n\npublic class socket {\n    public static void main(String[] args) {\n        try {\n            Socket socket = new Socket(InetAddress.getByName(\"localhost\"), 12345);//创建一个Socket对象，指定服务器地址和端口号\n            PrintWriter out = new PrintWriter(\n                    new BufferedWriter(\n                            new OutputStreamWriter(\n                                    //getOutputStream()方法获取Socket对象的输出流，并构造一个BufferedWriter对象\n                                    socket.getOutputStream())));//创建一个PrintWriter对象，用于向服务器发送信息\n            out.println(\"Hello, world!\");//向服务器发送一行文本\n            out.close();//关闭PrintWriter对象\n            socket.close();//关闭Socket对象\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n当然，直接运行这个程序一定报错，因为本地没有任何服务器程序在12345端口上听着，连接建立不起来  \n\n使用netcat可以实现监听  \n从[netcat](https://eternallybored.org/misc/netcat/)下载netcat1.12  \n解压后把nc.exe移动到C:\\Windows\\System32目录，压缩包内其它东西用不上  \n然后打开cmd，运行nc -l -p -12345\n\n现在再运行程序，cmd窗口就会输出Hello, world!  \n\n还可以接收服务端的数据  \n```java\nimport java.io.*;\nimport java.net.InetAddress;\nimport java.net.Socket;\n\npublic class socket {\n    public static void main(String[] args) {\n        try {\n            Socket socket = new Socket(InetAddress.getByName(\"localhost\"), 12345);//创建一个Socket对象，指定服务器地址和端口号\n            PrintWriter out = new PrintWriter(\n                    new BufferedWriter(\n                            new OutputStreamWriter(\n                                    //getOutputStream()方法获取Socket对象的输出流，并构造一个BufferedWriter对象\n                                    socket.getOutputStream())));//创建一个PrintWriter对象，用于向服务器发送信息\n            out.println(\"Hello, world!\");//向服务器发送一行文本\n            out.flush();//刷新缓冲区，将缓冲区中的数据立即发送出去\n            BufferedReader in = new BufferedReader(\n                    new InputStreamReader(\n                            //getInputStream()方法获取Socket对象的输入流，并构造一个BufferedReader对象\n                            socket.getInputStream()));//创建一个BufferedReader对象，用于接收服务器端的信息\n            String line = in.readLine();//读取服务器端的一行文本\n            System.out.println(line);//输出读取的文本\n            out.close();//关闭PrintWriter对象\n            socket.close();//关闭Socket对象\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n在cmd窗口输入任意文本，idea的控制台也会输出这个文本  \n\n### 对象串行化\n写入和读取一个对象，使用ObjectOutputStream和ObjectInputStream，被读写的类要实现Serializable接口  \n```java\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.Serializable;\nimport java.io.*;\n\nclass Student implements Serializable {//可以串行化的类\n    private String name;\n    private int age;\n    private int grade;\n\n    public Student(String name, int age, int grade) {\n        this.name = name;\n        this.age = age;\n        this.grade = grade;\n    }\n\n    public String toString() {\n        return \"Student: \" + name + \" \" + age+ \" \" + grade;\n    }\n}\n\npublic class chh {\n    public static void main(String[] args) {\n        try {\n            Student s1 = new Student(\"zhangsan\", 20, 1);\n            ObjectOutputStream out = new ObjectOutputStream(\n                    new FileOutputStream(\"obj.dat\"));\n            out.writeObject(s1);\n            out.close();\n            ObjectInputStream in = new ObjectInputStream(\n                    new FileInputStream(\"obj.dat\"));\n            Student s2 = (Student) in.readObject();\n            System.out.println(s2);\n        } catch (IOException | ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n```\n```java obj.bat\n  Offset: 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F \t\n00000000: AC ED 00 05 73 72 00 07 53 74 75 64 65 6E 74 98    ,m..sr..Student.\n00000010: 61 28 66 C5 BE 55 BC 02 00 03 49 00 03 61 67 65    a(fE>U<...I..age\n00000020: 49 00 05 67 72 61 64 65 4C 00 04 6E 61 6D 65 74    I..gradeL..namet\n00000030: 00 12 4C 6A 61 76 61 2F 6C 61 6E 67 2F 53 74 72    ..Ljava/lang/Str\n00000040: 69 6E 67 3B 78 70 00 00 00 14 00 00 00 01 74 00    ing;xp........t.\n00000050: 08 7A 68 61 6E 67 73 61 6E                         .zhangsan\n\n```\n```java 输出\nStudent: zhangsan 20 1\n```\n\n***\n\n>完结撒花！\n>javase的学习暂且告一段落，但学习的步伐永不停歇\n>翁恺老师讲的课循序渐进，简洁明了，好评，但课程上只学到流，刚步入javase的高级部分\n>后面还有一个重要部分：线程\n>过段时间实操一个java的管理系统（万物起源管理系统），暂且咕咕咕吧\n","tags":["JAVA","JavaSE"],"categories":["学习笔记"]},{"title":"给Butterfly加上顶部加载条","url":"/article/13d6481a.html","content":"\n>效果已在本站实装，切换页面顶部有加载进度条\n>参考文章[为Hexo博客添加顶部加载条](https://cloud.tencent.com/developer/article/1960734)\n\n# 旧版顶部长条\n\n## 引入css\n```css\n.pace {\n  -webkit-pointer-events: none;\n  pointer-events: none;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  user-select: none;\n}\n\n.pace-inactive {\n  display: none;\n}\n\n.pace .pace-progress {\n  background: #e90f92;\n  position: fixed;\n  z-index: 2000;\n  top: 0;\n  right: 100%;\n  width: 100%;\n  height: 2px;\n}\n\n.pace .pace-progress-inner {\n  display: block;\n  position: absolute;\n  right: 0px;\n  width: 100px;\n  height: 100%;\n  box-shadow: 0 0 10px #e90f92, 0 0 5px #e90f92;\n  opacity: 1.0;\n  -webkit-transform: rotate(3deg) translate(0px, -4px);\n  -moz-transform: rotate(3deg) translate(0px, -4px);\n  -ms-transform: rotate(3deg) translate(0px, -4px);\n  -o-transform: rotate(3deg) translate(0px, -4px);\n  transform: rotate(3deg) translate(0px, -4px);\n}\n\n.pace .pace-activity {\n  display: block;\n  position: fixed;\n  z-index: 2000;\n  top: 15px;\n  right: 15px;\n  width: 14px;\n  height: 14px;\n  border: solid 2px transparent;\n  border-top-color: #e90f92;\n  border-left-color: #e90f92;\n  border-radius: 10px;\n  -webkit-animation: pace-spinner 400ms linear infinite;\n  -moz-animation: pace-spinner 400ms linear infinite;\n  -ms-animation: pace-spinner 400ms linear infinite;\n  -o-animation: pace-spinner 400ms linear infinite;\n  animation: pace-spinner 400ms linear infinite;\n}\n\n@-webkit-keyframes pace-spinner {\n  0% { -webkit-transform: rotate(0deg); transform: rotate(0deg); }\n  100% { -webkit-transform: rotate(360deg); transform: rotate(360deg); }\n}\n@-moz-keyframes pace-spinner {\n  0% { -moz-transform: rotate(0deg); transform: rotate(0deg); }\n  100% { -moz-transform: rotate(360deg); transform: rotate(360deg); }\n}\n@-o-keyframes pace-spinner {\n  0% { -o-transform: rotate(0deg); transform: rotate(0deg); }\n  100% { -o-transform: rotate(360deg); transform: rotate(360deg); }\n}\n@-ms-keyframes pace-spinner {\n  0% { -ms-transform: rotate(0deg); transform: rotate(0deg); }\n  100% { -ms-transform: rotate(360deg); transform: rotate(360deg); }\n}\n@keyframes pace-spinner {\n  0% { transform: rotate(0deg); transform: rotate(0deg); }\n  100% { transform: rotate(360deg); transform: rotate(360deg); }\n}\n/* 在下面修改进度条外观 */\n.pace .pace-progress {\n  background: #1ef4fbec; /*进度条颜色*/\n  height: 3px;/* 进度条厚度 */\n}\n.pace .pace-progress-inner {\n  box-shadow: 0 0 10px #1ef4fbce, 0 0 5px #1ecffbd0; /*阴影颜色*/\n}\n.pace .pace-activity {\n  border-top-color: #1edafbe5;\t/*上边框颜色*/\n  border-left-color: #1ef4fbec;\t/*左边框颜色*/\n}\n```\n\n## 引入js\n\n```js\n<script src=\"//cdn.bootcss.com/pace/1.0.2/pace.min.js\"></script>\n```\n\n**然后三连即可**\n\n# 新版胶囊\n<img src=/images/10-1.webp width=\"50%\" height=\"50%\">\n\n\n\n\n\n\n\n","tags":["Butterfly","Hexo"],"categories":["Hexo"]},{"title":"基于UptimeRobot的监控面板","url":"/article/8f1fedc5.html","content":"\n>演示：[轻笑的网站监控面板](https://status.chuckle.top/)\n\n# 注册UptimeRobot\n\n填写邮箱以完成注册  \n>[跳转至注册](https://uptimerobot.com/signUp?ref=website-header)\n\n\n# 新建监视器\n点击左上角Add New Monitor  \n<div><img src=/images/9-1.webp width=\"70%\" height=\"70%\"></div>\n\n在弹出窗口填写需要需要监控的站点的相关信息  \n\n<div><img src=/images/9-2.webp width=\"70%\" height=\"70%\"></div>\n\n点击Create Monitor完成创建   \n\n\n# 创建API密钥\n\n点击My Settings\n<div><img src=/images/9-3.webp width=\"70%\" height=\"70%\"></div>\n为监视器创建一个api密钥（也可选择第三个，为所有监视器创建一个密钥）  \n<div><img src=/images/9-4.webp width=\"70%\" height=\"70%\"></div>\n\n# fork监控面板仓库\n选择其中一个fork  \n[yb/uptime-status](https://github.com/yb/uptime-status)  \n[Ice-Hazymoon/status](https://github.com/Ice-Hazymoon/status)  \n\n# 修改config.js\n\n进入刚fork的仓库，打开/public/config.js  \n添加监视器的api密钥  \n>需要监控的站点较多，也可为所有监控器创建一个api密钥填入\n\n```\n ApiKeys: [\n    '在这里粘贴api密钥',\n  ],\n```\n>还可以选择在ApiDomain修改自定义反代域名，详见https://github.com/yb/uptime-status/\n\n# vercel部署\n\n新建一个项目  \nimport监控面板仓库  \n等待几分钟创建完成，点击vist，一个监控面板就完成了  \n<div><img src=/images/9-5.webp width=\"70%\" height=\"70%\"></div>\n\n<div><img src=/images/9-6.webp width=\"70%\" height=\"70%\"></div>\n\n","tags":["教程"],"categories":["教程"]},{"title":"JAVA/面向对象学习笔记(2)","url":"/article/9f2dc6c7.html","content":"\n>所看教程（视频）：《浙江大学-翁恺-Java-面向对象程序设计》\n>作为我自己的复习笔记，也可以当做该视频的同步笔记\n>上接[JAVA/面向对象学习笔记(1)](https://www.chuckle.top/article/bfb663c6.html)\n\n# 城堡游戏（可扩展性）\n整体思路：用Room先初始化5个房间，Room类中有房间名称、四个方向所连接的房间，currentRoom = outside;设置出生点  \n进入goRoom方法，匹配用户输入的方向，让nextroom指向下一个房间，然后让currentRoom = outside;并输出房间信息。  \n大致以此循环  \n \n```java Room.java\npackage castle;\n\npublic class Room {\n    //房间名称\n    public String description;\n    //房间四个方向连接的房间\n    public Room northExit;\n    public Room southExit;\n    public Room eastExit;\n    public Room westExit;\n\n\n    public Room(String description)//初始化房间名\n    {\n        this.description = description;\n    }\n\n    public void setExits(Room north, Room east, Room south, Room west)//设置房间的四个方向的连接\n    {\n        if (north != null)\n            northExit = north;\n        if (east != null)\n            eastExit = east;\n        if (south != null)\n            southExit = south;\n        if (west != null)\n            westExit = west;\n    }\n\n    @Override\n    public String toString() {\n        return description;//输出房间名\n    }\n\n}\n```\n```java Game.java\npackage castle;\n\nimport java.util.*;\n\npublic class Game {\n    private Room currentRoom;//创建一个Room对象，用于保存当前房间\n\n    public Game()//构造函数\n    {\n        creatRooms();//创建房间\n    }\n\n    private void creatRooms()//创建一个房间\n    {\n        Room outside, lobby,pub,study,bedroom;//创建5种房间\n\n        // 制造5种房间\n        outside = new Room(\"城堡外\");\n        lobby = new Room(\"大堂\");\n        pub = new Room(\"小酒吧\");\n        study = new Room(\"书房\");\n        bedroom = new Room(\"卧室\");\n\n        // 初始化房间的出口\n        outside.setExits(null,lobby,study,pub);\n        lobby.setExits(null,null,null,outside);\n        pub.setExits(null,outside,null,null);\n        study.setExits(outside,bedroom,null,null);\n        bedroom.setExits(null,null,null,study);\n\n\n        currentRoom = outside; //从城堡门外开始\n    }\n\n\n    private void printWelcome()//输出欢迎信息\n    {\n        System.out.println();\n        System.out.println(\"欢迎来到城堡!\");\n        System.out.println(\"这是一个超级无聊的游戏。\");\n        System.out.println(\"如果需要帮助，请输入'help'\");\n        System.out.println();\n        System.out.println(\"现在你在:\" + currentRoom);\n        System.out.println(\"出口有：\");\n        //输出当前房间的出口\n        if(currentRoom.northExit !=null)\n            System.out.print(\"north \");\n        if(currentRoom.eastExit !=null)\n            System.out.print(\"east \");\n        if(currentRoom.southExit !=null)\n            System.out.print(\"south \");\n        if(currentRoom.westExit !=null)\n            System.out.print(\"west \");\n        System.out.println();\n    }\n\n    //  以下为用户命令\n\n    private void printHelp()//帮助菜单\n    {\n        System.out.println(\"迷路了吗？你可以做的命令有：go bye help\");\n        System.out.println(\"如：\\tgo east\");\n    }\n\n    private void goRoom(String direction)\n    {\n        Room nextRoom = null;//创建一个Room对象，用于保存下一个房间\n        // 在当前房间的出口中查找与用户输入的方向相同的房间\n        if(direction.equals(\"north\")){\n            nextRoom = currentRoom.northExit;\n        }\n        if(direction.equals(\"east\")){\n            nextRoom = currentRoom.eastExit;\n        }\n        if(direction.equals(\"south\")){\n            nextRoom = currentRoom.southExit;\n        }\n        if(direction.equals(\"west\")){\n            nextRoom = currentRoom.westExit;\n        }\n        // 如果找到了下一个房间，则进入下一个房间\n        if(nextRoom == null){\n            System.out.println(\"那里没有门！\");\n        }\n        else{\n            currentRoom = nextRoom;//让当前房间等于下一个房间\n            // 输出当前房间的描述\n            System.out.println(\"你在\"+ currentRoom);\n            System.out.println(\"出口有：\");\n            if(currentRoom.northExit != null)\n                System.out.println(\"north\");\n            if(currentRoom.eastExit != null)\n                System.out.println(\"east\");\n            if(currentRoom.southExit != null)\n                System.out.println(\"south\");\n            if(currentRoom.westExit != null)\n                System.out.println(\"west\");\n            System.out.println();\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        //通过new Scanner(System.in)创建一个Scanner，控制台会一直等待输入，直到敲回车键结束，把所输入的内容传给Scanner，作为扫描对象。\n        Game game = new Game();\n        game.printWelcome();//输出欢迎信息\n\n        while (true)//进入游戏主体，游戏结束时退出循环\n        {\n            String line = in.nextLine();//控制台输入一行\n            String[] words = line.split(\" \");//以空格为分隔符，把用户输入的字符串分割成字符串数组\n            //判断是go还是help\n            if ( words[0].equals(\"help\")){\n                game.printHelp();//输出帮助信息\n            }else if ( words[0].equals(\"go\")){\n                game.goRoom(words[1]);//将用户输入的方向传给goRoom方法\n            }else if ( words[0].equals(\"bye\")){\n                break;//如果用户数据为bye，则退出游戏\n            }\n        }\n        System.out.println(\"感谢您的光临。再见！\");\n        in.close();//关闭Scanner\n    }\n}\n```\n```java 输出\n欢迎来到城堡!\n这是一个超级无聊的游戏。\n如果需要帮助，请输入'help'\n\n你在城堡外\n出口有：\neast\nsouth\nwest\n\ngo south\n你在书房\n出口有：\nnorth\neast\n\ngo east\n你在卧室\n出口有：\nwest\n\nhelp\n迷路了吗？你可以做的命令有：go bye help\n如：\tgo east\nbye\n感谢您的光临。再见！\n```\n\n## 消除代码复制\n在printWelcome和goRoom方法中都有一段相同的输出出口方向的代码  \n将这段代码提取出来，做成一个方法，在需要输出房间信息的地方调用即可  \n```java\npublic void showPrompt()\n{\n    // 输出当前房间的描述\n    System.out.println(\"你在\"+ currentRoom);\n    System.out.println(\"出口有：\");\n    if(currentRoom.northExit != null)\n        System.out.println(\"north\");\n    if(currentRoom.eastExit != null)\n        System.out.println(\"east\");\n    if(currentRoom.southExit != null)\n        System.out.println(\"south\");\n    if(currentRoom.westExit != null)\n        System.out.println(\"west\");\n    System.out.println();\n}\n\n```\n\n## 封装\n这个程序没有bug，能正常运行，但不见得是一个好的代码  \n评价一个代码质量的好坏是多元的，尤其是这个代码是否能适应将来的需要  \n\n**可扩展性**：代码是否易于将来增加新的东西\n\n我们想在这个游戏里给每个房间增加两个方向down和up  \n我们需要改的地方很多  \nRoom.java里需要增加两个房间对象public Room downExit;和public Room upExit; setExits方法需要增加两个参数并进行判断  \nGame.java里很多方法也要增加if判断，还要改每个房间的初始化  \n\n总之，想增加一个方向，代码几乎每个地方都要改变  \n\n要想增加可扩展性，首先要降低类和类之间的耦合  \n\n### 用封装来降低耦合\nRoom类和Game类都有大量的代码和出口相关  \n尤其是Game类中大量使用了Room类的成员变量  \n类和类之间的关系称作**耦合**  \n耦合**越低越好**，保持距离是形成良好代码的关键  \n\n我们可以让Room自己告诉Game有哪些出口，出口连接的房间  \n```java Room.java\npackage castle;\n\npublic class Room {\n    //房间名称\n    private String description;\n    //public String description;\n    //房间四个方向连接的房间\n    private Room northExit;\n    private Room southExit;\n    private Room eastExit;\n    private Room westExit;\n    /*public Room northExit;\n    public Room southExit;\n    public Room eastExit;\n    public Room westExit;*/\n\n\n    public Room(String description)//初始化房间名\n    {\n        this.description = description;\n    }\n\n    public void setExits(Room north, Room east, Room south, Room west)//设置房间的四个方向的连接\n    {\n        if (north != null)\n            northExit = north;\n        if (east != null)\n            eastExit = east;\n        if (south != null)\n            southExit = south;\n        if (west != null)\n            westExit = west;\n    }\n\n    @Override\n    public String toString() {\n        return description;//输出房间名\n    }\n\n    public String getExitDesc() {\n        //返回一个字符串，来表达房间的出口\n        /*String returnString = \"Exits:\";\n        if (northExit != null)\n            returnString += \"north \";\n        if (eastExit != null)\n            returnString += \"east \";\n        if (southExit != null)\n            returnString += \"south \";\n        if (westExit != null)\n            returnString += \"west \";\n        return returnString;*/\n        //一般我们不使用String去做拼接，因为每次加都会产生一个新的String类型的对象，系统开销会很大，而是使用StringBuilder\n        StringBuilder builder = new StringBuilder(\"出口有：\");\n        if (northExit != null)\n            builder.append(\"north \");\n        if (eastExit != null)\n            builder.append(\"east \");\n        if (southExit != null)\n            builder.append(\"south \");\n        if (westExit != null)\n            builder.append(\"west \");\n        return builder.toString();\n    }\n\n    public Room getExit(String direction) {\n        //返回指定方向的连接房间\n        if (direction.equals(\"north\"))\n            return northExit;\n        if (direction.equals(\"east\"))\n            return eastExit;\n        if (direction.equals(\"south\"))\n            return southExit;\n        if (direction.equals(\"west\"))\n            return westExit;\n        return null;\n    }\n}\n```\n```java Game.java\npackage castle;\n\nimport java.util.*;\n\npublic class Game {\n    private Room currentRoom;//创建一个Room对象，用于保存当前房间\n\n    public Game()//构造函数\n    {\n        creatRooms();//创建房间\n    }\n\n    private void creatRooms()//创建一个房间\n    {\n        Room outside, lobby,pub,study,bedroom;//创建5种房间\n\n        // 制造5种房间\n        outside = new Room(\"城堡外\");\n        lobby = new Room(\"大堂\");\n        pub = new Room(\"小酒吧\");\n        study = new Room(\"书房\");\n        bedroom = new Room(\"卧室\");\n\n        // 初始化房间的出口\n        outside.setExits(null,lobby,study,pub);\n        lobby.setExits(null,null,null,outside);\n        pub.setExits(null,outside,null,null);\n        study.setExits(outside,bedroom,null,null);\n        bedroom.setExits(null,null,null,study);\n\n\n        currentRoom = outside; //从城堡门外开始\n    }\n\n\n    private void printWelcome()//输出欢迎信息\n    {\n        System.out.println();\n        System.out.println(\"欢迎来到城堡!\");\n        System.out.println(\"这是一个超级无聊的游戏。\");\n        System.out.println(\"如果需要帮助，请输入'help'\");\n        System.out.println();\n        showPrompt();\n        /*System.out.println(\"现在你在:\" + currentRoom);\n        System.out.println(\"出口有：\");\n        //输出当前房间的出口\n        if(currentRoom.northExit !=null)\n            System.out.print(\"north \");\n        if(currentRoom.eastExit !=null)\n            System.out.print(\"east \");\n        if(currentRoom.southExit !=null)\n            System.out.print(\"south \");\n        if(currentRoom.westExit !=null)\n            System.out.print(\"west \");\n        System.out.println();*/\n    }\n\n    //  以下为用户命令\n\n    private void printHelp()//帮助菜单\n    {\n        System.out.println(\"迷路了吗？你可以做的命令有：go bye help\");\n        System.out.println(\"如：\\tgo east\");\n    }\n\n    private void goRoom(String direction)\n    {\n        Room nextRoom = currentRoom.getExit(direction);//创建一个Room对象，用于保存下一个房间\n        // 在当前房间的出口中查找与用户输入的方向相同的房间\n        /*if(direction.equals(\"north\")){\n            nextRoom = currentRoom.northExit;\n        }\n        if(direction.equals(\"east\")){\n            nextRoom = currentRoom.eastExit;\n        }\n        if(direction.equals(\"south\")){\n            nextRoom = currentRoom.southExit;\n        }\n        if(direction.equals(\"west\")){\n            nextRoom = currentRoom.westExit;\n        }*/\n        // 如果找到了下一个房间，则进入下一个房间\n        if(nextRoom == null){\n            System.out.println(\"那里没有门！\");\n        }\n        else{\n            currentRoom = nextRoom;//让当前房间等于下一个房间\n            // 输出当前房间的描述\n            showPrompt();\n            /*System.out.println(\"你在\"+ currentRoom);\n            System.out.println(\"出口有：\");\n            if(currentRoom.northExit != null)\n                System.out.println(\"north\");\n            if(currentRoom.eastExit != null)\n                System.out.println(\"east\");\n            if(currentRoom.southExit != null)\n                System.out.println(\"south\");\n            if(currentRoom.westExit != null)\n                System.out.println(\"west\");\n            System.out.println();*/\n        }\n    }\n\n    public void showPrompt()\n    {\n        // 输出当前房间的描述\n        System.out.println(\"你在\"+ currentRoom);\n        //调用房间的getExitString()方法，输出当前房间的出口\n        System.out.println(currentRoom.getExitDesc());\n        /*System.out.println(\"出口有：\");\n        if(currentRoom.northExit != null)\n            System.out.println(\"north\");\n        if(currentRoom.eastExit != null)\n            System.out.println(\"east\");\n        if(currentRoom.southExit != null)\n            System.out.println(\"south\");\n        if(currentRoom.westExit != null)\n            System.out.println(\"west\");\n        System.out.println();*/\n    }\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        //通过new Scanner(System.in)创建一个Scanner，控制台会一直等待输入，直到敲回车键结束，把所输入的内容传给Scanner，作为扫描对象。\n        Game game = new Game();\n        game.printWelcome();//输出欢迎信息\n\n        while (true)//进入游戏主体，游戏结束时退出循环\n        {\n            String line = in.nextLine();//控制台输入一行\n            String[] words = line.split(\" \");//以空格为分隔符，把用户输入的字符串分割成字符串数组\n            //判断是go还是help\n            if ( words[0].equals(\"help\")){\n                game.printHelp();//输出帮助信息\n            }else if ( words[0].equals(\"go\")){\n                game.goRoom(words[1]);//将用户输入的方向传给goRoom方法\n            }else if ( words[0].equals(\"bye\")){\n                break;//如果用户数据为bye，则退出游戏\n            }\n        }\n        System.out.println(\"感谢您的光临。再见！\");\n        in.close();//关闭Scanner\n    }\n}\n```\n\n### 用接口来实现聚合\n原本Room有什么出口，连接着什么房间，Game是能直接获取使用的  \n现在我们在Room中实现了两个接口getExitDesc和getExit,把方向的细节彻底隐藏在Room类内部  \n今后方向如何实现就和外部无关了  \n\n### 用容器来实现灵活性\n在Room当中，有四个Room对象，用于保存这个房间连接着的四个房间（null，或者房间名）  \n这种一一对应的关系，可以使用HashMap去实现  \n```java Room.java\npackage castle;\n\nimport java.util.HashMap;\n\npublic class Room {\n    //描述\n    private String description;\n    //用HashMap来保存这个房间连接着的四个房间\n    private HashMap<String, Room> exits = new HashMap<String, Room>();\n    /*private Room northExit;\n    private Room southExit;\n    private Room eastExit;\n    private Room westExit;*/\n\n    public Room(String description)//初始化房间名\n    {\n        this.description = description;\n    }\n\n    public void setExits(String direction, Room room) {\n        exits.put(direction, room);//将出口方向和连接的房间放进容器中\n    }\n\n    /*public void setExits(Room north, Room east, Room south, Room west)//设置房间的四个方向的连接\n    {\n        if (north != null)\n            northExit = north;\n        if (east != null)\n            eastExit = east;\n        if (south != null)\n            southExit = south;\n        if (west != null)\n            westExit = west;\n    }*/\n\n    @Override\n    public String toString() {\n        return description;//输出房间名\n    }\n\n    public String getExitDesc() {\n        //返回一个字符串，来表达房间的出口\n        //一般我们不使用String去做拼接，因为每次加都会产生一个新的String类型的对象，系统开销会很大，而是使用StringBuilder\n        StringBuilder builder = new StringBuilder(\"出口有：\");\n        for (String direction : exits.keySet()) {\n            builder.append(direction);\n            builder.append(\" \");\n        }\n        /*if (northExit != null)\n            builder.append(\"north \");\n        if (eastExit != null)\n            builder.append(\"east \");\n        if (southExit != null)\n            builder.append(\"south \");\n        if (westExit != null)\n            builder.append(\"west \");*/\n        return builder.toString();\n    }\n\n    public Room getExit(String direction) {\n        //返回指定方向的连接房间\n        return exits.get(direction);//直接从HashMap中获取房间，如果没有容器会自动返回null\n        /*if (direction.equals(\"north\"))\n            return northExit;\n        if (direction.equals(\"east\"))\n            return eastExit;\n        if (direction.equals(\"south\"))\n            return southExit;\n        if (direction.equals(\"west\"))\n            return westExit;\n        return null;*/\n    }\n}\n```\n```java Game.java\npackage castle;\n\nimport java.util.*;\n\npublic class Game {\n    private Room currentRoom;//创建一个Room对象，用于保存当前房间\n\n    public Game()//构造函数\n    {\n        creatRooms();//创建房间\n    }\n\n    private void creatRooms()//创建一个房间\n    {\n        Room outside, lobby,pub,study,bedroom;//创建5种房间\n\n        // 制造5种房间\n        outside = new Room(\"城堡外\");\n        lobby = new Room(\"大堂\");\n        pub = new Room(\"小酒吧\");\n        study = new Room(\"书房\");\n        bedroom = new Room(\"卧室\");\n\n        // 初始化房间的出口\n        outside.setExits(\"east\", lobby);\n        outside.setExits(\"south\", study);\n        outside.setExits(\"west\", pub);\n        lobby.setExits(\"west\", outside);\n        pub.setExits(\"east\", outside);\n        study.setExits(\"north\", outside);\n        study.setExits(\"east\", bedroom);\n        bedroom.setExits(\"west\", study);\n        //现在当我们想增加出口方向，很简单\n        lobby.setExits(\"up\", pub);\n        pub.setExits(\"down\", lobby);\n\n        /*outside.setExits(null,lobby,study,pub);\n        lobby.setExits(null,null,null,outside);\n        pub.setExits(null,outside,null,null);\n        study.setExits(outside,bedroom,null,null);\n        bedroom.setExits(null,null,null,study);*/\n\n        currentRoom = outside; //从城堡门外开始\n    }\n\n\n    private void printWelcome()//输出欢迎信息\n    {\n        System.out.println();\n        System.out.println(\"欢迎来到城堡!\");\n        System.out.println(\"这是一个超级无聊的游戏。\");\n        System.out.println(\"如果需要帮助，请输入'help'\");\n        System.out.println();\n        showPrompt();\n    }\n\n    //  以下为用户命令\n\n    private void printHelp()//帮助菜单\n    {\n        System.out.println(\"迷路了吗？你可以做的命令有：go bye help\");\n        System.out.println(\"如：\\tgo east\");\n    }\n\n    private void goRoom(String direction)\n    {\n        Room nextRoom = currentRoom.getExit(direction);//创建一个Room对象，用于保存下一个房间\n        // 如果找到了下一个房间，则进入下一个房间\n        if(nextRoom == null){\n            System.out.println(\"那里没有门！\");\n        }\n        else{\n            currentRoom = nextRoom;//让当前房间等于下一个房间\n            // 输出当前房间的描述\n            showPrompt();\n        }\n    }\n\n    public void showPrompt()\n    {\n        // 输出当前房间的描述\n        System.out.println(\"你在\"+ currentRoom);\n        //调用房间的getExitString()方法，输出当前房间的出口\n        System.out.println(currentRoom.getExitDesc());\n    }\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        //通过new Scanner(System.in)创建一个Scanner，控制台会一直等待输入，直到敲回车键结束，把所输入的内容传给Scanner，作为扫描对象。\n        Game game = new Game();\n        game.printWelcome();//输出欢迎信息\n\n        while (true)//进入游戏主体，游戏结束时退出循环\n        {\n            String line = in.nextLine();//控制台输入一行\n            String[] words = line.split(\" \");//以空格为分隔符，把用户输入的字符串分割成字符串数组\n            //判断是go还是help\n            if ( words[0].equals(\"help\")){\n                game.printHelp();//输出帮助信息\n            }else if ( words[0].equals(\"go\")){\n                game.goRoom(words[1]);//将用户输入的方向传给goRoom方法\n            }else if ( words[0].equals(\"bye\")){\n                break;//如果用户数据为bye，则退出游戏\n            }\n        }\n        System.out.println(\"感谢您的光临。再见！\");\n        in.close();//关闭Scanner\n    }\n}\n```\n//现在当我们想增加出口方向，很简单  \nlobby.setExits(\"up\", pub);  \npub.setExits(\"down\", lobby);  \n\n这里发生了什么？  \n将lobby的出口方向和对应房间传给它的setExits的方法后  \nlobby里面的容器就会多一对出口和房间的对应关系  \nlobby里面的getExitDesc、getExit方法以及未来可能加入的新方法，都遍历这个容器  \n所以，增加出口和连接的房间，只需要调用setExits方法，去往lobby里的容器写入东西即可  \n\n现在，对于增加出口来说，已经具有了可扩展性\n\n### 以框架+数据来提高可扩展性\n我们原来用硬编码去保存room的出口  \n现在我们用容器，HashMap和对应的方法（接口方法）组成了一个框架，数据就是放在HashMap里的东西  \n在这个框架中要增加出口很容易  \n\n启发：  \n命令的解析是否可以脱离if-else  \n定义一个Handler来处理命令  \n用Hash表来保存命令和Handler之间的关系  \n\n现在我们可以用相同的思路去解决用户命令（help，go，bye）的硬编码问题  \n一个字符串对应调用一个方法，这显然也是一一对应的关系  \n但容器**只能放对象**，一个方法不能放进容器中  \n\n### 如何把方法放进容器中\n创建一个Handler类，然后把每个命令创建为Handler的子类  \n将命令字符串和Handler子类的对象一一对应放入HashMap中  \n将功能在Handler的子类的doCmd方法中实现  \n在game中通过父类对象管理者去管理子类对象（从HashMap中获取子类对象），管理者调用doCmd方法即可  \n\n```java Room.java\npackage castle;\n\nimport java.util.HashMap;\n\npublic class Room {\n    //描述\n    private String description;\n    //用HashMap来保存这个房间连接着的四个房间\n    private HashMap<String, Room> exits = new HashMap<String, Room>();\n\n    public Room(String description)//初始化房间名\n    {\n        this.description = description;\n    }\n\n    public void setExits(String direction, Room room) {\n        exits.put(direction, room);//将出口方向和连接的房间放进容器中\n    }\n\n    @Override\n    public String toString() {\n        return description;//输出房间名\n    }\n\n    public String getExitDesc() {\n        //返回一个字符串，来表达房间的出口\n        //一般我们不使用String去做拼接，因为每次加都会产生一个新的String类型的对象，系统开销会很大，而是使用StringBuilder\n        StringBuilder builder = new StringBuilder(\"出口有：\");\n        for (String direction : exits.keySet()) {\n            builder.append(direction);\n            builder.append(\" \");\n        }\n        return builder.toString();\n    }\n\n    public Room getExit(String direction) {\n        //返回指定方向的连接房间\n        return exits.get(direction);//直接从HashMap中获取房间，如果没有容器会自动返回null\n    }\n}\n```\n```java Game.java\npackage castle;\n\nimport java.util.*;\n\npublic class Game {\n    private Room currentRoom;//创建一个Room对象，用于保存当前房间\n    //创建一个HashMap对象，用于保存所有的命令处理器\n    private HashMap<String, Handler> handlers = new HashMap<String, Handler>();\n\n    public Game()//构造函数\n    {\n        //将字符串和命令处理器对应\n        handlers.put(\"go\",new HandlerGo(this));//把game对象作为参数传入HandlerGo类，让HandlerGo能管理game\n        handlers.put(\"help\",new HandlerHelp(this));\n        handlers.put(\"bye\",new HandlerBye(this));\n        creatRooms();//创建房间\n    }\n\n    private void creatRooms()//创建一个房间\n    {\n        Room outside, lobby,pub,study,bedroom;//创建5种房间\n\n        // 制造5种房间\n        outside = new Room(\"城堡外\");\n        lobby = new Room(\"大堂\");\n        pub = new Room(\"小酒吧\");\n        study = new Room(\"书房\");\n        bedroom = new Room(\"卧室\");\n\n        // 初始化房间的出口\n        outside.setExits(\"east\", lobby);\n        outside.setExits(\"south\", study);\n        outside.setExits(\"west\", pub);\n        lobby.setExits(\"west\", outside);\n        pub.setExits(\"east\", outside);\n        study.setExits(\"north\", outside);\n        study.setExits(\"east\", bedroom);\n        bedroom.setExits(\"west\", study);\n        //现在当我们想增加出口方向，很简单\n        lobby.setExits(\"up\", pub);\n        pub.setExits(\"down\", lobby);\n\n        currentRoom = outside; //从城堡门外开始\n    }\n\n\n    private void printWelcome()//输出欢迎信息\n    {\n        System.out.println();\n        System.out.println(\"欢迎来到城堡!\");\n        System.out.println(\"这是一个超级无聊的游戏。\");\n        System.out.println(\"如果需要帮助，请输入'help'\");\n        System.out.println();\n        showPrompt();\n    }\n\n    //  以下为用户命令\n\n    /*private void printHelp()//帮助菜单\n    {\n        System.out.println(\"迷路了吗？你可以做的命令有：go bye help\");\n        System.out.println(\"如：\\tgo east\");\n    }*/\n\n    public void goRoom(String direction)\n    {\n        Room nextRoom = currentRoom.getExit(direction);//创建一个Room对象，用于保存下一个房间\n        // 如果找到了下一个房间，则进入下一个房间\n        if(nextRoom == null){\n            System.out.println(\"那里没有门！\");\n        }\n        else{\n            currentRoom = nextRoom;//让当前房间等于下一个房间\n            // 输出当前房间的描述\n            showPrompt();\n        }\n    }\n\n    public void showPrompt()\n    {\n        // 输出当前房间的描述\n        System.out.println(\"你在\"+ currentRoom);\n        //调用房间的getExitString()方法，输出当前房间的出口\n        System.out.println(currentRoom.getExitDesc());\n    }\n\n    public void play(){//游戏开始\n        Scanner in = new Scanner(System.in);\n        while (true)//进入游戏主体，游戏结束时退出循环\n        {\n            String line = in.nextLine();//控制台输入一行\n            String[] words = line.split(\" \");//以空格为分隔符，把用户输入的字符串分割成字符串数组\n            Handler handler = handlers.get(words[0]);//获取用户输入的命令,从HashMap中获取对应的子类对象,让handler管理这个对象\n            String value = \"\";//保存命令的字符串\n            if(words.length > 1)//判断是不是bye命令\n            {\n                value = words[1];//获取参数\n            }\n            if(handler != null){//如果命令存在\n                handler.doCmd(value);//调用命令处理器\n                if ( handler.isBye() ) {//如果命令处理器返回true，则退出游戏\n                    System.out.println(\"感谢您的光临。再见！\");\n                    break;\n                }\n            }\n        }\n        in.close();//关闭Scanner\n    }\n\n    public static void main(String[] args) {\n        /*Scanner in = new Scanner(System.in);*/\n        //通过new Scanner(System.in)创建一个Scanner，控制台会一直等待输入，直到敲回车键结束，把所输入的内容传给Scanner，作为扫描对象。\n        Game game = new Game();\n        game.printWelcome();//输出欢迎信息\n        game.play();\n        /*while (true)//进入游戏主体，游戏结束时退出循环\n        {\n            String line = in.nextLine();//控制台输入一行\n            String[] words = line.split(\" \");//以空格为分隔符，把用户输入的字符串分割成字符串数组\n            //判断是go还是help\n            if ( words[0].equals(\"help\")){\n                game.printHelp();//输出帮助信息\n            }else if ( words[0].equals(\"go\")){\n                game.goRoom(words[1]);//将用户输入的方向传给goRoom方法\n            }else if ( words[0].equals(\"bye\")){\n                break;//如果用户数据为bye，则退出游戏\n            }\n        }*/\n        //System.out.println(\"感谢您的光临。再见！\");\n        //in.close();//关闭Scanner\n    }\n}\n```\n```java Handler.java\npackage castle;\n\npublic class Handler {\n    protected Game game;//创建一个Game对象的管理者，为了方便设为protected\n    public Handler(Game game) {\n        this.game = game;//两个game管理者管理同一个Game对象\n    }\n\n    public void doCmd(String word) {}//一个接口，用于运行命令\n    public boolean isBye() { return false; }\n}\n```\n```java HandlerBye.java\npackage castle;\n\npublic class HandlerBye  extends Handler {\n    //必要的构造器\n    public HandlerBye(Game game) {\n        super(game);\n    }\n    @Override\n    public boolean isBye() {\n        return true;\n    }\n}\n```\n```java HandlerHelp.java\npackage castle;\n\npublic class HandlerHelp extends Handler {\n    //必要的构造器\n    public HandlerHelp(Game game) {\n        super(game);\n    }\n    @Override\n    public void doCmd(String word) {\n        System.out.println(\"迷路了吗？你可以做的命令有：go bye help\");\n        System.out.println(\"如：\\tgo east\");\n    }\n}\n```\n```java HandlerGo.java\npackage castle;\n\npublic class HandlerGo extends Handler {\n    public HandlerGo(Game game) {\n        super(game);//现在HandlerGo能管理game对象了\n    }\n    //help和bye都与game无关，但go需要调用goRoom方法，所以需要拿到game对象的管理者\n    public void doCmd(String word) {\n        game.goRoom(word);//调用game的goRoom方法\n    }\n\n}\n```\n>HandlerGo在未来有更好的方法去实现，现在还是用管理者吧\n\n如果要加入新的命令，也非常简单  \n创建一个新的Handler子类，在里面实现命令的功能  \n在Game的构造器中将命令字符串和Handler的子类对象放进去  \n\n现在这个城堡游戏已经有极高的可扩展性了  \n>这个城堡游戏例子非常全面，偶尔回来看看这个例子，是个不错的选择\n\n***\n\n# 抽象abstract\n关键字：**abstract**\n```java\npublic abstract class Shape {//抽象类\n    public abstract void draw(Graphics g);//抽象方法不带{}，即不带方法体\n}\n```\n抽象方法：表达概念，但无法实现具体功能（代码）的方法  \n抽象类：表达概念而无法构造出实体（对象）的类  \n\n有抽象方法的类**一定**是抽象类  \n抽象类不能**制造**对象，但是可以**定义**类变量（任何继承了抽象类的非抽象类的对象可以使用赋给这个类变量，即任何抽象类的子类的对象都可以由这个类变量来管理）  \n抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。  \n\n继承自抽象类的子类必须覆盖父类中的抽象方法，否则自己成为抽象类（即子类必须实现抽象父类的抽象方法）\n\n## 两种抽象\n与具体相对  \n·表示一种概念而非实体  \n与细节相对  \n·表示在一定程度上忽略细节而着眼大局  \n\n*** \n\n# 细胞自动机\n\n死亡：如果活着的邻居的数量小于2或大于3，则死亡  \n新生：如果正好有3个邻居活着，则新生其他情况则保持原状  \n\n```java Cell.java\npackage cell;\n\nimport java.awt.Graphics;\n \npublic class Cell {\n\tprivate boolean alive = false;//默认为死亡状态\n\t\n\tpublic void die() { alive = false; }//让细胞死亡\n\tpublic void reborn() { alive = true; }//让细胞重生\n\tpublic boolean isAlive() { return alive; }//返回细胞状态,判断细胞是否存活\n\t//绘制细胞\n\tpublic void draw(Graphics g, int x, int y, int size) {\n\t\tg.drawRect(x, y, size, size);//画个空心矩形\n\t\tif ( alive ) {//如果细胞存活\n\t\t\tg.fillRect(x, y, size, size);//画个实心矩形\n\t\t}\n\t}\n}\n\n```\n\n```java CellMachine.java\npackage cellmachine;\n\nimport javax.swing.JFrame;\n\nimport cell.Cell;\nimport field.Field;\nimport field.View;\n\npublic class CellMachine {\n\n\tpublic static void main(String[] args) {\n\t\t//数据准备阶段,画出一个细胞网格\n\t\tField field = new Field(30,30);//一个30*30的网格\n\t\t//遍历网格，每个网格都有一个细胞\n\t\tfor ( int row = 0; row<field.getHeight(); row++ ) {//遍历每一行\n\t\t\tfor ( int col = 0; col<field.getWidth(); col++ ) {//遍历每一列\n\t\t\t\tfield.place(row, col, new Cell());//每个细胞都有一个状态，初始状态为死亡\n\t\t\t}\n\t\t}\n\n\t\t//遍历每个细胞，设置初始细胞的生存状态\n\t\tfor ( int row = 0; row<field.getHeight(); row++ ) {//遍历每一行\n\t\t\tfor ( int col = 0; col<field.getWidth(); col++ ) {//遍历每一列\n\t\t\t\tCell cell = field.get(row, col);//获取(row,col)位置上的细胞\n\t\t\t\t//利用随机数让整个网格的五分之一的细胞生存\n\t\t\t\tif ( Math.random() < 0.2 ) { //Math.random()返回0~1之间的随机数\n\t\t\t\t\tcell.reborn();//reborn()方法设置细胞的生存状态为true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n        //在窗口中显示细胞网格\n\t\tView view = new View(field);//将网格传入View类中\n\t\tJFrame frame = new JFrame();//创建一个JFrame对象,是java当中的窗口,用来显示细胞网格\n\t\tframe.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);//设置窗口关闭时的操作\n\t\tframe.setResizable(false);//设置窗口不可改变大小\n\t\tframe.setTitle(\"Cells\");//设置窗口的标题\n\t\tframe.add(view);//将网格添加到窗口中\n\t\tframe.pack();//设置窗口的大小\n\t\tframe.setVisible(true);//设置窗口可见,即显示出来\n\n\t\t//模拟细胞网格的运行\n\t\t//遍历整个网格,取出每个细胞\n\t\tfor ( int i=0; i<1000; i++ ) {//进行1000次模拟\n\t\t\tfor ( int row = 0; row<field.getHeight(); row++ ) {//遍历每一行\n\t\t\t\tfor ( int col = 0; col<field.getWidth(); col++ ) {//遍历每一列\n\t\t\t\t\tCell cell = field.get(row, col);//获取(row,col)位置上的细胞\n\t\t\t\t\tCell[] neighbour = field.getNeighbour(row, col);//获取(row,col)位置上的细胞的邻居\n\t\t\t\t\tint numOfLive = 0;//计数器，记录邻居中活细胞的个数\n\t\t\t\t\t//遍历邻居，计算邻居中有多少个细胞是活的\n\t\t\t\t\tfor ( Cell c : neighbour ) {\n\t\t\t\t\t\tif ( c.isAlive() ) {//如果邻居中有一个细胞是活的\n\t\t\t\t\t\t\tnumOfLive++;//让计数器加一\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//控制台输出当前细胞的状态\n\t\t\t\t\tSystem.out.print(\"[\"+row+\"][\"+col+\"]:\");//打印细胞的位置\n\t\t\t\t\tSystem.out.print(cell.isAlive()?\"live\":\"dead\");//打印细胞的状态\n\t\t\t\t\tSystem.out.print(\":\"+numOfLive+\"-->\");//打印细胞的邻居中有多少个细胞是活的\n\t\t\t\t\t//写入下一次的细胞状态\n\t\t\t\t\tif ( cell.isAlive() ) {//如果当前细胞是活的\n\t\t\t\t\t\tif ( numOfLive <2 || numOfLive >3 ) {//判断是否满足让细胞死的条件条件\n\t\t\t\t\t\t\tcell.die();//让细胞死\n\t\t\t\t\t\t\tSystem.out.print(\"die\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if ( numOfLive == 3 ) {//如果当前细胞是死的，判断是否满足让细胞活的条件条件\n\t\t\t\t\t\tcell.reborn();//让细胞活\n\t\t\t\t\t\tSystem.out.print(\"reborn\");\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(\"UPDATE\");\n\t\t\tframe.repaint();//整个Field都更新好后，画出棋盘\n\t\t\t//延时\n\t\t\ttry {\n\t\t\t\tThread.sleep(200);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n```\n\n```java Field.java\npackage field;\n\nimport java.util.ArrayList;\n\nimport cell.Cell;\n\npublic class Field {\n\tprivate int width;\n\tprivate int height;\n\tprivate Cell[][] field;//一个二维数组field，存放每个格子（细胞）\n\t//构造器，初始化棋盘\n\tpublic Field(int width, int height) {\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\tfield = new Cell[height][width];\n\t}\n\tpublic int getWidth() { return width; }\n\tpublic int getHeight() { return height; }\n\t//添加细胞\n\tpublic Cell place(int row, int col, Cell o) {\n\t\tCell ret = field[row][col];\n\t\tfield[row][col] = o;\n\t\treturn ret;\n\t}\n\t//获取某个格子\n\tpublic Cell get(int row, int col) {\n\t\treturn field[row][col];\n\t}\n\t//获取周围细胞\n\tpublic Cell[] getNeighbour(int row, int col) {\n\t\tArrayList<Cell> list = new ArrayList<Cell>();\n\t\tfor ( int i=-1; i<2; i++ ) {\n\t\t\tfor ( int j=-1; j<2; j++ ) {\n\t\t\t\tint r = row+i;\n\t\t\t\tint c = col+j;\n\t\t\t\tif ( r >-1 && r<height && c>-1 && c<width && !(r== row && c == col) ) {\n\t\t\t\t\tlist.add(field[r][c]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        //toArray会自动把一个Cell[]数组装好，让返回这个数组\n\t\treturn list.toArray(new Cell[list.size()]);\n\t}\n\t//清空所有格子\n\tpublic void clear() {\n\t\tfor ( int i=0; i<height; i++ ) {\n\t\t\tfor ( int j=0; j<width; j++ ) {\n\t\t\t\tfield[i][j] = null;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n```\n\n```java View.java\npackage field;\n\nimport java.awt.Dimension;\nimport java.awt.Graphics;\n\nimport javax.swing.JFrame;\nimport javax.swing.JPanel;\n\nimport cell.Cell;\n\npublic class View extends JPanel {\n\tprivate static final long serialVersionUID = -5258995676212660595L;\n\tprivate static final int GRID_SIZE = 16;\n\tprivate Field theField;\n\n\t//构造器\n\tpublic View(Field field) {\n\t\ttheField = field;\n\t}\n\n\t//每次当窗口被重绘时调用，被调用时会得到一个Graphics对象，即当前要画的对象\n\t@Override\n\tpublic void paint(Graphics g) {\n\t\tsuper.paint(g);//调用父类的paint方法\n\t\t//绘制网格\n\t\tfor ( int row = 0; row<theField.getHeight(); row++ ) {//行\n\t\t\tfor ( int col = 0; col<theField.getWidth(); col++ ) {//列\n\t\t\t\tCell cell = theField.get(row, col);//得到每个格子的对象\n\t\t\t\tif ( cell != null ) {//如果该格子有对象\n\t\t\t\t\tcell.draw(g, col*GRID_SIZE, row*GRID_SIZE, GRID_SIZE);//绘制该格子\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic Dimension getPreferredSize() {\n\t\treturn new Dimension(theField.getWidth()*GRID_SIZE+1, theField.getHeight()*GRID_SIZE+1);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tField field = new Field(10,10);\n\t\tfor ( int row = 0; row<field.getHeight(); row++ ) {\n\t\t\tfor ( int col = 0; col<field.getWidth(); col++ ) {\n\t\t\t\tfield.place(row, col, new Cell());\n\t\t\t}\n\t\t}\n\t\tView view = new View(field);\n\t\tJFrame frame = new JFrame();\n\t\tframe.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\t\tframe.setResizable(false);\n\t\tframe.setTitle(\"Cells\");\n\t\tframe.add(view);\n\t\tframe.pack();\n\t\tframe.setVisible(true);\n\t}\n\n}\n\n```\n\n## Cell、Field、View的关系\nField只需要管好数据以及提供数据  \nView只管拿到数据之后按数据把整个网格都重新画一遍  \n而Cell只管自己应该画空心还是实心，Field要就提供给它  \n\n不去精心设计哪个局部需要更新，需要更新就整个重画   \n这样简化了程序逻辑，是在计算机运算速度提高的基础上实现的  \n<div><img src=/images/7-8.webp width=\"80%\" height=\"80%\"></div>\n\n## 数据与表现分离\n程序的业务逻辑与表现无关  \n-表现可以是图形的也可以是文本的  \n-表现可以是当地的也可以是远程的  \n\n需要不同表现，那就用不同表现的代码去取数据，然后表现出来  \n\n## 责任驱动的设计\n将程序要实现的功能分配到合适的类/对象中去是设计中非常重要的一环  \n\n将功能拆分成很多个部分，每个部分只做自己擅长做的、简单的事  \n\n## 网格化\n图形界面本身有更高的解析度，但是将画面网格化以后，数据就更容易处理了  \n\n无需关心x、y轴坐标，只需知道要操作的对象在第几行第几列\n\n***\n\n# 狐狸和兔子\n细胞自动机是细胞在一个网格上，每个细胞都有两种状态  \n\n现在要模拟一个有狐狸和兔子的农场：   \n·狐狸和兔子都有年龄，且有规律增加  \n·当年龄到了一定的上限就会自然死亡  \n·狐狸可以随机决定在周围的兔子中吃一个，吃了后年龄上限会提高  \n·狐狸和兔子可以随机决定生一个小的，放在旁边的空的格子里  \n·如果不吃也不生，狐狸和兔子可以随机决定向旁边空的格子移一步  \n\n这比只有细胞，细胞只有两种状态要复杂得多  \n\n## 源码\n这个没注释，原理和细胞自动机差不多  \n```java Cell.java\npackage cell;\n\nimport java.awt.Graphics;\n\npublic interface Cell {\n\tvoid draw(Graphics g, int x, int y, int size);\n}\n```\n\n```java Animal.java\npackage animal;\n\nimport java.util.ArrayList;\nimport field.Location;\n\npublic abstract class Animal {\n\n\tprivate int ageLimit;\n\tprivate int breedableAge;\n\tprivate int age;\n\tprivate boolean isAlive = true;\n\n\tpublic Animal(int ageLimit, int breedableAge) {\n\t\tthis.ageLimit = ageLimit;\n\t\tthis.breedableAge = breedableAge;\n\t}\n\n\tprotected int getAge() {\n\t\treturn age;\n\t}\n\n\tprotected double getAgePercent() {\n\t\treturn (double) age / ageLimit;\n\t}\n\n\tpublic abstract Animal breed();\n\n\tpublic void grow() {\n\t\tage++;\n\t\tif (age >= ageLimit) {\n\t\t\tdie();\n\t\t}\n\t}\n\n\tpublic void die() {\n\t\tisAlive = false;\n\t}\n\n\tpublic boolean isAlive() {\n\t\treturn isAlive;\n\t}\n\n\tpublic boolean isBreedable() {\n\t\treturn age >= breedableAge;\n\t}\n\n\tpublic Location move(Location[] freeAdj) {\n\t\tLocation ret = null;\n\t\tif (freeAdj.length > 0 && Math.random() < 0.02) {\n\t\t\tret = freeAdj[(int) (Math.random() * freeAdj.length)];\n\t\t}\n\t\treturn ret;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"\" + age + \":\" + (isAlive ? \"live\" : \"dead\");\n\t}\n\n\tpublic Animal feed(ArrayList<Animal> neighbour) {\n\t\treturn null;\n\t}\n\n\tprotected void longerLife(int inc) {\n\t\tageLimit += inc;\n\t}\n}\n\n```\n\n```java Fox.java\npackage animal;\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.util.ArrayList;\n\nimport cell.Cell;\n\npublic class Fox extends Animal implements Cell {\n\n\tpublic Fox() {\n\t\tsuper(20, 4);\n\t}\n\n\t@Override\n\tpublic void draw(Graphics g, int x, int y, int size) {\n\t\tint alpha = (int) ((1 - getAgePercent()) * 255);\n\t\tg.setColor(new Color(0, 0, 0, alpha));// (int)((20-getAge())/20.0*255)));\n\t\tg.fillRect(x, y, size, size);\n\t}\n\n\t@Override\n\tpublic Animal breed() {\n\t\tAnimal ret = null;\n\t\tif (isBreedable() && Math.random() < 0.05) {\n\t\t\tret = new Fox();\n\t\t}\n\t\treturn ret;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Fox:\" + super.toString();\n\t}\n\n\t@Override\n\tpublic Animal feed(ArrayList<Animal> neighbour) {\n\t\tAnimal ret = null;\n\t\tif (Math.random() < 0.2) {\n\t\t\tret = neighbour.get((int) (Math.random() * neighbour.size()));\n\t\t\tlongerLife(2);\n\t\t}\n\t\treturn ret;\n\t}\n}\n\n```\n\n```java Rabbit.java\npackage animal;\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport cell.Cell;\n\npublic class Rabbit extends Animal implements Cell {\n\n\tpublic Rabbit() {\n\t\tsuper(10, 2);\n\t}\n\n\t@Override\n\tpublic void draw(Graphics g, int x, int y, int size) {\n\t\tint alpha = (int) ((1 - getAgePercent()) * 255);\n\t\tg.setColor(new Color(255, 0, 0, alpha));\n\t\tg.fillRect(x, y, size, size);\n\t}\n\n\t@Override\n\tpublic Animal breed() {\n\t\tAnimal ret = null;\n\t\tif (isBreedable() && Math.random() < 0.12) {\n\t\t\tret = new Rabbit();\n\t\t}\n\t\treturn ret;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Rabbit:\" + super.toString();\n\t}\n}\n```\n\n```java Field.java\npackage field;\n\nimport java.util.ArrayList;\nimport cell.Cell;\n\npublic class Field {\n\n\tprivate static final Location[] adjacent = {\n\t\t\tnew Location(-1, -1), new Location(-1, 0), new Location(-1, 1),\n\t\t\tnew Location(0, -1), new Location(0, 0), new Location(0, 1),\n\t\t\tnew Location(1, -1), new Location(1, 0), new Location(1, 1)\n\t};\n\n\tprivate int width;\n\tprivate int height;\n\tprivate Cell[][] field;\n\n\tpublic Field(int width, int height) {\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\tfield = new Cell[height][width];\n\t}\n\n\tpublic int getWidth() {\n\t\treturn width;\n\t}\n\tpublic int getHeight() {\n\t\treturn height;\n\t}\n\tpublic Cell place(int row, int col, Cell o) {\n\t\tCell ret = field[row][col];\n\t\tfield[row][col] = o;\n\t\treturn ret;\n\t}\n\n\tpublic Cell get(int row, int col) {\n\t\treturn field[row][col];\n\t}\n\n\tpublic Cell[] getNeighbour(int row, int col) {\n\t\tArrayList<Cell> list = new ArrayList<Cell>();\n\t\tfor (int i = -1; i < 2; i++) {\n\t\t\tfor (int j = -1; j < 2; j++) {\n\t\t\t\tint r = row + i;\n\t\t\t\tint c = col + j;\n\t\t\t\tif (r > -1 && r < height && c > -1 && c < width && !(r == row && c == col)) {\n\t\t\t\t\tlist.add(field[r][c]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn list.toArray(new Cell[list.size()]);\n\t}\n\n\tpublic Location[] getFreeNeighbour(int row, int col) {\n\t\tArrayList<Location> list = new ArrayList<Location>();\n\t\tfor (Location loc : adjacent) {\n\t\t\tint r = row + loc.getRow();\n\t\t\tint c = col + loc.getCol();\n\t\t\tif (r > -1 && r < height && c > -1 && c < width && field[r][c] == null) {\n\t\t\t\tlist.add(new Location(r, c));\n\t\t\t}\n\t\t}\n\t\treturn list.toArray(new Location[list.size()]);\n\t}\n\n\tpublic boolean placeRandomAdj(int row, int col, Cell cell) {\n\t\tboolean ret = false;\n\t\tLocation[] freeAdj = getFreeNeighbour(row, col);\n\t\tif (freeAdj.length > 0) {\n\t\t\tint idx = (int) (Math.random() * freeAdj.length);\n\t\t\tfield[freeAdj[idx].getRow()][freeAdj[idx].getCol()] = cell;\n\t\t\tret = true;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tpublic Cell remove(int row, int col) {\n\t\tCell ret = field[row][col];\n\t\tfield[row][col] = null;\n\t\treturn ret;\n\t}\n\n\tpublic void remove(Cell cell) {\n\t\tfor (int row = 0; row < height; row++) {\n\t\t\tfor (int col = 0; col < width; col++) {\n\t\t\t\tif (field[row][col] == cell) {\n\t\t\t\t\tfield[row][col] = null;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void clear() {\n\t\tfor (int i = 0; i < height; i++) {\n\t\t\tfor (int j = 0; j < width; j++) {\n\t\t\t\tfield[i][j] = null;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void move(int row, int col, Location loc) {\n\t\tfield[loc.getRow()][loc.getCol()] = field[row][col];\n\t\tremove(row, col);\n\t}\n}\n```\n\n```java Location.java\npackage field;\n\npublic class Location {\n\n\tprivate int row;\n\tprivate int col;\n\n\tpublic Location(int row, int col) {\n\t\tthis.row = row;\n\t\tthis.col = col;\n\t}\n\n\tpublic int getRow() {\n\t\treturn row;\n\t}\n\n\tpublic int getCol() {\n\t\treturn col;\n\t}\n}\n```\n\n```java View.java\npackage field;\n\nimport java.awt.Color;\nimport java.awt.Dimension;\nimport java.awt.Graphics;\nimport javax.swing.JPanel;\nimport cell.Cell;\n\npublic class View extends JPanel {\n\tprivate static final long serialVersionUID = -2417015700213488315L;\n\tprivate static final int GRID_SIZE = 16;\n\tprivate Field theField;\n\tpublic View(Field field) {\n\t\ttheField = field;\n\t}\n\n\t@Override\n\tpublic void paint(Graphics g) {\n\t\tsuper.paint(g);\n\t\tg.setColor(Color.GRAY);\n\t\tfor (int row = 0; row < theField.getHeight(); row++) {\n\t\t\tg.drawLine(0, row * GRID_SIZE, theField.getWidth() * GRID_SIZE, row * GRID_SIZE);\n\t\t}\n\t\tfor (int col = 0; col < theField.getWidth(); col++) {\n\t\t\tg.drawLine(col * GRID_SIZE, 0, col * GRID_SIZE, theField.getHeight() * GRID_SIZE);\n\t\t}\n\t\tfor (int row = 0; row < theField.getHeight(); row++) {\n\t\t\tfor (int col = 0; col < theField.getWidth(); col++) {\n\t\t\t\tCell cell = theField.get(row, col);\n\t\t\t\tif (cell != null) {\n\t\t\t\t\tcell.draw(g, col * GRID_SIZE, row * GRID_SIZE, GRID_SIZE);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic Dimension getPreferredSize() {\n\t\treturn new Dimension(theField.getWidth() * GRID_SIZE + 1, theField.getHeight() * GRID_SIZE + 1);\n\t}\n}\n```\n\n```java FoxAndRabbit.java\npackage foxnrabbit;\n\nimport java.util.ArrayList;\nimport javax.swing.JFrame;\nimport animal.Animal;\nimport animal.Fox;\nimport animal.Rabbit;\nimport cell.Cell;\nimport field.Field;\nimport field.Location;\nimport field.View;\n\npublic class FoxAndRabbit {\n\n\tprivate Field theField;\n\tprivate View theView;\n\n\tpublic FoxAndRabbit(int size) {\n\t\ttheField = new Field(size, size);\n\t\tfor (int row = 0; row < theField.getHeight(); row++) {\n\t\t\tfor (int col = 0; col < theField.getWidth(); col++) {\n\t\t\t\tdouble probability = Math.random();\n\t\t\t\tif (probability < 0.05) {\n\t\t\t\t\ttheField.place(row, col, new Fox());\n\t\t\t\t} else if (probability < 0.15) {\n\t\t\t\t\ttheField.place(row, col, new Rabbit());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttheView = new View(theField);\n\t\tJFrame frame = new JFrame();\n\t\tframe.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\t\tframe.setResizable(false);\n\t\tframe.setTitle(\"Cells\");\n\t\tframe.add(theView);\n\t\tframe.pack();\n\t\tframe.setVisible(true);\n\t}\n\n\tpublic void start(int steps) {\n\t\tfor (int i = 0; i < steps; i++) {\n\t\t\tstep();\n\t\t\ttheView.repaint();\n\t\t\ttry {\n\t\t\t\tThread.sleep(200);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void step() {\n\t\tfor (int row = 0; row < theField.getHeight(); row++) {\n\t\t\tfor (int col = 0; col < theField.getWidth(); col++) {\n\t\t\t\tCell cell = theField.get(row, col);\n\t\t\t\tif (cell != null) {\n\t\t\t\t\tAnimal animal = (Animal) cell;\n\t\t\t\t\tanimal.grow();\n\t\t\t\t\tif (animal.isAlive()) {\n\t\t\t\t\t\tLocation loc = animal.move(theField.getFreeNeighbour(row, col));\n\t\t\t\t\t\tif (loc != null) {\n\t\t\t\t\t\t\ttheField.move(row, col, loc);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// eat\n\t\t\t\t\t\t// animal.eat(theField);\n\t\t\t\t\t\tCell[] neighbour = theField.getNeighbour(row, col);\n\t\t\t\t\t\tArrayList<Animal> listRabbit = new ArrayList<Animal>();\n\t\t\t\t\t\tfor (Cell an : neighbour) {\n\t\t\t\t\t\t\tif (an instanceof Rabbit) {\n\t\t\t\t\t\t\t\tlistRabbit.add((Rabbit) an);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!listRabbit.isEmpty()) {\n\t\t\t\t\t\t\tAnimal fed = animal.feed(listRabbit);\n\t\t\t\t\t\t\tif (fed != null) {\n\t\t\t\t\t\t\t\ttheField.remove((Cell) fed);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// breed\n\t\t\t\t\t\tAnimal baby = animal.breed();\n\t\t\t\t\t\tif (baby != null) {\n\t\t\t\t\t\t\ttheField.placeRandomAdj(row, col, (Cell) baby);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttheField.remove(row, col);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tFoxAndRabbit fab = new FoxAndRabbit(50);\n\t\tfab.start(500);\n\t}\n}\n\n```\n\n## 项目结构及分析\n<div><img src=/images/7-9.webp width=\"40%\" height=\"40%\"></div>\n\n在英文中Cell有两种意思，格子、细胞  \n在刚刚到细胞自动机中，Cell类表达细胞，或者没有细胞的空格子，这很合理  \n\n狐狸和兔子类有很多相似的属性和动作，所以它们应该有一个父类  \n但这个父类不应该是Cell，Cell在这个程序中应该表达有东西或没东西的格子才合理  \n所以这个父类应该是Animal  \n\n现在类之间关系是这样的：  \n<div><img src=/images/7-10.webp width=\"100%\" height=\"100%\"></div>\n\n在细胞自动机中我们通过place(r,c,cell)将Cell放进网格中  \n但现在Fox、Rabbit和Cell没有联系，无法将它们放进网格中  \n如果按照之前的思路，Fox、Rabbit应该也是Cell的子类，但多继承是不被允许的（除了C++）  \n\n如果让Animal从Cell继承，这在语意上是模糊的，动物不应该是一种格子（虽然这样做能实现）  \n\n## 接口\n接口是纯抽象类  \n·所有的成员函数都是抽象函数  \n·所有的成员变量都是public static final  \n\n类表达一个具体的东西，而接口表达一种概念、一种规范  \n接口规定了长什么样，但是不管里面有什么  \n\n我们可以将Cell类改造成接口： \n```java Cell\nimport java.awt.Graphics;\npublic interface Cell {\n\tvoid draw(Graphics g, int x, int y, int size);\n}\n```\nCell现在的作用：所有实现了Cell这个接口的类，都应该有draw这个方法  \n在这个程序中，只要实现了这个方法的类的对象，都可以直接放到Field中  \n\n为什么Cell接口只要求实现draw方法？  \n因为将来View只需要拿Cell去draw，所以只需要要求放到Field里的类的对象实现draw方法  \n\n现在类之间关系是这样的：  \n<div><img src=/images/7-11.webp width=\"100%\" height=\"100%\"></div>\n\n现在Fox、Rabbit的对象都可以放进Field里（Field需要一个Cell，而Fox、Rabbit都实现了Cell）  \n\n### implements\n用关键字implements让类实现接口  \n```java\npublic class Fox extends Animal implements Cell{\n    //Fox是一种Animal，它实现了Cell\n}\n```\n在Field的place方法中,place需要一个Cell类的对象  \nCell本身是一个接口，它本身是抽象的，不可能有对象  \n但**所有实现了Cell接口**的对象都可以交给Cell对象的管理者  \n```java\npublic Cell place(int row, int col, Cell o) {\n\t\tCell ret = field[row][col];\n\t\tfield[row][col] = o;\n\t\treturn ret;\n\t}\n```\n当Fox实现Cell后，就必须重写Cell中的方法  \n把draw方法实际地做出来  \n```java\n@Override\n\tpublic void draw(Graphics g, int x, int y, int size) {\n\t\tint alpha = (int) ((1 - getAgePercent()) * 255);\n\t\tg.setColor(new Color(0, 0, 0, alpha));\n\t\tg.fillRect(x, y, size, size);\n\t}\n```\n类用extends,接口用implements  \n类可以实现很多接口  \n接口可以继承接口，但不能继承类  \n接口不能实现接口  \n\n### interface\n声明一个接口  \n```java\npublic interface Cell{//接口\n}\npublic class Cell{//类\n}\n```\ninterface是一种特殊的class，它替代掉了class  \n\n### 面向接口的编程方式\n在上面的程序中，Field需要一个能draw的类的对象，然后Field提供了一个Cell接口，所有实现了这个接口的东西都可以交给Field，而它不关心这个东西是什么，只需要符合接口即可  \n\n设计程序时先定义接口，再实现类  \n任何需要在函数间传入传出的一定是接口而不是具体的类  \n是Java成功的关键之一，因为极适合多人同时写一个大程序：每个人只需要用接口去提出要求，其他人根据借口实现具体的类   \n也是Java被批评的要点之一，因为代码量膨胀起来很快，显得程序十分臃肿  \n\n## 增加一个按钮\n\n在狐狸与兔子程序的图形界面中增加一个按钮，按一下执行一步   \n\n在FoxAndRabbit.java中，这么一段代码生成了一个窗口  \n```java\ntheView = new View(theField);\nJFrame frame = new JFrame();\nframe.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\nframe.setResizable(false);\nframe.setTitle(\"Cells\");\nframe.add(theView);\nframe.pack();\nframe.setVisible(true);\n```\n首先要在窗口中增加一个按钮  \n```java\ntheView = new View(theField);\nJFrame frame = new JFrame();\nframe.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\nframe.setResizable(false);\nframe.setTitle(\"Cells\");\nframe.add(theView);\n//有一个类叫JButton，做一个叫btnstep的对象\nJButton btnstep =new JButton(\"单步\");\n//把这个按钮加到窗口中\nframe.add(btnstep);\nframe.pack();\nframe.setVisible(true);\n```\n运行一下\n<div><img src=/images/7-12.webp width=\"30%\" height=\"30%\"></div>\n\n整个窗口只剩下了我们加进去的这个按钮,解决这个问题我们需要了解Swing  \n\n***\n\n>下接[JAVA/面向对象学习笔记(3)](https://www.chuckle.top/article/8636f786.html)","tags":["JAVA","JavaSE"],"categories":["学习笔记"]},{"title":"我的butterfly魔改","url":"/article/ab2d75d5.html","content":"\n# 最新文章标志\n{% link 给首页文章卡片加上最新文章标志,/article/2ed7d622.html,%}<img src=/images/20-1.webp width=\"40%\" height=\"40%\">\n\n# 首页第一个卡片加个class\n{% link 首页第一个卡片加个class,/article/dbde845d.html,%}<img src=/images/21-1.webp width=\"40%\" height=\"40%\">\n\n# 加载进度条\n{% link 一个加载进度条,/article/13d6481a.html,%}<img src=/images/10-1.webp width=\"40%\" height=\"40%\">\n\n咕咕咕~~","tags":["Butterfly","Hexo"],"categories":["Hexo"]},{"title":"JAVA/面向对象学习笔记(1)","url":"/article/bfb663c6.html","content":"\n>所看教程（视频）：《浙江大学-翁恺-Java-面向对象程序设计》\n>作为我自己的复习笔记，也可以当做该视频的同步笔记\n\n# 面向对象\n\n## 什么是面向对象\n面向对象是把**一组数据结构**和**处理他们的方法**组成对象。  \n把具有**相同行为**的对象归纳成**类**  \n通过**封装**隐藏类的内部细节  \n通过**继承**使类得到泛化  \n通过**多态**实现基于对象类型的动态分派 \n\n## 只能操作对象\n一切事物都是调用加封装的结果  \n程序实现的一切功能都是**调用**加**封装**的结果  \n程序调用一个个对象  \n封装的也是一个个对象\n\n## 基于对象编程\n同一个事物，构成它的对象能有多种划分方式  \n机器语言、汇编语言将电路上的开关，由1和0组成的指令作为对象  \n\nc语音将对象界定为一个个**数据**和一个个**算法**  \njava将**数据和算法的结合**作为一个对象    \n\n数据和算法分开的编程：面向过程编程  \n数据和算法结合的编程：面向对象编程  \n\n## 面向过程与面向对象\n面向过程关注如何实现，关注如何做，将一个要实现的、复杂的功能，用一个或多个大函数去实现，再抽丝剥茧，用更多的函数去实现这些函数。  \n面向对象关注数据，方法就在这，处理什么数据（对象）  \n\n面向对象中也有面向过程的代码，只是重点不在如何做，而是对对象的**抽象**与**扩展**  \n对于实现功能的核心算法，面向对象与面向过程并无区别，c语言也可通过结构体与函数指针实现面向对象    \n\n面向对象的**封装**、**继承**和**多态**，使得代码、功能的扩展、复用变得非常容易  \n\n这两种编程思想都是为了解决实际的问题  \n\n{% folding, 如何烧水  %}\n**转自互联网**  \n面向过程的烧水：  \n读取热水壶内水的水温，缓存  \n电热装置将发热量缓存  \n损耗算法读取发热量，并将将水的提升温度缓存  \n与水温相加  \n将这个数值重新赋给水温  \n直到温度达到沸点，完成烧水    \n\n面向对象的烧水：  \n定义热水壶类，继承自盛水容器，温度改变装置，温度计，水温控制接口  \n实例化一个热水壶类对象，命名为「我的热水壶」  \n为终止温度赋值：水.沸点  \n我的热水壶.温度处理(终止温度);  \n\n另：个人实现的烧水方法，仅图一乐：  \n为热水壶类实装烧水接口：实装水温监视事件  \n为热水壶类实装烧水接口：定义一个水温枚举器  \n为热水壶类实装烧水接口：实装温度处理方法  \n执行流程：  \n1.执行继承自盛水容器类的盛水方法  \n2.注册继承自温度改变装置类的温度监视事件  \n3.遍历水温枚举器：如果水温提升，则返回当前水温  \n4.如果返回值接近终止温度，跳出枚举过程，完成烧水。  \n5.否则，继续遍历枚举器。  \n\n你肯定会问这哪里优雅了，确实，看起来是复杂了不少，但再仔细想一想，这一整套流程只要稍加修改，稍加改变接口实现，你就可以直接用这个「热水壶类」实现一个热水器，甚至还可以是一个冰箱。  \n毕竟烧的又不一定是水，又不一定要烧水，又不一定要用壶烧水，又不一样要是个烧水壶  \n{% endfolding %}\n\n***\n\n# 对象与类\n对象是实体，需要被创建，可以为我们做事情    \n类是规范，根据类的定义来创建对象    \n\n一个类可以有多个对象  \n\n动物是一个类，每个对象，猫，狗，都是动物类的实体    \n我们用类制造出对象，再给对象所需要的数据，对象可以利用这些数据去做事情，我们大可无需知道对象是如何利用这些数据的，因为我们只要求，这个对象能实现一些功能  \n\n## 面向对象的思维\n我们看到一个事物  \n它有什么东西？  \n能干什么？  \n\n## 第一个程序：自动售货机\n售货机（VendingMachine）有什么？  \n商品的价格：price  \n显示的余额：balance  \n卖了多少钱：total  \n\n售货机能干什么？  \n输出一些提示：showPromot  \n取得一些钱：insertMomey  \n告诉用户余额：showBalance\n给我们商品（食物）：getFood  \n告诉商家总收入：showTotal\n\n我们需要设计VendingMachine这个类，这个类有3个属性，有5个动作（方法）  \n```java\nimport java.util.Scanner;\n//创建一个类\npublic class VendingMachine {\n    int price = 80;//商品价格(假设就只有一个商品，且价格固定)\n    int balance = 0;//当前余额\n    int total = 0;//总收入\n    int amount = 0;//钱\n    Scanner s=new Scanner(System.in);\n\n    void showPromot() {\n        //输出提示\n        System.out.println(\"欢迎！\");\n    }\n\n    void insertMomey(){\n        // 投入钱，更新余额\n        System.out.print(\"请充值余额：\");\n        amount = s.nextInt();\n        balance = balance + amount;\n    }\n\n    void showBalance(){\n        //输出余额\n        System.out.println(\"现在余额： \"+ balance);\n    }\n\n    void getFood(){\n        //给食物\n        if (balance >= price) {\n            System.out.println(\"给你。\");\n            balance = balance - price;\n            total = total + price;\n        }\n        else{\n            System.out.println(\"没有足够的余额！\");\n        }\n    }\n\n    void showTotal(){\n        System.out.println(\"目前总收入：\"+total);\n    }\n}\n```\n有了这个类，就可以通过类去制造一个对象,并让对象去实现一些功能\n```java\npublic class Main {\n    public static void main(String[] args) {\n        //制作一个对象\n        VendingMachine vm = new VendingMachine();\n        boolean t = true;\n        vm.showPromot();\n        vm.showBalance();\n        while (t) {\n            vm.insertMomey();\n            vm.getFood();\n            vm.showBalance();\n            vm.showTotal();\n        }\n    }\n}\n```\n运行结果：  \n```\n欢迎！\n现在余额： 0\n请充值余额：100\n给你。\n现在余额： 20\n目前总收入：80\n请充值余额：20\n没有足够的余额！\n现在余额： 40\n目前总收入：80\n请充值余额：40\n给你。\n现在余额： 0\n目前总收入：160\n请充值余额：\n```\n\n## 创建对象\n使用new运算符，来创建这个类的一个对象  \n然后将这个对象交给这个类型的一个变量  \nVendingMachine vm = new VendingMachine();  \n\n**对象变量是对象的管理者**  \n\n## 让对象做事情\n使用 . 运算符  \nvm.insertMomey();  \nvm.getFood();  \n通过.运算符调用某个对象的方法  \n\n## 成员变量、成员方法\n类定义了**对象中**所具有的变量，这些变量称作成员变量  \n每个对象有自己的变量，和同一个类的其他对象是分开的  \n在方法中可以直接写成员变量（方法）的名字来访问成员变量（方法）（省去了this关键字）  \n\njava会给成员变量默认0值\n\n成员变量（方法）分为实例变量（方法）和类变量（方法）  \n加了static的就是类变量（方法）  \n\n### 类变量\n声明类变量： **static** <类型> <变量名>  \n\n访问类变量：  \n通过对象访问：<对象名>.<类变量名>  \n通过类访问：<类名>.<类变量名>  \n\n类变量不属于任何一个对象，属于这个类，但任何一个对象都拥有这个变量  \n\n修改类变量的值，所有对象中的该变量的值都会改变  \n\n类变量的初始化只会进行一次（在类的装载时）  \n\n### 类方法\n声明类方法： **static** <返回类型> <方法名>() {  }  \n\nstatic方法只能调用static方法，只能访问static变量   \n\n类方法可以通过类的名字去访问，也可以通过对象去访问  \n\n\n## 本地（局部）变量\n定义在**方法内部**的变量是本地变量  \n本地变量的生存期和作用域都是方法内部  \n\n本地变量没被赋值，会被禁止使用  \n\n成员变量的生存期是对象的生存期，作用域是类内部的成员方法 \n\n### var局部变量\n使用var时必须指出初始值(不可以是null)  \nvar <变量名> = <值>;  \n编译器可以推断出该变量的类型，且之后该变量的类型都是确定的，不可以给该变量赋其它类型的值\n\n## 对象初始化\n可以在定义成员变量的地方直接赋值  \nint price = 80;  \n\n在创建一个对象的过程中，会首先去做各种初始化的动作\n\n### 构造方法\n与类同名的函数，没有返回值  \n在创建一个对象时会自动调用的方法\n应该是public\n```java  \nVendingMachine(){\n    total = 10;\n}\n\nVendingMachine(int price ){\n    this.price = price;\n}\n```\n### 方法重载\n一个类里可以有多个**不同参数**的构造方法  \n创建对象的时候给出不同的参数值，就会自动调用不同的构造方法  \n通过this()还可以在构造方法中调用其他构造方法，写在第一行，且只能使用一次    \n一个类里的同名但参数表不同的方法构成了重载关系  \n\n## 对象的识别\n通过巧妙的思想，识别不同出对象的特点，让类更通用  \n例如，要实现一个时钟  \n可以设计一个类，通过这个类可以制造出时、分、秒三个对象  \n\n## 对象的交互\n时、分、秒三个对象可以共同组成一个时钟对象  \n控制时、分、秒之间的交互在时钟对象的方法中完成  \n```java Display.java\npublic class Display {\n    private int value = 0;\n    private int limit = 0;\n\n    public Display(int limit){\n        this.limit = limit;\n    }\n\n    public void increase(){\n        value++;\n        if(value == limit){\n            value = 0;\n        }\n    }\n\n    public int getValue(){\n        return value;\n    }\n\n}\n```\n\n```java Clock.java\npublic class Clock {\n    Display hour = new Display(24);\n    Display minute = new Display(60);\n    Display second = new Display(60);\n\n    public void start() {\n        while (true) {\n            second.increase();\n            if (second.getValue() == 0) {\n                minute.increase();\n                if (minute.getValue() == 0) {\n                    hour.increase();\n                }\n            }\n            System.out.printf(\"%02d:%02d:%02d\\n\", hour.getValue(), minute.getValue(), second.getValue());\n        }\n    }\n}\n```\n\n```java Main.java\npublic class Main {\n    public static void main(String[] args) {\n        Clock clock = new Clock();\n        clock.start();\n    }\n}\n```\n\n***\n\n# 访问属性\n**private**：这个成员是私有的，只有在类的内部（成员方法和定义初始化 ）才能访问  \n一般来说，成员变量都该是private   \n**这个限制是对类的而不是对对象的**：同一个类的不同对象可以互相访问对方的成员变量  \n\n**public**：任何人都可以访问  \n任何人指的是在任何类的方法或定义初始化中可以使用  \n使用指的是调用、访问或定义变量  \n很多的成员方法都是public \npublic的类，类名和文件名要一致，一个编译单元只能有一个public的类  \n\n**protected**：受保护的成员  \n\n**friendly**：默认属性，友好的成员  \n\n| 访问属性  | 本类    | 同包       | 子类      |   其它  |\n| -----    | ------ | --------- | ------   |   ---  |\n| private  |   √    |           |          |        |\n| friendly |     √  |   √       |          |        |\n| protected|   √    |     √     |     √    |        |\n| public   |     √  |     √     |      √   |   √    |\n\n***\n\n# 包package\n包是java管理类的一个机制  \n源文件中同名类要在**不同**包内  \n\n声明该类的指定包名  \npackage <包名>;  \n\n包名中的.代表文件夹的层次  \n\n没有package语句的源程序都将视为在同一个无名包内  \n\n## import\n使用import语句引入包中的类和接口  \n\nimport test.Hallo  \ntest包中的Hallo类  \n\n只要用到的类和本类不在同一个包内，就要import它  \n\n如果不使用import，当要用到类时要给出全名：<包名>.<类名>  \n\n引入一个包内的所有东西：import <包名>.*;（注意同名类的冲突） \n\n***\n# NoteBook例子\n记事本可以做什么？  \n1、能存储记录  \n2、不限制能存储的记录的数量  \n3、能知道已经存储的记录的数量  \n4、能查看存进去的每一条记录  \n5、能删除一条记录  \n6、能列出所有的记录  \n\n确定需求后，进行接口设计  \n```java 接口设计\npublic class NoteBook {\n\n    public void add(String s) {\n        //添加内容\n    }\n\n    public int getSize() {\n        //放了多少个\n        return 0;\n    }\n\n    public String getNote(int index) {\n        //得到指定位置的内容\n        return \" \";\n    }\n\n    public boolean removeNote(int index) {\n        //删除\n        return true;\n    }\n\n    public String[] list() {\n        //返回全部内容\n    }\n\n}\n\n```\n接口设计完，考虑实际功能的实现，首先是数据的存放  \n\n## 顺序容器\n```java\nprivate ArrayList<String> notes = new ArrayList<String>();  \n```\n用来存放String的一个ArrayList  \nArrayList内的东西是有顺序的，是加入数据的顺序，形成对应下标的索引（从0开始）  \n\n这种类型叫做范型类：泛型类封装不特定于特定数据类型的操作  \n这种范型类是一种容器  \n\n容器类有两个类型：容器的类型、元素的类型  \n\n利用容器类的方法可以实现需要的功能  \nnotes.add(s);  //向容器添加数据\nnotes.size();  //容器存了多少个东西\nnotes.get(1); //得到1位置处的数据\n\n完成全部功能接口\n```java NoteBook.java\nimport java.util.ArrayList;\n\npublic class NoteBook {\n    private ArrayList<String> notes = new ArrayList<String>();//容器类\n\n    public void add(String s) {\n        //添加内容\n        notes.add(s);\n    }\n\n    public void add(String s, int location) {\n        //加到指定位置前，后面的内容下标后推\n        notes.add(location, s);\n    }\n\n    public int getSize() {\n        //放了多少个\n        return notes.size();\n    }\n\n    public String getNote(int index) {\n        //得到指定位置的内容\n        return notes.get(index);\n    }\n\n    public void removeNote(int index) {\n        //删除，后面下标前移，因为remove方法自会抛异常，所以无需返回boolean\n        notes.remove(index);\n    }\n\n    public String[] list() {\n        //返回全部内容\n        String[] a = new String[notes.size()];\n\n        //for (int i=0; i< notes.size(); i++){\n        //    a[i] = notes.get(i);\n        //}\n        notes.toArray(a);//会自己把数组按顺序填好\n        //要熟悉系统类库里有的方法，无需重复造轮子\n        return a;\n    }\n\n}\n```\n写出上层程序\n```java Main.java\npublic class Main {\n    public static void main(String[] args) {\n        NoteBook nb = new NoteBook();\n\n        nb.add(\"first\");\n        nb.add(\"second\");\n        System.out.println(nb.getSize());\n        System.out.println(nb.getNote(1));\n\n        nb.add(\"third\", 1);\n        System.out.println(nb.getNote(1));\n        System.out.println(nb.getNote(2));\n        System.out.println(nb.getSize());\n\n        nb.removeNote(1);\n        String[] b = nb.list();\n        for (String s : b) {\n            System.out.println(s);\n        }\n    }\n\n}\n\n```\n输出：\n```\n2\nsecond\nthird\nsecond\n3\nfirst\nsecond\n```\n\n## 对象数组\n```java\nString[] a = new String[notes.size()];  \n```\n对象数组中的每个元素都是对象的管理者而非对象本身  \n当创建了一个对象数组，只是管理者们被创建了，但对象还没有，得想办法把每个对象创建出来  \n\n### for-each循环\n对于普通数组：  \n```java\nint[] a = new int[10];\nfor (int i = 0; i < a.length; i++) {\n    a[i] = i;//赋值\n}\nfor ( int k : a ) {\n    System.out.println(k);\n    k++;//每个k都是a中元素的复制品，不会起作用\n}\n```\n对于对象数组：  \n```java\nValue[] a = new Value[10]; \nfor (int i=0; i< 10; i++){\n    a[i] = new Value[];\n    a[i].set(i);\n}\nfor ( Value v : a ){\n    System.out.println(v.get());\n    v.set(0);//起作用，因为对象数组存的是对象管理者，v=a[i]，v也会成为对象管理者\n}\n```\n\n\n## 集合容器\n集合容器内所有元素都不相同  \n而且里面的元素不排序  \n```java\nHashSet<String> s = new HashSet<String>();\ns.add(\"first\");\ns.add(\"second\");\ns.add(\"first\");\nSystem.out.println(s);//容器都可以这样输出\n```\n输出：\n```java\n[second, first]\n```\n\n## public String toString\n在java中只要类中实现了这样一个方法  \n就可以直接用对象名输出这个对象  \n容器当中都有这样一个方法 \n```java\npublic String toString(){  \n    return \"\";  \n}  \n```\n\n## Hash表\n例子：数字与美元硬币名字对应，查找硬币名称  \n1=penny  \n5=nickel  \n10=dime  \n25=quarter  \n50=half-dollar\n\n定义接口：\n```java\npublic class Coin {\n    public String getName(int amount){\n            return  \"\";\n    }\n}\n```\n为什么不用switch-case？  \n体现在代码中的硬编码越少越好  \n\n使用Hash表（一种数据结构）  \n在这个表中，所有东西是以一对值放入的，一个叫做key（键），一个叫做值  \n一个key对应一个值，可以用key取值  \nHash表中的元素没有顺序  \n```java Coin.java\nimport java.util.HashMap;\n\npublic class Coin {\n    //不能使用int，容器当中所有的类型都得是对象,而不能是基本类型\n    //Integer是int的包裹类型\n    private HashMap<Integer, String> coinnames = new HashMap<Integer, String>();\n\n    public Coin(){\n        coinnames.put(1, \"penny\");//1对应penny\n        coinnames.put(10, \"dime\");\n        coinnames.put(25, \"quarter\");\n        coinnames.put(50, \"half-dolar\");\n        \n        System.out.println(coinnames.keySet().size());//keySet()，把所有key做为一个HashSet的集合给你，在这个集合可以得到size\n        System.out.println(coinnames);//也可以直接输出\n        coinnames.put(50, \"五十\");//会替换掉前面的\n        System.out.println(coinnames);\n        for (Integer k : coinnames.keySet()){//遍历Hash表\n            String s = coinnames.get(k);\n            System.out.println(s);\n        }\n    }\n\n    public String getName(int amount){\n        if (coinnames.containsKey(amount))\n            return coinnames.get(amount);\n        else\n            return  \"NOT FOUND\";//不判断的话，不存在会返回null\n    }\n\n\n}\n```\n```java Main.java\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int amount = in.nextInt();\n        Coin coin = new Coin();\n        String name = coin.getName(amount);\n        System.out.println(name);\n    }\n}\n```\n输出：\n```java\n10\n4\n{1=penny, 50=half-dolar, 25=quarter, 10=dime}\n{1=penny, 50=五十, 25=quarter, 10=dime}\npenny\n五十\nquarter\ndime\ndime\n```\n\n***\n\n# 继承与子类\n\n## 媒体资料库设计\n和NoteBook一样，需要设计一个类,用类去表达一种媒体（CD,DVD）  \n然后用一个媒体类的容器去装媒体对象，一个资料库就完成了  \n\nCD有什么？  \n名称：title  \n艺术家：artist  \n多少首歌：numofTracks  \n持续时间：playingTime  \n是否被借出：gotIt  \n描述：comment  \n\n能做什么？\n输出一些信息：print\n\n```java CD.java\npublic class CD{\n    private String title;\n    private String artist;\n    private int numofTracks;\n    private int playingTime;\n    private boolean gotIt = false;\n    private String comment;\n\n    public CD(String title, String artist, int numofTracks, int playingTime, String comment) {\n        this.title = title;\n        this.artist = artist;\n        this.numofTracks = numofTracks;\n        this.playingTime = playingTime;\n        this.comment = comment;\n    }\n\n    public void print() {\n        System.out.print(\"CD:\");\n        System.out.print(title+\":\");\n        System.out.println(artist);\n    }\n}\n```\n```java Database.java\nimport java.util.ArrayList;\n\npublic class Database {\n    private ArrayList<CD> listCD = new ArrayList<CD>();\n\n    public void add(CD cd){\n        listCD.add(cd);\n    }\n\n    public void list(){\n        for (CD cd : listCD){\n            cd.print();\n        }\n    }\n\n    public static void main(String[] args) {\n        Database db = new Database();\n        db.add(new CD(\"abc\",\"aaa\",4,60,\"bb\"));\n        db.add(new CD(\"adc\",\"dgh\",5,40,\"ak\"));\n        db.list();\n    }\n}\n```\n现在资料库中已经可以存各种CD媒体了  \n但我们还想在资料库中存DVD媒体或者其它媒体类型  \n\n当然，我们可以再创建一个类表示DVD\n```java DVD.java\npublic class DVD{\n    private String title;\n    private String director;\n    private int playingTime;\n    private boolean gotIt = false;\n    private String comment;\n\n    public DVD(String title, String director, int playingTime, String comment) {\n        this.director = director;\n        this.title = title;\n        this.playingTime = playingTime;\n        this.comment = comment;\n    }\n\n    public void print() {\n        System.out.print(\"DVD:\");\n        System.out.print(title+\":\");\n        System.out.println(director);\n    }\n}\n```\n设计好类后在Database.java里创建一个放DVD的容器,以及配套的方法    \n```java Database.java\nimport java.util.ArrayList;\n\npublic class Database {\n    private ArrayList<CD> listCD = new ArrayList<CD>();\n    //+\n    private ArrayList<DVD> listDVD = new ArrayList<DVD>();\n\n    public void add(CD cd){\n        listCD.add(cd);\n    }\n    //+\n    public void add(DVD dvd){\n        listCD.add(dvd);\n    }\n\n    public void list(){\n        for (CD cd : listCD){\n            cd.print();\n        }\n        //+\n        for(DVD dvd : listDVD){\n            dvd.print();\n        }\n    }\n\n    public static void main(String[] args) {\n        Database db = new Database();\n        db.add(new CD(\"abc\",\"aaa\",4,60,\"bb\"));\n        db.add(new CD(\"adc\",\"dgh\",5,40,\"ak\"));\n        //+\n        db.add(new DVD(\"add\",\"eee\",45,\"qqq\"));\n        db.list();\n    }\n}\n```\n现在资料库中能存放两种媒体  \n运行一下： \n```java 输出\nCD:abc:aaa\nCD:adc:dgh\nDVD:add:eee\n```\n上面发生了什么？  \n我们创建了一个资料库类  \n资料库类里有两个容器，用来存放两种不同类型的媒体的对象管理者  \n\n<div><img src=/images/7-1.webp width=\"70%\" height=\"70%\"></div>\n\n这样的结构虽然能实现我们需要的功能，但DVD和CD类几乎一模一样   \n出现了很多代码复制，这是代码质量不良的表现  \n当我们需要修改print，add等方法，就得逐个去改  \n当我们需要新增一种媒体，就得为它做很多的工作  \n\n## 继承\nCD和DVD类很相似，我们可以从中提取一些它们共有的东西封装成一个类Item  \nItem可以表达CD或者DVD  \n而Database只需管Item  \n\n```java Item.java\npublic class Item {\n    private String title;\n    private int playingTime;\n    private boolean gotIt = false;\n    private String comment;\n\n    public Item(String title, int playingTime, boolean gotIt, String comment) {\n        this.title = title;\n        this.playingTime = playingTime;\n        this.gotIt = gotIt;\n        this.comment = comment;\n    }\n\n    public Item(){\n\n    }\n\n    public void print() {\n        System.out.print(title+\":\");\n    }\n\n}\n```\n```java CD.java\npublic class CD extends Item{\n//    private String title;\n    private String artist;\n    private int numofTracks;\n//    private int playingTime;\n//    private boolean gotIt = false;\n//    private String comment;\n\n    public CD(String title, String artist, int numofTracks, int playingTime, String comment) {\n        super(title, playingTime, false, comment);\n//        this.title = title;\n        this.artist = artist;\n        this.numofTracks = numofTracks;\n//        this.playingTime = playingTime;\n//        this.comment = comment;\n    }\n\n    public void print() {\n        System.out.print(\"CD:\");\n        super.print();\n        System.out.println(artist);\n    }\n}\n```\n```java DVD.java\npublic class DVD extends Item{\n//    private String title;\n    private String director;\n//    private int playingTime;\n//    private boolean gotIt = false;\n//    private String comment;\n\n    public DVD(String title, String director, int playingTime, String comment) {\n        super(title, playingTime, false, comment);\n        this.director = director;\n//        this.title = title;\n//        this.playingTime = playingTime;\n//        this.comment = comment;\n    }\n\n    public void print() {\n        System.out.print(\"DVD:\");\n        super.print();\n        System.out.println(director);\n    }\n}\n```\n```java Database.java\nimport java.util.ArrayList;\n\npublic class Database {\n//    private ArrayList<CD> listCD = new ArrayList<CD>();\n//    private ArrayList<DVD> listDVD = new ArrayList<DVD>();\n    private ArrayList<Item> listItem = new ArrayList<Item>();\n\n//    public void add(CD cd){\n//        listCD.add(cd);\n//    }\n//\n//    public void add(DVD dvd){\n//        listCD.add(dvd);\n//    }\n    public void add(Item item){\n        listItem.add(item);\n    }\n\n    public void list(){\n//        for (CD cd : listCD){\n//            cd.print();\n//        }\n//        for(DVD dvd : listDVD){\n//            dvd.print();\n//        }\n        for (Item item : listItem){\n            item.print();\n        }\n    }\n\n    public static void main(String[] args) {\n        Database db = new Database();\n        db.add(new CD(\"abc\",\"aaa\",4,60,\"bb\"));\n        db.add(new CD(\"adc\",\"dgh\",5,40,\"ak\"));\n        db.add(new DVD(\"add\",\"eee\",45,\"qqq\"));\n        db.list();\n    }\n}\n```\n运行一下： \n```java 输出\nCD:abc:aaa\nCD:adc:dgh\nDVD:add:eee\n```\n上面发生了什么？  \nCD extends Item：CD扩展了Item  \n即CD变成了Item的子类  \n这就是**继承**  \nCD得到了Item里所有的东西  \n\n<div><img src=/images/7-2.webp width=\"70%\" height=\"70%\"></div>\n\n## 子类与父类\n当父类里的东西是private时  \nprivate String title;  \n子类得到了这个东西，但不能用（可以通过父类的方法去用）  \n解决办法：将private改成protect  \n但这样不好，有很多时候父类和子类不在同一个包内  \n\ntitle本来就是父类的东西  \n可以让title在父类中初始化完，再让子类得到title  \n```java\npublic Item(String title) {\n    this.title = title;\n}\n```\n在子类构造器中使用super()来得到父类的title  \n```java\n public CD(String title) {\n    super(title);\n}\n```\n\n### super()\n当程序初始化对象时，会先运行super()  \n然后去运行父类的构造器，再回来继续运行自己的构造器  \n\nsuper():去父类调用一个没有参数的构造器  \nsuper(<参数>):去父类调用一个有对应参数的构造器  \n\n当子类没有super(),会默认去调用父类没有参数的构造器  \n\n通过super关键字来实现对父类成员的访问，用来引用当前对象的父类  \nsuper.<父类成员>  \n\n通过this来区分子类父类中的同名成员  \nthis.aaa();   // this 调用自己的方法  \nsuper.aaa();  // super 调用父类方法  \n\n## 子类和子类型\n类定义了类型  \n子类定义了子类型  \n\n子类的对象可以被当作父类的对象来使用  \n-赋值给父类的变量（父类的对象管理者可以管理子类的对象）  \n<div><img src=/images/7-3.webp width=\"70%\" height=\"70%\"></div>\n\n-传递给需要父类对象的方法  \n\n\n-放进存放父类对象的容器里  \n<div><img src=/images/7-4.webp width=\"70%\" height=\"70%\"></div>\n\n<div><img src=/images/7-5.webp width=\"35%\" height=\"35%\"></div>\n\n***\n\n# 多态\n## 多态变量\n所有的**对象变量**都是**多态**的（它们能保存不止一种类型的对象，不同时刻可以放不同类型的对象（例如父类的对象变量放子类的对象））  \n它们可以保存的是声明类型的对象，或声明类型的子类的对象  \n\n当把**子类的对象**赋给**父类的变量**的时候，就发生了**向上造型**  \n\n每一个java的对象变量，都具有两个类型  \n一个是**声明类型**  \n一个是**动态类型**  \n有时候两者是一致的，有时候又不一样  \n\n这就是变量的多态（在运行过程中，它所管理的对象类型是会变化的）  \n\n## 造型\n造型：把一个类型的**对象**，赋给另一个类型的**变量**\n\n对象变量的赋值并不是把一个对象赋给另一个对象（注在c++中可以做两个对象之间的赋值）  \n而是让这两个对象的管理者去**管理同一个对象**  \n```java\nString s = \"hello\";\n//原本这个String类型的对象变量s管理着一个对象\n//这个对象里面有个\"hello\"\ns = \"bye\";\n//后来s去管理另一个对象，里面有\"bye\"\n```\n并不是将bye替换掉hello，java不能做这种事  \n\njava中”=“的赋值运算，实际上是在改变指向  \n```java\nString s = \"hello\";\nString t = \"bye\";\ns = t;\n//原本s和t各管理一个对象，现在s和t管理同一个对象，里面有”hello“\n```\n当给一个**对象变量**管理着与它声明（静态）类型**不符**的对象时，就发生了**造型**  \n```java CD是Item的子类\nCD cd = new CD(\"abc\",\"aaa\",4,60,\"bb\");\nItem item = cd;\n//把子类的对象赋给父类的变量，让父类的对象变量去管理子类的对象\n```\n父类对象是不能直接赋给子类对象变量的\n但可以强制把父类对象当成子类的对象，然后去造型  \n```java CD是Item的子类\nCD cd = new CD(\"abc\",\"aaa\",4,60,\"bb\");\nItem item = cd;\nCD cc = item;//不行。父类对象不能直接交给子类对象变量去管理\nCD cc = (CD)item;//行，因为item已经管理着一个CD的对象了\n//强制把item的类型当做CD\n```\n如果没有Item item = cd;\n```java CD是Item的子类\nCD cd = new CD(\"abc\",\"aaa\",4,60,\"bb\");\n//Item item = cd;\nCD cc = (CD)item;//编译可以通过，但运行会出错\n```\n将一个变量强制造型成另一个类型，然后赋给另一个变量  \nCD cc = (CD)item;  \n只有当item这个变量**实际管理**着CD类型的对象才不会出错  \n\n在C语言中，有类似写法，但是是类型转换（对于基本类型int、double，java也能强制类型转换）  \nint i = (int)10.2;//强制类型转换\n这与造型是不同的  \n类型转换是将10.2变成了10  \n但造型只是把item当做CD类型来看待  \nitem本身还是Item类型  \n\n(类型名)对象名：将一个对象当做这个类型来看待  \n\n### 向上造型\n向上造型是特殊的造型，无需写(父类类型)  \n拿一个子类的对象，当作父类的对象来用  \n向上造型总是安全的  \n\n## 方法调用的绑定\n```java\npublic void list(){\n    for (Item item : listItem){\n        item.print();\n    }\n}\n```\nitem每次循环管理的对象不一样，甚至管理的对象的类型也不一样，可以是CD或是DVD  \n当item管理CD(DVD)类型的对象时，去调用print方法，调用的是CD(DVD)类型里的print  \n\n\n当通过对象变量调用方法的时候，调用哪个方法这件事情叫做绑定  \n-静态绑定：根据变量的声明类型来决定  \n-动态绑定：根据变量的动态类型来决定  \n在成员函数中调用其他成员函数也是通过this这个对象变量来调用的  \n\njava默认所有的绑定都是动态绑定  \n\n### 覆盖\n子类和父类中存在**名称和参数表**完全相同的函数，这一对函数构成**覆盖**关系  \n通过父类的变量调用存在覆盖关系的函数时，调用变量当时所**管理的对象**所属的类的函数  \n这是一种动态绑定  \n\n## 多态总结\n多态性是对象多种表现形式的体现  \n\n通过一个变量去调用一个函数，我们不去判断变量运行中实际类型是什么，我们只想它能print  \n多态是**同一个行为**具有多个**不同表现形式或形态**的能力  \nitem是CD类型时它这样print，是DVD类型时那样print，但都是print行为  \n\n***\n\n# 类型系统\n\n## Object类\njava中所有类都是Object类型的子类  \n这是一种单根结构  \n<div><img src=/images/7-6.webp width=\"70%\" height=\"70%\"></div>\n\n发生继承时，父类所有public的东西子类都会得到  \n所以java中所有的类，都从Object类中得到了两个函数  \n-toString()  \n-equals()  \n\n## toString()\ntoString()会返回一个字符串，用来表达对象  \n\n当一个类中没有toString()方法时，会调用继承自Object类的toString()  \n```java\nCD cd = new CD(\"abc\",\"aaa\",4,60,\"bb\");\nSystem.out.println(cd.toString());\nSystem.out.println(cd);//和上面的效果一个月，编译器会知道这个地方需要调用toString()\n\nString s = \"aa\"+cd;//编译器知道这个地方需要调用toString()\nSystem.out.println(s);\n```\n```java 输出\nCD@3d075dc0\n//类型名+一个类似地址、编号的东西\nCD@3d075dc0\naaCD@3d075dc0\n```\n显然，默认的表达这个对象的toString(),是返回一个类型名+一个类似地址、编号的东西  \n\n我们可以在类中自定义一个toString()  \n即设计一个表达对象的toString()  \n```java\n@Override\npublic String toString() {\n    return \"CD{\" +\n            \"artist='\" + artist + '\\'' +\n            \", numofTracks=\" + numofTracks +\n            '}';\n    }\n```\n```java 输出\nCD{artist='aaa', numofTracks=4}\n```\n\n## equals()\n\n==**无法**比较两个对象的内容是否相同，只能比较这两个对象变量是否管理着同一个对象    \n我们需要使用equals()去比较内容  \n\n当类中没有equals()，会调用继承自Object类的equals()  \n```java\nCD cd1 = new CD(\"abc\",\"aaa\",4,60,\"bb\");\nCD cd2 = new CD(\"abc\",\"aaa\",4,60,\"bb\");\nSystem.out.println(cd1.equals(cd2));\n```\n```java 输出\nfalse\n```\nObject这个公共父类的equals()无法知道它的子类长什么样子，所以也无法比较这两个对象内容是否相等  \nObject的equals()实际上也是在比较两个对象变量是否管理着同一个对象\n\n我们需要使用自定义的equals()去比较内容  \n```java\n@Override\npublic boolean equals(Object o) {\n    CD cc = (CD) o;//将Object o看作是CD类型的\n    return numofTracks == cc.numofTracks && artist.equals(cc.artist);\n}\n```\n```java 输出\ntrue\n```\n\n## @Override\n作用：告诉编译器，这个函数覆盖了父类的同属性、同名、同参方法  \n也可能会在代码界面报错，如果这个函数没有和父类的同名方法有相同属性、参数\n\n不带@Override，如果自定义的equals()和父类的同属性、同名、同参  \n那么也会覆盖掉父类的，@Override只是起帮助检查作用  \n\n***\n\n# 可扩展性\n现在要往Database这个资料库里增加新的媒体类型，是一件非常容易的事情    \n```java VideoGame.java\npublic class VideoGame extends Item {\n    private int numberofPlayers;\n\n    public VideoGame(String title, int playingTime, boolean gotIt, String comment, int numberofPlayers) {\n        super(title, playingTime, gotIt, comment);\n        this.numberofPlayers = numberofPlayers;\n    }\n\n    public void print() {\n        System.out.print(\"VideoGame:\");\n        super.print();\n        System.out.println(numberofPlayers);\n    }\n}\n```\n<div><img src=/images/7-7.webp width=\"70%\" height=\"70%\"></div>\n\n只需要增加一个子类，然后构造一下，覆盖下方法，父类完全不需要去动  \n这种特性叫**可扩展性**：代码无需修改即可扩展去适应新的数据、新的内容  \n\n如果需要修改去适应新的数据、新的内容，则叫**可维护性**  \n\n***\n\n>下接[JAVA/面向对象学习笔记(2)](https://www.chuckle.top/article/9f2dc6c7.html)","tags":["JAVA","JavaSE"],"categories":["学习笔记"]},{"title":"C语言单链表菜品管理系统","url":"/article/a696e8fe.html","content":"\n# 简介\n我的大一上学期期末项目，也是C语言的期末大作业。  \n\n使用单链表进行菜品信息的存储，系统有菜品的增删改查、排序、安全输入、统计、随机输出和文件输入输出等功能。 \n\n现在回去看代码想给自己一锤子（误）\n\n***\n\n# 包含文件\n<div><img src=/images/6-8.webp width=\"70%\" height=\"70%\"></div>\n\n***\n\n# 函数说明\n<div><img src=/images/6-9.webp width=\"70%\" height=\"70%\"></div>\n<div><img src=/images/6-10.webp width=\"70%\" height=\"70%\"></div>\n\n***\n# 代码\n```c 900行有点长\n#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <string.h>\n#include <time.h>\n#include <windows.h>\n\n#define SIZE1 100 //名称，价格等字数\n#define SIZE2 200 //限制评价字数\n\ntypedef struct _node\n{\t\t\t\t\t\t\t//链表的节点结构体\n\tchar name[SIZE1];\t\t//菜品名称\n\tchar restaurant[SIZE1]; //饭店名字\n\tfloat price;\t\t\t//菜的价格\n\tint fraction;\t\t\t//菜的评分\n\tchar comment[SIZE2];\t//菜品评价\n\tstruct _node *next;\n} Node;\ntypedef struct _list //方便对链表操作\n{\n\tNode *head;\n\tNode *pa;\n\tNode *pb;\n\tNode *pc;\n} List;\n//菜单\nvoid menu(void);\t\t\t   //一级菜单\nvoid menu_inquire(List *list); //二级菜单_查询菜单\nvoid help(void);\t\t\t   //二级菜单_帮助菜单\nint menu_sort(List *list);\t   //三级菜单_排序方法\n//对节点操作\nvoid add(List *list);\t  //添加节点\nvoid delete (List *list); //删除节点\nvoid revise(List *list);  //修改节点\n//安全输入\nchar *s_gets(char *st, int n); //安全输入字符\nint get_int(void);\t\t\t   //安全输入int型\nfloat get_float(void);\t\t   //安全输入float型\n//链表的输出和操作\nvoid inquire_all(List *list);\t\t\t//输出链表全部节点\nvoid inquire_one(List *list);\t\t\t//输出链表指定菜名节点\nvoid inquire_restaurant(List *list);\t//输出链表指定饭店节点\nvoid inquire_part_price(List *list);\t//输出一定价格以下的菜品(这功能。。贫穷)\nvoid inquire_part_fraction(List *list); //输出一定评分以上的菜品\nvoid average_percentage(List *list);\t//查询某饭店或食堂的平均价格和评分\nvoid output(Node *p);\t\t\t\t\t//方便输出\nvoid random_menu(List *list);\t\t\t//随机输出一道菜\nvoid empty(List *list);\t\t\t\t\t//清空链表\n//文件操作\nvoid save(List *list);\t   //保存\nvoid read_txt(List *list); //读取文件_初始链表\n//单链表的排序\nvoid sort_ascending(List *list);\t\t //菜品按价格从低到高排序\nvoid sort_descending(List *list);\t\t //菜品按价格从高到低排序\nvoid sort_score(List *list);\t\t\t //菜品按评分从高到低排序\nint calculate(List *list);\t\t\t\t //计算出单链表的节点个数\nvoid swap1(List *list, List *list_swap); //单链表冒泡排序的算法块1\nvoid swap2(List *list, List *list_swap); //单链表冒泡排序的算法块2\n//其他\nint random_number(List *list); //随机生成不大于节点数的整数\nvoid color(int a);\t\t\t   //控制台文本颜色\n//______________________________________________________\n//------------------------------------------------------\nint main() //主函数\n{\n\t//system(\"chcp 65001\");//GB2313\n\t//system(\"chcp 936\");//UTF8\n\t//system(\"cls\");\n\tmenu(); //输出功能菜单\n\t//佛祖开光无bug\n\treturn 0;\n}\n//菜单\nvoid menu() //一级菜单\n{\n\tint options, z = 1;\n\tList list;\n\tlist.head = NULL;\t\t\t\t   //head指向空，链表不存在\n\tFILE *fp = fopen(\"Menu.txt\", \"a\"); //若无Menu.txt文件，则创建一个\n\tfclose(fp);\n\tread_txt(&list); //读入txt中的数据，初始化链表\n\twhile (z)\n\t{\n\t\tsystem(\"cls\");\n\t\tprintf(\"\\n\");\n\t\tcolor(2);\n\t\tprintf(\"|-----------------------------------------------------\\n\");\n\t\tcolor(14);\n\t\tprintf(\"|                    菜品信息系统             \\n\");\n\t\tcolor(2);\n\t\tprintf(\"|-----------------------------------------------------\\n\");\n\t\tcolor(11);\n\t\tprintf(\"|********************系统功能菜单*********************\\n\");\n\t\tcolor(2);\n\t\tprintf(\"|-----------------------------------------------------\\n\");\n\t\tcolor(15);\n\t\tprintf(\"|*******************|1、使用帮助|                       \\n\");\n\t\tprintf(\"|*******************|2、添加菜品信息|                    \\n\");\n\t\tprintf(\"|*******************|3、删除菜品信息|                    \\n\");\n\t\tprintf(\"|*******************|4、查询菜品信息|                    \\n\");\n\t\tprintf(\"|*******************|5、修改菜品信息|                    \\n\");\n\t\tprintf(\"|*******************|6、今天吃什么|                     \\n\");\n\t\tprintf(\"|*******************|7、清空所有数据|                     \\n\");\n\t\tprintf(\"|*******************|8、保存|\\n\");\n\t\tcolor(2);\n\t\tprintf(\"|-----------------------------------------------------\\n\");\n\t\tcolor(15);\n\t\tprintf(\"|*******************|0、退出系统|                       \\n\");\n\t\tcolor(12);\n\t\tprintf(\"|!!!前请先保存再退出系统,否则数据会丢失!!!\\n\");\n\t\tcolor(2);\n\t\tprintf(\"|-----------------------------------------------------\\n\");\n\t\tcolor(11);\n\t\tprintf(\"请输入功能序号：\");\n\t\tcolor(15);\n\t\toptions = get_int();\n\t\tswitch (options)\n\t\t{\n\t\tcase 0:\n\t\t\tz = 0; //跳出循环\n\t\t\tprintf(\"即将退出系统。\\n\");\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\thelp();\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tadd(&list);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tdelete (&list);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tmenu_inquire(&list);\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\trevise(&list);\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\trandom_menu(&list);\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tempty(&list);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tsave(&list);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcolor(12);\n\t\t\tprintf(\"无该功能，请重新输入\\n\");\n\t\t\tcolor(11);\n\t\t\tsystem(\"pause\");\n\t\t\tcolor(15);\n\t\t}\n\t}\n\tsystem(\"pause\");\n}\nvoid help() //二级菜单_帮助菜单\n{\n\tsystem(\"cls\");\n\tprintf(\"\\n\");\n\tcolor(2);\n\tprintf(\"|-----------------------------------------------------------------\\n\");\n\tcolor(15);\n\tprintf(\"|使用帮助：\\n\");\n\tprintf(\"|1、本菜品信息系统可供用户自行修改内容\\n\");\n\tprintf(\"|2、因为考虑到不同饭店有同样名称的菜品，本系统允许菜品名称有重复\\n\");\n\tprintf(\"|3、请勿输入错误信息，以免造成程序出错\\n\");\n\tprintf(\"|4、关闭系统前记得保存！否则数据会丢失\\n\");\n\tprintf(\"|5、有bug联系1934009145@qq.com\\n\");\n\tprintf(\"|6、github地址:github.com/qxchuckle/Dishes-Management-System\\n\");\n\tcolor(2);\n\tprintf(\"|-----------------------------------------------------------------\\n\");\n\tprintf(\"\\n\");\n\tcolor(11);\n\tsystem(\"pause\");\n}\nvoid menu_inquire(List *list) //二级菜单_查询菜单\n{\n\tint options, z = 1;\n\tList *p = list;\t\t\t//方便传结构体指针\n\tif (list->head == NULL) //判断链表是否为空\n\t{\n\t\tcolor(12);\n\t\tprintf(\"还未存入任何菜品！无法查询！\\n\");\n\t\tcolor(11);\n\t\tsystem(\"pause\");\n\t\treturn; //为空结束函数\n\t}\n\twhile (z)\n\t{\n\t\tsystem(\"cls\");\n\t\tprintf(\"\\n\");\n\t\tcolor(2);\n\t\tprintf(\"|-----------------------------------------------------\\n\");\n\t\tcolor(15);\n\t\tprintf(\"|1、查询全部菜品信息\\n\");\n\t\tprintf(\"|2、按菜名查询菜品信息\\n\");\n\t\tprintf(\"|3、查询饭店或食堂的全部菜品信息\\n\");\n\t\tprintf(\"|4、查询某价格以下的全部菜品\\n\");\n\t\tprintf(\"|5、查询某评分以上的全部菜品\\n\");\n\t\tprintf(\"|6、查询某饭店或食堂的平均价格、评分和价格区间占比\\n\");\n\t\tprintf(\"|0、返回主菜单\\n\");\n\t\tcolor(2);\n\t\tprintf(\"|-----------------------------------------------------\\n\");\n\t\tcolor(11);\n\t\tprintf(\"请输入功能序号：\");\n\t\tcolor(15);\n\t\toptions = get_int();\n\t\tswitch (options)\n\t\t{\n\t\tcase 0:\n\t\t\tz = 0;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (menu_sort(p))\n\t\t\t\tinquire_all(p);\n\t\t\treturn;\n\t\tcase 2:\n\t\t\tinquire_one(p);\n\t\t\treturn;\n\t\tcase 3:\n\t\t\tif (menu_sort(p))\n\t\t\t\tinquire_restaurant(p);\n\t\t\treturn;\n\t\tcase 4:\n\t\t\tif (menu_sort(p))\n\t\t\t\tinquire_part_price(p);\n\t\t\treturn;\n\t\tcase 5:\n\t\t\tif (menu_sort(p))\n\t\t\t\tinquire_part_fraction(p);\n\t\t\treturn;\n\t\tcase 6:\n\t\t\taverage_percentage(p);\n\t\t\treturn;\n\t\tdefault:\n\t\t\tcolor(12);\n\t\t\tprintf(\"无该功能，请重新输入\\n\");\n\t\t\tcolor(11);\n\t\t\tsystem(\"pause\");\n\t\t}\n\t}\n}\nint menu_sort(List *list) //三级菜单_排序方法\n{\n\tint options, z = 1, n = 1;\n\tList *p = list;\n\twhile (z)\n\t{\n\t\tsystem(\"cls\");\n\t\tprintf(\"\\n\");\n\t\tcolor(2);\n\t\tprintf(\"|-----------------------------------------------------\\n\");\n\t\tcolor(15);\n\t\tprintf(\"|1、按价格从低到高排序\\n\");\n\t\tprintf(\"|2、按价格从高到低排序\\n\");\n\t\tprintf(\"|3、按评分从高到低排序\\n\");\n\t\tprintf(\"|4、不排序\\n\");\n\t\tprintf(\"|0、返回主菜单\\n\");\n\t\tcolor(2);\n\t\tprintf(\"|-----------------------------------------------------\\n\");\n\t\tcolor(11);\n\t\tprintf(\"请输入功能序号：\");\n\t\tcolor(15);\n\t\toptions = get_int();\n\t\tswitch (options)\n\t\t{\n\t\tcase 0:\n\t\t\tz = 0;\n\t\t\treturn z;\n\t\tcase 1:\n\t\t\tsort_ascending(p);\n\t\t\treturn n;\n\t\tcase 2:\n\t\t\tsort_descending(p);\n\t\t\treturn n;\n\t\tcase 3:\n\t\t\tsort_score(p);\n\t\t\treturn n;\n\t\tcase 4:\n\t\t\treturn n;\n\t\tdefault:\n\t\t\tcolor(12);\n\t\t\tprintf(\"无该功能，请重新输入\\n\");\n\t\t\tcolor(11);\n\t\t\tsystem(\"pause\");\n\t\t\tcolor(15);\n\t\t}\n\t}\n}\n//对节点操作\nvoid add(List *list) //添加节点\n{\n\tfloat k = 1;\n\tint n = 0, i = 0;\n\tNode *last = list->head;\n\tNode *p1 = (Node *)malloc(sizeof(Node)), *p; //给节点分配空间\n\tp1->next = NULL;\n\tsystem(\"cls\");\n\tputs(\"开始录入菜品：\\n----------------\\n\");\n\tputs(\"请输入菜品名称：\");\n\tdo\n\t{\n\t\ts_gets(p1->name, SIZE1);\n\t} while (strlen(p1->name) == 0);\n\tputs(\"请输入菜品所属饭店or食堂名称：\");\n\tdo\n\t{\n\t\ts_gets(p1->restaurant, SIZE1);\n\t} while (strlen(p1->restaurant) == 0);\n\tfor (p = list->head; p; p = p->next) //遍历链表\n\t{\n\t\tif (!(strcmp(p1->name, p->name) || strcmp(p1->restaurant, p->restaurant)))\n\t\t{\n\t\t\tcolor(12);\n\t\t\tprintf(\"该饭店/食堂内已存在同名菜品！\\n\");\n\t\t\tcolor(11);\n\t\t\tsystem(\"pause\");\n\t\t\treturn;\n\t\t}\n\t}\n\tputs(\"请输入菜品的价格：\");\n\tp1->price = get_float();\n\tputs(\"请输入0-10的整数对菜品进行评分：\");\n\tdo\n\t{\n\t\tn = get_int();\n\t\tif (n >= 0 && n <= 10) //判断评分是否是0-10\n\t\t{\n\t\t\tp1->fraction = n;\n\t\t\ti = 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcolor(12);\n\t\t\tputs(\"评分不在规定范围内，请重新输入：\");\n\t\t\tcolor(15);\n\t\t}\n\t} while (!i);\n\tputs(\"请对菜品进行评价：\");\n\tdo\n\t{\n\t\ts_gets(p1->comment, SIZE2);\n\t} while (strlen(p1->comment) == 0);\n\tif (last) //如果last有值，则说明head已指向链表第一个节点\n\t{\n\t\twhile (last->next)\n\t\t{\n\t\t\tlast = last->next; //last始终指向最后一个节点\n\t\t}\n\t\tlast->next = p1; //在最后一个节点后面再加一个节点\n\t}\n\telse\n\t{\n\t\tlist->head = p1; //如果last为NULL，则要将head指向第一个节点\n\t}\n\tcolor(11);\n\tputs(\"录入成功！\");\n\tsystem(\"pause\");\n}\nvoid delete (List *list) //删除节点\n{\n\tint n = 0;\n\tchar a[SIZE1];\n\tchar b[SIZE1];\n\tNode *p, *q;\n\tif (list->head == NULL)\n\t{ //判断链表是否为空\n\t\tprintf(\"还未存入任何菜品！删除失败！\\n\");\n\t\tsystem(\"pause\");\n\t\treturn;\n\t}\n\tsystem(\"cls\");\n\tprintf(\"请输入你要删除的菜品名称：\");\n\ts_gets(a, SIZE1);\n\tprintf(\"请输入菜品所属饭店名称：\");\n\ts_gets(b, SIZE1);\n\tfor (q = NULL, p = list->head; p; q = p, p = p->next)\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t   //遍历链表\n\t\tif (!(strcmp(a, p->name) || strcmp(b, p->restaurant))) //判断是否找到要修改的节点\n\t\t{\n\t\t\tn++;   //记录找到了\n\t\t\tif (q) //判断找到的是不是第一个节点\n\t\t\t{\n\t\t\t\tq->next = p->next; //让该节点的前一个节点都next指向后一个节点\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlist->head = p->next; //让head的next指向后一个节点\n\t\t\t}\n\t\t}\n\t}\n\tif (!n)\n\t{\n\t\tprintf(\"\\n没有这道菜！\\n\");\n\t}\n\telse\n\t{\n\t\tprintf(\"\\n删除成功%d道菜。\\n\", n);\n\t}\n\tcolor(11);\n\tsystem(\"pause\");\n}\nvoid revise(List *list) //修改节点\n{\n\tfloat k = 1;\n\tint n = 0, m = 0, i = 0;\n\tchar a[SIZE1];\n\tchar b[SIZE1];\n\tNode *p, *q;\n\tif (list->head == NULL) //判断链表是否为空\n\t{\n\t\tprintf(\"还未存入任何菜品！无法修改！\\n\");\n\t\tsystem(\"pause\");\n\t\treturn;\n\t}\n\tsystem(\"cls\");\n\tprintf(\"请输入要修改的菜品的名称：\");\n\ts_gets(a, SIZE1);\n\tprintf(\"请输入菜品所属饭店名称：\");\n\ts_gets(b, SIZE1);\n\tfor (q = NULL, p = list->head; p; q = p, p = p->next) //遍历链表\n\t{\n\t\tif (!(strcmp(a, p->name) || strcmp(b, p->restaurant))) //判断是否找到要删除的节点\n\t\t{\n\t\t\tn++; //记录找到\n\t\t\tprintf(\"\\n原来的菜品信息:\\n\");\n\t\t\tprintf(\"|菜名:%s\\n\", p->name);\n\t\t\tprintf(\"|所属:%s\\n\", p->restaurant);\n\t\t\tprintf(\"|价格:%.2f\\n\", p->price);\n\t\t\tprintf(\"|评分:%d\\n\", p->fraction);\n\t\t\tprintf(\"|评价:%s\\n\", p->comment);\n\t\t\tprintf(\"\\n\");\n\t\t\tputs(\"请修改菜品的价格：\");\n\t\t\tp->price = get_float();\n\t\t\tputs(\"请输入0-10的整数以修改菜品的评分：\");\n\t\t\tdo\n\t\t\t{\n\t\t\t\tm = get_int();\n\t\t\t\tif (m >= 0 && m <= 10)\n\t\t\t\t{\n\t\t\t\t\tp->fraction = m;\n\t\t\t\t\ti = 1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcolor(12);\n\t\t\t\t\tputs(\"评分不在规定范围内，请重新输入：\");\n\t\t\t\t\tcolor(15);\n\t\t\t\t}\n\t\t\t} while (!i);\n\t\t\tputs(\"请修改对菜品的评价：\");\n\t\t\tdo\n\t\t\t{\n\t\t\t\ts_gets(p->comment, SIZE2);\n\t\t\t} while (strlen(p->comment) == 0);\n\t\t}\n\t}\n\tif (n)\n\t{\n\t\tprintf(\"\\n修改完成。\\n\");\n\t}\n\telse\n\t{\n\t\tprintf(\"\\n没有这道菜！\\n\");\n\t}\n\tcolor(11);\n\tsystem(\"pause\");\n}\n//安全输入\nchar *s_gets(char *m, int n) //安全输入字符\n{\n\tchar *p;\n\tchar *find;\n\tp = fgets(m, n, stdin);\n\tif (p)\n\t{\n\t\tfind = strchr(m, '\\n'); //查找换行符\n\t\tif (find)\t\t\t\t//如果地址不是NULL\n\t\t\t*find = '\\0';\t\t//在此处放一个空字符\n\t\telse\n\t\t\twhile (getchar() != '\\n')\n\t\t\t\tcontinue;\n\t}\n\treturn p;\n}\nint get_int() //安全输入int型\n{\n\tint n;\n\tchar ch;\n\twhile (scanf(\"%d%*c\", &n) != 1)\n\t{\n\t\twhile ((ch = getchar()) != '\\n')\n\t\t\tputchar(ch);\n\t\tcolor(4);\n\t\tprintf(\" 不是一个正整数！\\n请您重新输入：\\n\");\n\t\tcolor(15);\n\t}\n\treturn n;\n}\nfloat get_float() //安全输入float型\n{\n\tfloat n = 1;\n\tchar ch;\n\tdo\n\t{\n\t\tif (n <= 0)\n\t\t{ //用户输入不是正数输出提示\n\t\t\tcolor(12);\n\t\t\tputs(\"请重新输入一个正数！\");\n\t\t\tcolor(15);\n\t\t}\n\t\twhile (scanf(\"%f%*c\", &n) != 1)\n\t\t{\n\t\t\twhile ((ch = getchar()) != '\\n')\n\t\t\t\tputchar(ch);\n\t\t\tcolor(12);\n\t\t\tprintf(\" 不是一个正数！\\n请您重新输入：\\n\");\n\t\t\tcolor(15);\n\t\t}\n\t} while (n <= 0);\n\treturn n;\n}\n//链表的输出和操作\nvoid inquire_all(List *list) //输出链表全部节点\n{\n\tNode *p;\n\tint n = 1;\n\tsystem(\"cls\");\n\tfor (p = list->head; p; p = p->next) //遍历链表\n\t{\n\t\tprintf(\"\\n第%d道菜:\", n);\n\t\toutput(p);\n\t\tn++;\n\t}\n\tcolor(11);\n\tprintf(\"\\n所有菜品查询完毕\\n\");\n\tsystem(\"pause\");\n}\nvoid inquire_one(List *list) //输出指定菜名\n{\n\tint n = 0;\n\tchar a[SIZE1];\n\tNode *p;\n\tsystem(\"cls\");\n\tprintf(\"请输入你要找的菜品名称：\");\n\ts_gets(a, SIZE1);\n\tfor (p = list->head; p; p = p->next) //遍历链表\n\t{\n\t\tif (!strcmp(a, p->name)) //判断是否找到\n\t\t{\n\t\t\toutput(p); //调用函数输出节点信息\n\t\t\tn++;\t   //记录找到多少节点\n\t\t}\n\t}\n\tcolor(11);\n\tprintf(\"\\n共查找到%d道菜\\n\", n);\n\tsystem(\"pause\");\n}\nvoid inquire_restaurant(List *list) //输出指定饭店所有菜品\n{\n\tint n = 0;\n\tchar a[SIZE1];\n\tNode *p;\n\tsystem(\"cls\");\n\tprintf(\"请输入你要找的饭店或食堂：\");\n\ts_gets(a, SIZE1);\n\tfor (p = list->head; p; p = p->next) //遍历链表\n\t{\n\t\tif (!strcmp(a, p->restaurant)) //判断是否找到\n\t\t{\n\t\t\toutput(p); //调用函数输出节点信息\n\t\t\tn++;\t   //记录找到多少节点\n\t\t}\n\t}\n\tcolor(11);\n\tprintf(\"\\n共查找到%d道菜\\n\", n);\n\tsystem(\"pause\");\n}\nvoid inquire_part_price(List *list) //输出一定价格以下的菜品(这功能。。贫穷)\n{\n\tint n = 0;\n\tfloat money, k = 1;\n\tchar a[SIZE1];\n\tNode *p;\n\tsystem(\"cls\");\n\tprintf(\"请输入封顶价格：\");\n\tmoney = get_float();\n\tfor (p = list->head; p; p = p->next) //遍历链表\n\t{\n\t\tif (p->price <= money) //判断是否符合要求\n\t\t{\n\t\t\toutput(p); //调用函数输出节点信息\n\t\t\tn++;\t   //记录找到多少节点\n\t\t}\n\t}\n\tcolor(11);\n\tprintf(\"\\n共查找到%d道菜\\n\", n);\n\tsystem(\"pause\");\n}\nvoid inquire_part_fraction(List *list) //输出一定评分以上的菜品\n{\n\tint n = 0;\n\tint score;\n\tchar a[SIZE1];\n\tNode *p;\n\tsystem(\"cls\");\n\tprintf(\"请输入最低评分：\");\n\tscore = get_int();\n\tfor (p = list->head; p; p = p->next) //遍历链表\n\t{\n\t\tif (p->fraction >= score) //判断是否符合要求\n\t\t{\n\t\t\toutput(p); //调用函数输出节点信息\n\t\t\tn++;\t   //记录找到多少节点\n\t\t}\n\t}\n\tprintf(\"\\n共查找到%d道菜\\n\", n);\n\tcolor(11);\n\tsystem(\"pause\");\n}\nvoid average_percentage(List *list) //查询某饭店或食堂的平均价格和评分\n{\n\tint n = 0;\n\tfloat sum1 = 0, sum2 = 0, b[5] = {0};\n\tchar a[SIZE1];\n\tNode *p;\n\tsystem(\"cls\");\n\tprintf(\"请输入你要查的饭店或食堂：\");\n\ts_gets(a, SIZE1);\n\tfor (p = list->head; p; p = p->next) //遍历链表\n\t{\n\t\tif (!strcmp(a, p->restaurant)) //判断是否找到\n\t\t{\n\t\t\tsum1 += p->price;\t //累加价格\n\t\t\tsum2 += p->fraction; //累加评分\n\t\t\tif (p->price <= 5)\n\t\t\t{\n\t\t\t\tb[0]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (p->price <= 10)\n\t\t\t\t{\n\t\t\t\t\tb[1]++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (p->price <= 15)\n\t\t\t\t\t{\n\t\t\t\t\t\tb[2]++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (p->price < 20)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tb[3]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tb[4]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tn++; //记录找到多少节点\n\t\t}\n\t}\n\tcolor(11);\n\tif (n)\n\t{\n\t\tprintf(\"该饭店/食堂的一共有%d道菜\\n平均价格是：%.2f\\t平均评分是：%.2f\\n\", n, sum1 / n, sum2 / n);\n\t\tprintf(\"其中：\\n0~5元占:%.1f%%\\n5~10元占:%.1f%%\\n10~15元占:%.1f%%\\n\", b[0] / n * 100, b[1] / n * 100, b[2] / n * 100);\n\t\tprintf(\"15~20元占:%.1f%%\\n20元以上占:%.1f%%\\n\\n\", b[3] / n * 100, b[4] / n * 100);\n\t}\n\telse\n\t{\n\t\tcolor(12);\n\t\tprintf(\"无该饭店或食堂！\\n\\n\");\n\t}\n\tcolor(11);\n\tsystem(\"pause\");\n}\nvoid output(Node *p) //方便输出\n{\n\tprintf(\"\\n|菜名:%s\\n\", p->name);\n\tprintf(\"|所属:%s\\n\", p->restaurant);\n\tprintf(\"|价格:%.2f\\n\", p->price);\n\tprintf(\"|评分:%d\\n\", p->fraction);\n\tprintf(\"|评价:%s\\n\", p->comment);\n}\nvoid random_menu(List *list) //随机输出一道菜\n{\n\tsystem(\"cls\");\n\tif (list->head == NULL) //判断链表是否为空\n\t{\n\t\tcolor(12);\n\t\tprintf(\"还未存入任何菜品！\\n\");\n\t\tcolor(11);\n\t\tsystem(\"pause\");\n\t\treturn;\n\t}\n\tList *q = list;\n\tNode *p = list->head;\n\tint n = random_number(q), i = 1; //将随机出来的数赋予n，并初始i等于第一道菜，判断数字是否相等，即可找到那个随机出来的菜\n\twhile (p != NULL)\n\t{\n\n\t\tif (i == n) //借助随机数来随机输出菜\n\t\t{\n\t\t\toutput(p);\n\t\t\tcolor(11);\n\t\t\tsystem(\"pause\");\n\t\t\treturn;\n\t\t}\n\t\ti++;\n\t\tp = p->next;\n\t}\n}\nvoid empty(List *list) //清空链表\n{\n\tNode *p, *q;\n\tint n;\n\tsystem(\"cls\");\n\tcolor(12);\n\tprintf(\"此操作将清空所有数据！\\n输入 1 继续，输入 0 取消：\\n\");\n\tdo\n\t{\n\t\tn = get_int();\n\t} while (!(n == 0 || n == 1));\n\tif (n == 1)\n\t{\n\t\tfor (p = list->head; p; p = q) //遍历链表\n\t\t{\n\t\t\tq = p->next;\n\t\t\tfree(p);\n\t\t}\n\t\tlist->head = NULL;\n\t\tprintf(\"清除完成！\\n\");\n\t\tsystem(\"pause\");\n\t\treturn;\n\t}\n}\n//文件操作\nvoid save(List *list) //保存\n{\n\tif (list->head == NULL)\n\t{\n\t\tcolor(12);\n\t\tprintf(\"还未存入任何菜品！保存为空！\\n\");\n\t\tcolor(11);\n\t\tsystem(\"pause\");\n\t\treturn;\n\t}\n\tNode *p = list->head;\n\tFILE *fp = fopen(\"Menu.txt\", \"w\");\n\tif (fp)\n\t{\n\t\twhile (p)\n\t\t{\n\t\t\tfprintf(fp, \"\\n%s %s %0.2f %d %s\", p->name, p->restaurant, p->price, p->fraction, p->comment);\n\t\t\tp = p->next;\n\t\t}\n\t\tfclose(fp);\n\t\tcolor(11);\n\t\tprintf(\"\\n保存成功\\n\");\n\t\tsystem(\"pause\");\n\t}\n\telse\n\t{\n\t\tcolor(12);\n\t\tprintf(\"保存失败，请自查或联系作者\");\n\t}\n}\nvoid read_txt(List *list) //读取文件_初始链表\n{\n\tint i = 1;\n\tNode *last;\n\tNode *p1;\n\tint a = 1;\n\tchar f[5];\n\tFILE *fp = fopen(\"Menu.txt\", \"r\");\n\tfgets(f, 10, fp); //读取第一行，并进入下一行，防止bug\n\twhile (!feof(fp)) //当读取到文件结束符跳出循环结束读取\n\t{\n\t\tlast = list->head;\n\t\tp1 = (Node *)malloc(sizeof(Node));\n\t\tp1->next = NULL;\n\t\tfscanf(fp, \"%s%s%f%d%s\", p1->name, p1->restaurant, &p1->price, &p1->fraction, p1->comment);\n\t\tif (last)\n\t\t{\n\t\t\twhile (last->next)\n\t\t\t{\n\t\t\t\tlast = last->next;\n\t\t\t}\n\t\t\tlast->next = p1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlist->head = p1;\n\t\t}\n\t}\n\tfclose(fp);\n}\n//单链表的冒泡排序，这指来指去，作者一口气写完到断气的，不想加注释了，应该会有更好的算法，咕咕咕，以后优化\nvoid sort_ascending(List *list) //菜品按价格从低到高排序\n{\n\tint n = 0, i, k, num;\n\tList *p = list;\n\tNode *p1 = list->head, *p2, *p3;\n\tList list_swap;\n\tn = calculate(p);\n\tlist_swap.pa = p1;\n\tlist_swap.pb = p2;\n\tlist_swap.pc = p3;\n\tfor (i = 0; i < n - 1; i++)\n\t{\n\t\tlist_swap.pa = list->head;\t\t   //当前\n\t\tlist_swap.pb = NULL;\t\t\t   //前一个\n\t\tlist_swap.pc = list_swap.pa->next; //下一个\n\t\tfor (k = 0; k < n - i - 1; k++)\n\t\t{\n\t\t\tif (list_swap.pa->price > list_swap.pc->price)\n\t\t\t{\n\t\t\t\tswap1(p, &list_swap);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tswap2(p, &list_swap);\n\t\t\t}\n\t\t}\n\t}\n}\nvoid sort_descending(List *list) //菜品按价格从高到低排序\n{\n\tint n = 0, i, k, num;\n\tList *p = list;\n\tNode *p1 = list->head, *p2, *p3;\n\tList list_swap;\n\tn = calculate(p);\n\tlist_swap.pa = p1;\n\tlist_swap.pb = p2;\n\tlist_swap.pc = p3;\n\tfor (i = 0; i < n - 1; i++)\n\t{\n\t\tlist_swap.pa = list->head;\t\t   //当前\n\t\tlist_swap.pb = NULL;\t\t\t   //前一个\n\t\tlist_swap.pc = list_swap.pa->next; //下一个\n\t\tfor (k = 0; k < n - i - 1; k++)\n\t\t{\n\t\t\tif (list_swap.pa->price < list_swap.pc->price)\n\t\t\t{\n\t\t\t\tswap1(p, &list_swap);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tswap2(p, &list_swap);\n\t\t\t}\n\t\t}\n\t}\n}\nvoid sort_score(List *list) //菜品按评分从高到低排序\n{\n\tint n = 0, i, k, num;\n\tList *p = list;\n\tNode *p1 = list->head, *p2, *p3;\n\tList list_swap;\n\tn = calculate(p);\n\tlist_swap.pa = p1;\n\tlist_swap.pb = p2;\n\tlist_swap.pc = p3;\n\tfor (i = 0; i < n - 1; i++)\n\t{\n\t\tlist_swap.pa = list->head;\t\t   //当前\n\t\tlist_swap.pb = NULL;\t\t\t   //前一个\n\t\tlist_swap.pc = list_swap.pa->next; //下一个\n\t\tfor (k = 0; k < n - i - 1; k++)\n\t\t{\n\t\t\tif (list_swap.pa->fraction < list_swap.pc->fraction)\n\t\t\t{\n\t\t\t\tswap1(p, &list_swap);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tswap2(p, &list_swap);\n\t\t\t}\n\t\t}\n\t}\n}\nint calculate(List *list) //计算出单链表的节点个数\n{\n\tint n = 0;\n\tNode *p = list->head;\n\twhile (p->next != NULL)\n\t{\n\t\tn++;\n\t\tp = p->next;\n\t}\n\treturn n + 1;\n}\nvoid swap1(List *list, List *list_swap) //单链表冒泡排序的算法块1\n{\n\tif (list_swap->pb)\n\t{\n\t\tlist_swap->pb->next = list_swap->pa->next;\n\t\tlist_swap->pa->next = list_swap->pc->next;\n\t\tlist_swap->pc->next = list_swap->pa;\n\t}\n\telse\n\t{\n\t\tlist->head = list_swap->pa->next;\n\t\tlist_swap->pa->next = list_swap->pc->next;\n\t\tlist_swap->pc->next = list_swap->pa;\n\t}\n\tlist_swap->pb = list_swap->pc;\n\tlist_swap->pc = list_swap->pa->next;\n}\nvoid swap2(List *list, List *list_swap) //单链表冒泡排序的算法块2\n{\n\tif (list_swap->pb)\n\t{\n\t\tlist_swap->pa = list_swap->pa->next;\n\t\tlist_swap->pc = list_swap->pa->next;\n\t\tlist_swap->pb = list_swap->pb->next;\n\t}\n\telse\n\t{\n\t\tlist_swap->pa = list_swap->pa->next;\n\t\tlist_swap->pc = list_swap->pa->next;\n\t\tlist_swap->pb = list->head;\n\t}\n}\n//其他\nint random_number(List *list) //随机生成不大于节点数的整数\n{\n\tint n = 0, m = 0, sum = 1, i = 0;\n\tList *q = list;\n\tsrand((unsigned)time(NULL) * 12);\n\tm = calculate(q);\n\ti = m;\n\twhile (m > 0)\n\t{\n\t\tsum = sum * 10;\n\t\tm = m / 10;\n\t}\n\twhile (1)\n\t{\n\t\tn = rand() % sum;\n\t\tif (n <= i && n > 0)\n\t\t{\n\t\t\ti = n;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn i;\n}\nvoid color(int a) //控制台文本颜色\n{\n\tSetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), a); //更改控制台文字颜色\n}\n\n```\n***\n\n# 部分功能截图\n**主菜单**\n<div><img src=/images/6-1.webp width=\"50%\" height=\"50%\"></div>\n\n**查找功能**\n<div><img src=/images/6-2.webp width=\"50%\" height=\"50%\"></div>\n<div><img src=/images/6-5.webp width=\"50%\" height=\"50%\"></div>\n<div><img src=/images/6-6.webp width=\"50%\" height=\"50%\"></div>\n<div><img src=/images/6-7.webp width=\"50%\" height=\"50%\"></div>\n\n**排序**\n<div><img src=/images/6-3.webp width=\"50%\" height=\"50%\"></div>\n\n**修改功能**\n<div><img src=/images/6-4.webp width=\"45%\" height=\"45%\"></div>\n\n***\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["C语言"],"categories":["项目"]},{"title":"C语言学习笔记","url":"/article/13675369.html","content":"\n# 整数运算\n两个整数运算结果也只能是整数  \na+=5等价于a=a+5  \na*=b+5等价于a=a*(b+5)  \na++等a+=1等a=a+1  \na++是a加1以前的值，++a是a加1后的值  \n运算符优先级：算数>关系>赋值，判断是否相等的优先级比大于小于低\n***\n# 所表达的数的范围\nchar< short<int< float<double\n***\n# sizeof()\nsizeof()是一个运算符,给出某个类型或变量在内存中所占据的字节数  \nsizeof()是静态运算符,它的结果在编译时刻就决定了，不要在 sizeof的括号里做运算,这些运算不会做的\n***\n# unsigned\nunsigned：如果一个字面量常数想要表达自己是 unsigned,可以在后面加u或U，255U用l或L表示long(long)  \nunsigned的初衷并非扩展数能表达的范围,而是为了做纯二进制运算,主要是为了移位\n***\n# 整数的输入输出\n只有两种形式:int或 long long  \n%d: int  \n%u: unsigned  \n%ld: longlong  \n%lu: unsigned long long\n***\n# 选搔整数类型\n为什么整数要有那么多种?为了准确表达内存,做底层程序的需要  \n没有特殊需要,就选int  \n现在的CPU的字长普遍是32位或64位,一次内存该写就是个int,一次计算也是一个int,选择更短的类型不会更快,甚至可能更慢  \n现代的编译器一般会设计内存对齐,所以更短的类型实际在内存中有可能也占据一个int的大小(虽然sizeof告诉你更小)\n***\nunsigned与否只是输出的不同,内部计算是一样的  \nprintf输出inf表示超过范围的浮点数:±∞  \nprint输出nan表示不存在的浮点数  \n带小数点的字面量是 double而非 float  \nfloat需要用或F后綴来表明身份  \n1.234f\n***\n判断两个浮点数是否相等可能失败  \nfabs(fl-2)< le-2//两个浮点数相减的绝对值小于一个很小的数，可认为两个浮点数相等\n***\n# 选浮点类型\n如果没有特殊需要,只使用 double  \n现代CPU能直接对 double做硬件运算,性能不会比float差,在64位的机器上,数据存儲的速度也不比float慢\n***\n# 自动类型转换\n当运算符的两边出现不一致的类型时,会自动转换成較大的类型  \n大的意思是能表达的数的范围更大  \nchar——> short——>int——>long——>long long  \nint——> float——> double  \n对于 printf,任何小于int的类型会被转换成int，float会被转换成 double  \n但是scanf不会,要输入short,需要%hd\n***\n# 强制类型转换\n要把一个量强制转换成另一个类型(通常是較小的类型),需要:(类型)值  \n比如：  \n(int)10.2  \n(short)32  \n注意这时候的安全性,小的变量不总能表达大的量  \n(short)32768  \n只是从那个变量计算出了一个新的类型的值,它并不改变那个变量,无论是值还是类型都不改变  \n强制类型转换的优先级高于四则运算\n***\n# 逻辑运算符优先级:\n!>&&>||\n***\n# 短路\n逻辑运算是自左向右进行的,如果左边的结果已经能够决定结果了,就不会做右边的计算  \na==6&&b==1  \na==6&&b+=1  \n对于&&,左边是 false时就不做右边了  \n对于‖,左边是true时就不做右边了  \n***\n# tip1\n不要把赋值,包括复合赋值组合进表达式!  \n一个代码内有重复相似段是程序质量不良的表现  \n函数是一块代,接收零个或多个参数做一件事情,并返回零个或一个值\n***\n# 数组的大小\nsizeof给出整个数组所占据的内容的大小,单位是字节  \nsizeof(a)/sizeof(a[0])  \nsizeof(a[0])给出数组中单个元素的大小,于是相除就得到了数组的单元个数  \n这样的代码,一旦修改数组中初始的数据,不需要修改遍历的代吗\n***\n# 数组的操作\n遍历数组：通常都是使用for循环,让循环变量i从0到<数组的长度,这样循环体内最大的正好是数组最大的有效下标  \n数组作为函数的参数时:不能在[]中给出数组的大小，不能再利用 sizeof来计算数组的元素个数!  \n数组作为函数参数时,往往必再用另一个参数来传入数组的大小\n# 作为参数的指针\nvoid f(int * p)  \n在被调用的时候得到了某个变量的地址  \nint i=O; f(&i)  \n在函数里面可以通过这个指针访问外面的这个  \n函数参数表中的数组实际上是指针  \nsizeof(a)==sizeof(int *)  \n但是可以用数组的运算符进行运算\n***\n# 指针是const\n表示一旦得到了某个变量的地址,不能再指向其他变量  \nint *const q=&i;//q是 const  \n*q=26;//OK  \nq++; //ERROR\n***\n# 所指是 const\n表示不能通过这个指针去修改那个变量(并不能使得那个变量成为 const)  \nconst int *p=&i  \n*p= 26; //ERROR!  \ni=26;//OK  \nP=&i;//OK\n***\n# const\nlnt i  \nconst int* p1 =&i  \nint const* p2=&i  \nint *const p3=&i  \n判断哪个被const了的标志是const在*的前面还是后面  \n*const p指针不许动  \nconst *p指针不许动变量\n***\n## 转换\n总是可以把一个非 const的值转換成 const的  \nvoid f(const int* x)  \nint a =15:  \nf(&a);//ok  \nconst int b = a  \nf(&b);//ok  \nb =a+1: // Error  \n当要传递的参数的类型比地址大的时候,这是常用的手段:既能用比較少的字节数传递值给参数,又能避免函数对外面的变量的修改\n***\n## const数组\nconst int a[]={1,2,3,4,5,6};  \n数组变量已经是 const的指针了,这里的 const表明数组的每个单元都是 const Int所以必须通过初始化进行赋值\n***\n## 保护数组值\n因为把数组传入函数时传递的是地址,所以那个函数内部可以修改数组的值  \n为了保护数组不被函数破坏,可以设置参数为 const  \nint sum(const int a[], int length);\n***\n# 指针\nint *p ：指针加一p+1是指加上一个sizeof(int)，将指针移到下一个单元  \nint *p=a[];  \n*p -->a[0]  \n*(p+1)-->a[1]  \n*(p++)可以遍历数组\n***\n给一个指针加|表示要让指针指向下一个变量  \nint a[l0]  \nint *p= a  \n*(p+1)-->a[1]  \n如果指针不是指向一片连分配的空间,如数组,则这种运算没有意义  \n*(p+n)<-->a[n]  \n*p*q两个指针相减p-q，等于q加多少个单元等于p\n***\n*p++  \n取出p所指的那个数据来,完事之后顺便把移到下一个位置去  \n*的优先级然高,但是没有++高  \n常用于数组类的连续空间操作  \n在某些CPU上,这可以直接被翻译成一条汇编指令\n\n指针乘除无意义\n***\n## 指针遍历数组方法 \n```\n*p a[10]\np=a\nfor(i=0;i<sizeof(a)/sizeof(a[0]); i++ ){\nprintf(\"%d\\n\", acri[i]);\n}  \na[9]=-1//在数组末尾放入一个特殊的东西\nwhile(*p!=-1){\nprintf(\"%d\\n\",*p++);\n}\n```\n***\n## 指针比較\n<,<=,==,>,>=,!=都可以对指针做  \n比较它们在内存中的地址  \n数组中的单元的地址肯定是线性从小到大递增的\n***\n## 0地址\n当然你的内存中有0地址,但是0地址通常是个不能随便碰的地址  \n所以你的指针不应该具有0值  \n\n因此可以用0地址来表示特殊的事情:  \n1返回的指针是无效的  \n2指针没有被真正初始化(先初始化为0)  \n\nNULL（必须是大写）是一个预定定义的符号,表示0地址  \n有的编译器不愿意你用0来表示0地址\n***\n## 指针的类型\n无论指向什么类型,所有的指针的大小都是一样的,因为都是地址  \n但是指向不同类型的指针是不能直接互相赋值的  \n这是为了避免用错指针\n## 指针的类型转换\nvoid*表示不知道指向什么东西的指针  \n计算时与char*相同(但不相通)\n\n指针也可以转换类型  \nint*p =&i  \nvoid*p<-->(void *)p  \n这并没有改变p所指的变量的类型,而是让后人用不同的眼光通过p看它所指的变量  \n我不再当你是int,我认为你就是个void!\n***\n## 用指针来做什么\n需要传入較大的数据时用作参数  \n传入数组后对数组做操作  \n函数返回不止一个结果是  \n需要用函数来修改不止一个变量  \n动态申请的内存\n***\n# 内存操作\n## malloc(跟系统要一块内存)\n```\n#include <stdlib. h>\nvoid*malloc(size_t size)\n//向malloc申请的空间的大小是以字节为单位返回的结果是void,需要类型转换为自己需要的类型\n(int *)malloc(n*sizeof(int))\n```\n如果申请失敗则返回0,或者叫做NULL\n***\n## free()\n把申请得来的空间还给“系统”  \n申请过的空间,最终都应该要还  \n只能还申请来的空间的首地址\n## free常见问题\n申请了没free—>长时间运行内存逐漸下降  \n新手:忘了  \n老手:找不到合的free的时机  \nfree过了再free  \n地址变过了,直接去free\n***\n# 字符串\nchar a[]={'h','a','l','l','o','!'}//字符数组  \nchar a[]={'h','a','l','l','o','!','\\0'}//字符串\n***\n以0(整数0)结尾的一串字符  \n0或'\\0'是一样的,但是和0不同  \n0标志字符串的结束,但它不是字符串的一部分  \n计算字符串长度的时候不包含这个0  \n字符串以数组的形式存在,以数组或指针的形式访问  \n更多的是以指针的形式  \nstring.h里有很多处理字符串的函数\n***\n```\nchar*str=\"Hello\"\nchar word[]=\"Hello\"\nchar linel[10]=\"Hello\"\n```\n***\n## 字符串常量\nChar* s=\"Hello, world\"  \n●s是一个指针,初始化为指向一个字符串常量 \n●由于这个常量所在的地方,所以实际上s是 const  \nchar*s,但是由于历史的原因,编译器接受不带const的写法  \n●但是试图对s所指的字符串做写入会导致严重的后果\n***\nchar S[]=\"Hello, world\"//这个字符串就在我这里  \nChar* s=\"Hello, world\"//指向某个地方的字符串  \n数组:这个字符串在这里(作为本地变量,空间自动被回收)  \n指针:这个字符串不知道在哪里(处理参数,动态分配空间)  \n如果要构造一个字符串一>数组  \n如果要处理一个字符串一>指针\n***\n## 字符串输入输出\n```\nchar string[8];\nscanf(\"%s\", string);\nprintf(\"%s\", string);\n//scanf读入一个単词(到空格、tab或回车为止)\n//scanf是不安全的,因为不知道要该入的内容的长度\nscanf(\"%7s\", string)\n//在%和s之间的数字表示最多允许该入的字符的数量,这个数字应该比数组的大小小\n```\n***\n## 空字符串\n```\nchar buffer[100]=\"\";\n//这是一个空的字符串, buffer[O]==\"\\0\";\nchar buffer[]=\"\";\n//这个数组的长度只有1\n```\n***\n## 复制一个字符串\n```\nchar*dst=(char*)malloc(strlen(src)+1)\nstrcpy(dst, src)\n```\n***\n# 枚挙\n枚挙是一种用戶定义的数据类型,它用关键字enum以如下语法来声明  \nenum枚挙类型名字{名字0,……,名字n};  \n\n枚挙类型名字通常并不真的使用,要用的是在大括号里的名字,因为它们就是就是常量符号,它们的类型是int,值则依次从0到n。如：  \nenum colors {red, yellow, green};  \n就创建了三个常量,red的值是0, yellow是1,而 green是2。  \n当需要一些可以排列起来的常量值时,定义枚举的意义就是给了这些常量值名字。\n>声明枚挙量的时候可以指定值\n>enum COLOR {RED=1, YELLOW, GREEN =5};\n\n***\n\n# 结构\n## 声明结构的形式\n```\nstruct point{\nint X;\nInt y;\n};\nstruct point p1, p2\n//pl和p2都是 point里面有x和y的值\n\nstruct {\nInt x;\nint y;\n}pl, p2;\n//pl和p2都是一种无名结构,里面有x和y\n\nstruct point {\nInt x;\nint y;\n}pl, p2;\n//pI和p2都是point, 里面有x和y的值t\n```\n>和本地变量一样,在函数内部声明的结构类型只能在函数内部使用  \n>所以通常在函数外部声明结构类型,这样就可以被多个函数所使用了\n\n***\n## 结构指针\n和数组不同,结构变量的名字并不是结构变量的地址,必须使用&运算符\n```\nstruct date*pdate= &today;\n```\n***\n## 结构作为函数参数\n```\nint numberofdays(struct date d)\n```\n整个结构可以作为参数的值传入函数  \n这时候是在函数内新建一个结构变量,并复制调用者的结构的值  \n也可以返回一个结构  \n这与数组完全不同\n***\n## 指向结构的指针\n```\nstruct date {\nint month;\nint day;\nint yeari;\n}myday;\nstruct date *p =&myday;\n(*p).month 12;\np->zmonth 12;\n//用->表示指针所指的结构变量中的成员\n```\n***\n# 全局变量初始化\n没有做初始化的全局变量会得到0值  \n指针会得到NULL值  \n只能用编译时刻已知的值来初始化全局变量  \n它们的初始化发生在main函数之前  \n全局变量不应该和另一个全局变量有联系  \n同名变量，本地变量优先级高于全局变量，即本地变量隐藏了全局变量\n***\n# 静态本地变量（全局生存期，本地作用域）\n在本地变量定义时加上 static修饰符就成为静态本地变量  \n当函数离开的时候,静态本地变量会銖存在并保持其值  \n静态本地变量的初始化只会在第一次进入这个函数时做（只做一次初始化）,以后进入函数时会保持上次离开时的值  \n静态本地变量实际上是特殊的全局变量，它们位于相同的内存区域  \n静态本地变量具有全局的生存期,函数内的局部作用域  \nstatic在这里的意思是局部作用域(本地可访问)\n>不要使用全局变量来在函数间传递参数和结果  \n>尽量避免使用全局变量  \n>丰田汽车的案子  \n>使用全局变量和静态本地变量的函数是线程不安全的  \n\n***\n# 返回指针的函数\n返回本地变量的地址是危险的  \n返回全局变量或静态本地变量的地址是安全的  \n返回在函数内 malloc的内存是安全的,但是容易造成问题  \n最好的做法是返回传入的指针\n***\n# 编译预处理指令\n#开头的是编译预处理指令  \n它们不是C语言的成分,但是C语言程序离不开它们\n***\n## #define(纯文本替换)\n#define用来定义一个宏  \n#define<名字><值>  \n注意没有结尾的分号,因为不是C的语句  \n名字必颁是一个单词,值可以是各种东西  \n在C语言的编译器开始编译之前,编译预处理程序  \n(cpp)会把程序中的名字换成值  \n完全的文本替换  \nacc-save-temps\n***\n## 宏\n如果一个宏的值中有其他的宏的名字,也是会被替换的  \n如果一个宏的值超过一行,最后一行之前的行末需要加  \\   \n宏的值后面出现的注释不会被当作宏的值的一部分\n***\n### 预定义的宏\n```\n_LINE_\n_FILE_\n_DATE_\n_TIME_\n_STDC_\n```\n### 带参数的宏\n```\n#define cube(x) ((x)*(x)*(x))\n```\n在大型程序的代吗中使用非常普遍  \n可以非常复杂,如“产生”函数:在#和##这两个运算符的帮助下  \n存在中西方文化差异  \n部分宏会被inline函数替代\n***\n# 变量的声明\nint i;是变量的定义  \nextern int i;是变量的声明\n***\n# 声明和定义\n声明是不产生代码的东西  \n函数原型  \n变量声明  \n结构声明  \n宏声明  \n枚挙声明  \n类型声明  \ninline函数  \n定义是产生代码的东西  \n头文件放声明是规则\n***\n# 重复声明\n同一个编译单元里,同名的结构不能被重复声明  \n如果你的头文件里有结构的声明,很难这个头文件不会在一个编译单元里被#include多次，所以需要\"标准头文件结构\"\n***\n# 标准头文件结构(宏的if)\n```\n#ifndef _LIST_HEAD_\n#define _LIST_HEAD_\n#include \"node.h\"\ntypedef struct _list{\n    Node* head\n    Node* tail\n}List\n#endif\n//运用条件编译和宏,保证这个头文件在一个编译单元中只会被#include一次\n#pragma once//也能起到相同的作用,但是不是所有的编译器都支持\n```\n\n# 链表\n>0建一个node结构  \n>1首选有个node结构(作为节点)，结构里有int(或者其他类型)变量去存数据，还有个同样结构的*next(next要等于下一个节点)（套娃）  \n>2读入数据，并新建一个node结构p，要让一个node结构head始终等于链表第一个节点  \n>3要有一个node结构last，每次要让last从head开始，直到last->next是空的，然后让next等于新的p结构（这样就链起来了）  \n>4每次读入新的数据，就新建一个p，然后让last从head开始遍历链表，直到last->next是空的，然后然后让next等于新的p结构  \n\n**要在函数内改变指针的指向，就要传指针的指针进去**\n***\n## 遍历链表\n```\nfor(p=list.head; p; p=p->next){}\n//单用一个指针p可以遍历链表\n```\n\n但要让删除链表中某一结点，需要另一个指针q，q一开始为null，后来始终指向p前一个节点  \n当p找到了要删除的节点，就让q->next等于p->next，然后free(p)  \nfor(q=null，p=list.head; p; q=p，p=p->next){}  \n当然还要判断链表的第一个元素是不是我们要删除的  \n如果是，就不能让q->next等于p->next，因为q一开始是NULL  \n我们应该让head->next等于p->next，然后free(p)  \n>\".\"一般情况下读作\"的”。  \n>\"->\"一般读作\"指向的结构体的\"。  \n\n***\n## 清除整个链表\n```\nfor(p=head;p;p=q){\n     q=p->next;\n     free(p)\n}\n//先让指针p等于head，让q始终指向p的下一个节点，然后free(p),再让p=q，p去等于下一个节点\n```\n\n***\n# main()\nmain(成为C语言的入口函数其实和C语言本身无关,你的代码是被一小段叫做启动代的程序所调用的,它需要叫做main的地方)  \n操作系统把你的可执行程序装载到内存里,启动运行,然后调用你的main函数  \n在不同操作系统，入口函数可能不是main()\n***","tags":["C语言"],"categories":["学习笔记"]},{"title":"博客搜索挂了解决方法","url":"/article/f8c79a1b.html","content":">省流助手：删除所有local-search.js中下面这行代码\n>window.pjax && window.pjax.refresh($resultContent)\n\n# 遇到的问题\n我使用的是本地搜索，local-search，装好后一直正常使用，也没去动过配置\n前天捣鼓着博客，突然发现博客部署到github上后搜索挂了\n<img src=/images/4-2.webp width=\"60%\" height=\"60%\">\n一直卡在数据库加载中\n\n但是，部署在本地，搜索却一切正常\n<img src=/images/4-3.webp width=\"60%\" height=\"60%\">\n尝试过重装插件，清除浏览器缓存，search.xml改为json，但过一会又挂了\n\n看网上也有不少人遇到这种问题，却找不到解决办法\n\n***\n\n# 解决过程\nlocal-search会请求生成在本地的search.xml，也就是数据库加载中里的“数据库”\n\n部署在本地时正常请求\n<img src=/images/4-8.webp width=\"80%\" height=\"80%\">\n而部署在github时没有请求\n<img src=/images/4-9.webp width=\"65%\" height=\"65%\">\n直接访问search.xml正常，不是search.xml的问题\n<img src=/images/4-5.webp width=\"60%\" height=\"60%\">\n查看报错，看起来是这个js的问题\n<img src=/images/4-6.webp width=\"60%\" height=\"60%\">\n本地找到local-search.js，这三个代码都一样\n<img src=/images/4-7.webp width=\"60%\" height=\"60%\">\njs中只有一处pjax报错\n<img src=/images/4-10.webp width=\"60%\" height=\"60%\">\n类型“Window & typeof globalThis”上不存在属性“pjax”。ts(2339)  \n\n\n看不懂这种报错，但问题多半就是这行代码导致的，查看整个js后，尝试删除此行\n```\nwindow.pjax && window.pjax.refresh($resultContent)\n```\n删除后，搜索挂了的问题解决，博客正常请求search.xml\n<img src=/images/4-8.webp width=\"70%\" height=\"70%\">\n\n但点击搜索结果后pjax失效，具体表现是aplayer停止播放音乐\n\n看来是pjax的bug，不过感知不强，其余地方的pjax仍然生效\n\n暂时先这样，以后找到更好的解决办法再更新\n\n***","tags":["Butterfly","Hexo"],"categories":["Hexo"]},{"title":"Hexo博客的基本操作","url":"/article/aa2a7b7e.html","content":"\n> **Hexo官方文档:**[Hexo](https://hexo.io/zh-cn/docs)\n\n# Hexo操作\n\n## 指令\n\n```js 新建文章，在blog\\source\\_posts\nhexo new post (文章名称)\n```\n```js 新建页面，在blog\\source\nhexo new page (页面名称)\n```\n```js 清除缓存文件 (db.json) 和已生成的静态文件 (public)\nhexo clean\n```\n```js 生成静态文件\nhexo g\n```\n```js 启动服务器，访问网址:http://localhost:4000\nhexo s\n```\n```js 部署网站\nhexo d\n```\n```js hexo三连,四连\nhexo cl && hexo g && hexo s\nhexo cl && hexo g && gulp && hexo d\n```\n```js push三连\ngit add .\ngit commit -m \"github action update\"\ngit push origin master\n```\n<br>\n\n## 文章操作\n\n>**Markdown 教程**\n>[菜鸟教程](https://www.runoob.com/markdown/md-tutorial.html)\n>[官网--Markdown基本语法](http://markdown.p2hp.com/basic-syntax/)\n\n\n> **blog\\scaffolds中修改三种文章模板**\n\n>*斜体文本* &emsp;\\*斜体文本\\* \n>**粗体文本** &emsp;\\*\\*粗体文本\\*\\*\n>***粗斜体文本*** &emsp;\\*\\*\\*粗斜体文本\\*\\*\\* \n>~~横线删除~~ &emsp;\\~\\~横线删除\\~\\~ \n\n>***水平分割线\n\n```html 文字蓝链 \n文字内容[tittle](https://*******)\n```\n```html 文章中自定义文本，size文字大小，face字体，color颜色，&emsp空格\n<font size=\"2\" face=\"verdana\" color=\"blue\" >&emsp;这是一个文本</font>\n\n```\n```html 插入自定义图片,\n\n<div align=left><img src=1.png width=\"25%\" height=\"25%\"></div>\n\n<div align=left><img src=1.png><img src=2.png></div>\n\n![文本](图片地址 \"鼠标悬停弹出文本提示\")\n```\n***\n","tags":["Hexo"],"categories":["Hexo"]},{"title":"测试用文章","url":"/article/d87f7e0c.html","content":"\nwaawdadadadadawdda\n11111111111111111111111111111\n241412\naaaaaaaaaa\n65767awdaad\n141212414114124121241\n<img src=\"https://cdn.nlark.com/yuque/0/2022/png/26795473/1659838729962-11aa244b-c946-45ac-bedb-c2278df4a1ce.png\" width=\"50%\" height=\"50%\">"},{"title":"第一篇文章：一点小小的说明与介绍","url":"/article/ff73d561.html","content":"\n# 本博的说明\n\n1.目前记录自己学习编程之路\n\n2.酷安机佬分享搞机\n\n3.记录日常\n\n4.欢迎交换友链\n\n5.更多\n\n***\n\n# 写博原因\n>不写博客不知道自己多牛B，写了博客就知道自己多lowB\n>~~博客不是你想写，想写就能写，这玩意儿需要大量知识，沉淀，研究，总结~~\n>博客就是自己想什么就写什么的哈，比如有个瞬间想法也可以写进去，记录下来！何必在意那么多！\n>~~把工作中需要用的技术和实现代码写到博客里，下次再用上就直接复制粘贴~~\n>>来自评论区[bilibili评论区](https://www.bilibili.com/video/BV1334y1q72q) \n\n写博明确的好处————CodeSheep\n1.培养总结能力\n2.面试加分项\n3.让自己的知识在某个地方留下痕迹，不流失\n4.加深对技术点的理解(写的过程=复现)\n5.帮助自己创建一个属于自己的知识体系\n6.踩坑记录\n7.获得阅读量，提高知名度，结交志同道合的朋友\n8.提高表达与写作能力\n9.·····\n\n**总之写博是提升自己方便自己的好途径**\n作为一只计科大一<font size=2>~~带学牲~~</font>，未来的程序员，写博是必要的\n\n***\n\n# CodeSheep的tip\n>写博客可以系统地整合自己某一阶段的学习成果\n\n>博客的方向：\n>可复现，能否解决实际问题\n\n>注意：\n>尊重知识产权，用别人的代码或者语言，记得表明来源。\n\n>入门：\n>备忘录，基础理解，踩坑的记录分享、学习笔记\n>实战类：\n>环境搭建，操作记录\n\n***\n\n# 为什么用hexo搭博客\n\n1.静态博客够用了\n\n2.hexo用的人多，遇到问题百度好解决\n\n3.主题丰富\n\n4.无需服务器 ~~部署到github/gitee无需软妹币~~\n\n>100天后我还是把博客主线路部署在腾讯云了，用上腾讯云与又拍云的cdn速度就是快\n","tags":["Chuckle"],"categories":["Chuckle"]}]